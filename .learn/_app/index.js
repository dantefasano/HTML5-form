var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function() {
  "use strict";
  var __vite_style__ = document.createElement("style");
  __vite_style__.textContent = '.lesson-container-component {\r\n  /* background-color: white; */\r\n  max-width: 1145px;\r\n  margin: 0 auto;\r\n  padding: 0px 15px;\r\n  overflow-y: scroll;\r\n  color: var(--read-font-color);\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 10px;\r\n  line-height: 1.5rem;\r\n}\r\n\r\n.lesson-content {\r\n  padding-bottom: 70px;\r\n  font-size: 20px;\r\n  line-height: 24px;\r\n}\r\n\r\n.lesson-content img {\r\n  margin: 5px auto;\r\n  max-width: 750px;\r\n  display: block;\r\n}\r\n\r\n.lesson-content h1 {\r\n  font-size: 32px;\r\n}\r\n\r\n.lesson-content h2 {\r\n  font-size: 25px;\r\n}\r\n\r\n.lesson-content h3 {\r\n  font-size: 20px;\r\n}\r\n\r\n.lesson-content code {\r\n  cursor: pointer;\r\n}\r\n\r\n.simple-button-svg {\r\n  max-height: 100% !important;\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 10px;\r\n  font-size: var(--font-size-medium);\r\n  opacity: 0.9;\r\n  transition: opacity 0.1s ease-in-out;\r\n  border: 1px solid transparent;\r\n}\r\n\r\n.simple-button-svg:hover {\r\n  opacity: 1;\r\n}\r\n.simple-button-svg.big {\r\n  padding: 10px 30px !important;\r\n}\r\n\r\n.simple-button-svg.bg-success svg path {\r\n  stroke: white !important;\r\n}\r\n.simple-button-svg.bg-blue svg path {\r\n  stroke: white !important;\r\n}\r\n\r\n.simple-button-svg.small {\r\n  padding: 5px 15px;\r\n}\r\n\r\n.simple-button-svg.mini {\r\n  padding: 0px;\r\n}\r\n.simple-button-svg.mini > svg {\r\n  max-height: 20px !important;\r\n  max-width: 20px !important;\r\n}\r\n\r\n.simple-button-svg:disabled {\r\n  opacity: 0.5;\r\n  cursor: not-allowed;\r\n}\r\n\r\n.simple-button-svg > svg {\r\n  max-height: 30px !important;\r\n  max-width: 30px !important;\r\n}\r\n\r\n.simple-button-svg > img {\r\n  max-height: 18px !important;\r\n  max-width: 18px !important;\r\n  filter: saturate(90%);\r\n}\r\n\r\n.feedback-container {\r\n  background-color: rgba(31, 31, 31, 0.821);\r\n  backdrop-filter: blur(1px);\r\n  position: absolute;\r\n  z-index: 2;\r\n  width: 100% !important;\r\n  min-height: 100% !important;\r\n}\r\n\r\n.feedback-component {\r\n  width: min(99%, 600px);\r\n  background-color: white;\r\n  padding: 10px;\r\n  border-radius: 10px;\r\n  position: absolute;\r\n  backdrop-filter: blur(10px);\r\n  top: 10%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 13px;\r\n  left: 50%;\r\n  transform: translate(-50%, 0%);\r\n}\r\n\r\n.feedback-component > .-header {\r\n  font-weight: bold;\r\n  padding: 5px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n}\r\n\r\n.feedback-component > .-header > button {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 5px;\r\n  font-size: 12px;\r\n  font-weight: 600;\r\n}\r\n\r\n.feedback-component > p {\r\n  font-size: 16px;\r\n}\r\n\r\n.feedback-component > .-content {\r\n  padding: 10px;\r\n  background-color: #f9f9f9;\r\n}\r\n\r\n.feedback-component > .-footer {\r\n  padding: 10px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  text-align: center;\r\n}\r\n\r\n.feedback-component > .-footer > div {\r\n  display: flex;\r\n  justify-content: space-around;\r\n}\r\n\r\n#socket-disconnected {\r\n  display: none;\r\n}\r\n\r\n.test-button {\r\n  background-color: red;\r\n  display: flex;\r\n  align-items: center;\r\n  padding: 10px;\r\n  border-radius: 10px;\r\n  color: yellow;\r\n  font-weight: 700;\r\n}\r\n\r\n.button {\r\n  background-color: var(--color-active);\r\n  border-radius: 7px;\r\n  color: white;\r\n  padding: 10px;\r\n}\r\n\r\n.button:hover {\r\n  color: white;\r\n}\r\n\r\n.text-center {\r\n  text-align: center;\r\n}\r\n\r\n.centered {\r\n  margin-inline: auto;\r\n}\r\n\r\n.on-hover-active:hover {\r\n  background-color: var(--color-active);\r\n  color: white;\r\n}\r\n\r\n.rounded {\r\n  border-radius: var(--standard-border-radius);\r\n}\r\n\r\n.rigo-thumbnail {\r\n  position: fixed;\r\n  bottom: 20px;\r\n  cursor: pointer;\r\n  right: 10px;\r\n  background-color: var(--color-active);\r\n  border-radius: 50%;\r\n  width: 50px;\r\n  height: 50px;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  z-index: 2;\r\n  border: var(--read-font-color) 2px solid;\r\n}\r\n\r\n.quiz-buttons-container {\r\n  display: flex;\r\n  gap: 10px;\r\n  justify-content: center;\r\n}\r\n.quiz-button {\r\n  padding: 10px;\r\n  border-radius: 10px;\r\n  border: 1px solid var(--color-active);\r\n  width: fit-content;\r\n\r\n  cursor: pointer;\r\n  transition: all 0.3s ease;\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 10px;\r\n}\r\n/* @tailwind base;\r\n@tailwind components;\r\n@tailwind utilities; */\r\n\r\n:root {\r\n  --bg-color-dark-gray: #a1a1a1;\r\n  --bg-color: #f9f9f9;\r\n  --app-bg-color: white;\r\n  --color-active: #02a9ea;\r\n  --4geeks-yellow: #ffd900;\r\n  --opaque-blue-editor: #a5d9f8;\r\n  --soft-blue-color: #eef9fe;\r\n  --color-blue-opaque: #eef9fe;\r\n  --color-blue: #c1dfed;\r\n  --tabs-bg-color: #f4faff;\r\n  --color-hovered: rgba(224, 224, 224, 0.665);\r\n  --color-success: #21b761;\r\n  --color-fail: #eb5757;\r\n  --bg-color-code: #f1fcffd5;\r\n  --link-inactive-color: #c1c1c1;\r\n  --backdrop-background: rgba(0, 0, 0, 0.7);\r\n  --soft-green: #a4ffbd;\r\n  --soft-red: #ffbebe;\r\n  --modals-bg-color: var(--bg-color);\r\n  --font-color-secondary: #9c9c9c;\r\n  --font-size-small: 16px;\r\n  --font-size-mini: 12px;\r\n  --font-size-medium: 18px;\r\n  --app-width: min(100%, 1111px);\r\n  --read-font-color: black;\r\n  --dropdown-bg-color: white;\r\n  --standard-border-radius: 8px;\r\n  font-size: 16px;\r\n}\r\n\r\n:root:has(main.dark) {\r\n  font-size: 16px;\r\n  --bg-color-dark-gray: #a1a1a1;\r\n  --bg-color: #111f39;\r\n  --app-bg-color: #00041a;\r\n  --app-bg-color-opaque: #00041a38;\r\n  --color-active: #02a9ea;\r\n  --4geeks-yellow: #ffd900;\r\n  --opaque-blue-editor: #a5d9f8;\r\n  --soft-blue-color: #eef9fe;\r\n  --color-blue-opaque: #003b5a77;\r\n  --color-hovered: rgba(95, 95, 95, 0.311);\r\n  --color-success: #21b761;\r\n  --color-fail: #eb5757;\r\n  --bg-color-code: #2d3748;\r\n  --link-inactive-color: #a9a9a9;\r\n  --backdrop-background: rgba(0, 0, 0, 0.7);\r\n  --tabs-bg-color: #1e1e1e;\r\n  --font-color-secondary: #9c9c9c;\r\n  --font-size-small: 16px;\r\n  --font-size-medium: 18px;\r\n  --dropdown-bg-color: var(--bg-color);\r\n  --read-font-color: white;\r\n}\r\n\r\n* {\r\n  margin: 0;\r\n  padding: 0;\r\n  box-sizing: border-box;\r\n  font-family: "Inter", sans-serif;\r\n}\r\n\r\nhtml {\r\n  font-size: 14px;\r\n  font-family: "Inter", sans-serif;\r\n}\r\nhtml:has(main.dark) {\r\n  color-scheme: dark light;\r\n}\r\n\r\nbody {\r\n  background-color: var(--bg-color);\r\n  overflow-x: hidden;\r\n  overflow-y: scroll;\r\n}\r\n\r\nimg {\r\n  width: 100%;\r\n}\r\n\r\nbutton {\r\n  border: 0;\r\n  background: transparent;\r\n}\r\nh1 {\r\n  font-size: 26px;\r\n  font-weight: 700;\r\n}\r\nhr {\r\n  margin-top: 15px;\r\n}\r\npre {\r\n  background-color: var(--bg-color-code);\r\n  padding: 10px;\r\n  border-left: 2px solid var(--color-active);\r\n  border-radius: 5px;\r\n  overflow: auto;\r\n}\r\ncode {\r\n  color: var(--read-font-color);\r\n  background-color: var(--bg-color-code);\r\n  cursor: pointer;\r\n}\r\ncode:not(pre code) {\r\n  padding: 2px 6px;\r\n  border-radius: 5px;\r\n}\r\nli {\r\n  padding-left: 0 !important;\r\n  margin-left: 20px !important;\r\n}\r\nul li {\r\n  list-style-type: disc;\r\n}\r\nol li {\r\n  list-style-type: decimal;\r\n}\r\nblockquote {\r\n  border-left: 2px solid var(--color-active);\r\n  padding: 2px 6px;\r\n  border-radius: 5px;\r\n  margin-top: 10px;\r\n  background-color: var(--color-hovered);\r\n}\r\nbutton {\r\n  cursor: pointer;\r\n}\r\n\r\ntable {\r\n  border-collapse: collapse;\r\n  width: 100%;\r\n}\r\nth {\r\n  background-color: var(--bg-color-code);\r\n  padding: 6px;\r\n  color: var(--read-font-color);\r\n  border: 1px solid rgb(130, 130, 130);\r\n}\r\ntd {\r\n  border: 1px solid rgb(130, 130, 130);\r\n  text-align: center;\r\n  padding: 4px;\r\n}\r\n\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nh6,\r\np {\r\n  margin-block: 15px;\r\n  line-height: 1.7;\r\n}\r\n\r\nform {\r\n  display: flex;\r\n  gap: 5px;\r\n  flex-direction: column;\r\n}\r\nform button {\r\n  width: fit-content;\r\n  padding: 7px;\r\n  cursor: pointer;\r\n  border-radius: 6px;\r\n}\r\nform input {\r\n  border: 1px solid gray;\r\n  border-radius: 8px;\r\n  padding: 10px;\r\n  width: 100%;\r\n}\r\n\r\n/* This will affect the entire webpage */\r\n::-webkit-scrollbar {\r\n  width: 5px;\r\n  height: 5px;\r\n}\r\n/* Handle */\r\n::-webkit-scrollbar-thumb {\r\n  background: rgba(\r\n    0,\r\n    0,\r\n    0,\r\n    0.433\r\n  ); /* Change the color and transparency as needed */\r\n}\r\n/* Handle on hover */\r\n::-webkit-scrollbar-thumb:hover {\r\n  background: var(--color-active);\r\n}\r\n\r\n.pill {\r\n  border-radius: 7px;\r\n  padding: 5px 5px;\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n.bg-blue {\r\n  background-color: var(--color-active) !important;\r\n  color: white;\r\n}\r\n.bg-blue > svg {\r\n  stroke: white;\r\n}\r\n\r\n.border-blue {\r\n  border: 1px solid var(--color-active);\r\n}\r\n.color-blue {\r\n  color: var(--color-active);\r\n}\r\n\r\n.bg-secondary {\r\n  background-color: rgba(231, 231, 231, 0.761);\r\n}\r\n.scrolleable {\r\n  overflow-y: auto !important;\r\n}\r\n\r\n.blue-circle {\r\n  background-color: var(--color-active);\r\n  border-radius: 50%;\r\n  padding: 10px;\r\n  margin-left: 10px;\r\n  width: 40px;\r\n  height: 40px;\r\n  position: relative;\r\n}\r\n.blue-circle > * {\r\n  position: absolute;\r\n  left: 50%;\r\n  font-size: 10px;\r\n  color: white;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n\r\n.pos-relative {\r\n  position: relative;\r\n}\r\n.pos-absolute {\r\n  position: absolute;\r\n}\r\n\r\n.bg-fail {\r\n  background-color: var(--color-fail) !important;\r\n}\r\n.bg-success {\r\n  background-color: var(--color-success) !important;\r\n}\r\n\r\n.dropdown {\r\n  display: flex;\r\n  flex-direction: column;\r\n  position: relative;\r\n}\r\n.dropdown-content {\r\n  display: none;\r\n  position: absolute;\r\n  min-width: 230px;\r\n}\r\n.dropdown:hover .dropdown-content {\r\n  display: flex;\r\n  flex-direction: column;\r\n\r\n  background-color: var(--dropdown-bg-color);\r\n  padding: 5px;\r\n  width: fit-content;\r\n\r\n  border-radius: var(--standard-border-radius);\r\n}\r\n\r\n.dropdown.up .dropdown-content {\r\n  bottom: 100%;\r\n  left: 0;\r\n}\r\n.dropdown.down .dropdown-content {\r\n  top: 100%;\r\n  left: 0;\r\n}\r\n\r\n.modal-container {\r\n  width: 100%;\r\n  height: 100vh !important;\r\n  position: absolute;\r\n  z-index: 10;\r\n  background-color: var(--backdrop-background);\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 10px;\r\n}\r\n\r\n.modal-container > div {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 8px;\r\n  background-color: white;\r\n  padding: 10px;\r\n  position: absolute;\r\n  top: 50%;\r\n  width: min(99%, 750px);\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n  border-radius: 10px;\r\n}\r\n\r\n.modal-container > div .modal-header {\r\n  font-weight: bolder;\r\n  font-size: 16px;\r\n}\r\n\r\n.modal-container > div .modal-content {\r\n  background-color: rgb(236, 232, 232);\r\n  padding: inherit;\r\n  border-radius: inherit;\r\n  position: relative;\r\n}\r\n\r\n.float-right {\r\n  position: absolute;\r\n  top: 10px;\r\n  right: 10px;\r\n}\r\n\r\n.text-white {\r\n  border: white;\r\n  color: white !important;\r\n}\r\n\r\n.text-white > svg {\r\n  stroke: white;\r\n}\r\n\r\n.d-block {\r\n  display: block;\r\n}\r\n\r\n.d-flex {\r\n  display: flex;\r\n}\r\n\r\n.space-between {\r\n  justify-content: space-between;\r\n}\r\n.justify-center {\r\n  justify-content: center;\r\n}\r\n.align-center {\r\n  align-items: center;\r\n}\r\n\r\n.palpitate {\r\n  animation: palpitate 1s ease-in infinite;\r\n  animation-play-state: running;\r\n}\r\n\r\n@keyframes palpitate {\r\n  0% {\r\n    opacity: 1;\r\n  }\r\n  0% {\r\n    opacity: 0.5;\r\n  }\r\n  100% {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n.justify-between {\r\n  justify-content: space-between;\r\n}\r\n.justify-around {\r\n  justify-content: space-around;\r\n}\r\n\r\n.separator {\r\n  justify-content: center;\r\n  display: flex;\r\n  color: var(--font-color-secondary);\r\n  align-items: center;\r\n  gap: 20px;\r\n}\r\n.separator > div {\r\n  width: 100%;\r\n  height: 1px;\r\n  background-color: var(--font-color-secondary);\r\n}\r\n\r\n.btn-dark {\r\n  border: 1px solid var(--bg-color-dark-gray);\r\n}\r\n.w-100 {\r\n  width: 100%;\r\n}\r\n\r\n.btn-dark:hover {\r\n  background-color: var(--color-hovered);\r\n}\r\n\r\n#main-container {\r\n  width: var(--app-width);\r\n  background-color: var(--app-bg-color);\r\n\r\n  margin-inline: auto;\r\n  height: 100vh;\r\n}\r\n\r\n#main-container.iframe-mode {\r\n  width: 100vw !important;\r\n}\r\n@media only screen and (min-width: 1111px) {\r\n  #main-container.iframe-mode {\r\n    margin-top: 0;\r\n  }\r\n}\r\n\r\n.badge {\r\n  width: 100%;\r\n  text-align: center;\r\n  padding: 10px;\r\n  border-radius: 4px;\r\n  cursor: pointer;\r\n}\r\n\r\n.clickeable:hover {\r\n  background-color: var(--color-hovered);\r\n}\r\n\r\n.min-width {\r\n  width: var(--app-width);\r\n}\r\n\r\n.gap-small {\r\n  gap: 5px;\r\n}\r\n.gap-big {\r\n  gap: 20px;\r\n}\r\n\r\n.my-2 {\r\n  margin-block: 20px;\r\n}\r\n.d-none {\r\n  display: none;\r\n}\r\n\r\n@media only screen and (min-width: 769px) {\r\n  .hide-continue-button {\r\n    display: none !important;\r\n  }\r\n}\r\n\r\n.browser {\r\n  position: relative;\r\n  background-color: rgba(203, 203, 203, 0.168);\r\n}\r\n.browser-tab {\r\n  padding: 4px 20px;\r\n  border-radius: 5px;\r\n  background-color: var(--soft-blue-color);\r\n  color: var(--color-active);\r\n  max-width: 300px;\r\n  text-overflow: ellipsis;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n}\r\n\r\n.browser-header {\r\n  background-color: #06758b2f;\r\n  border-radius: 5px;\r\n  padding: 2px;\r\n  position: absolute;\r\n  width: calc(100% - 8px);\r\n  left: 50%;\r\n  transform: translateX(-50%);\r\n  top: 10px;\r\n}\r\n.browser-body {\r\n  margin-top: 40px;\r\n  background-color: white;\r\n  overflow-y: auto;\r\n  height: calc(100% - 40px);\r\n}\r\n\r\n.danger-on-hover:hover {\r\n  background-color: var(--color-fail);\r\n}\r\n\r\n.svg-success svg path {\r\n  stroke: var(--color-success) !important;\r\n}\r\n.hover:hover {\r\n  background-color: rgba(163, 158, 158, 0.326) !important;\r\n}\r\n\r\n.preview-iframe {\r\n  border-radius: var(--standard-border-radius);\r\n  color: var(--read-font-color) !important;\r\n}\r\n.padding-medium {\r\n  padding: 10px;\r\n}\r\n.padding-small {\r\n  padding: 5px;\r\n}\r\n\r\n.bg-secondary {\r\n  background-color: var(--color-hovered);\r\n}\r\n.input {\r\n  padding: 10px;\r\n  border-radius: 8px;\r\n  border: 1px solid var(--color-hovered);\r\n}\r\n\r\n.text-blue {\r\n  color: var(--color-active);\r\n}\r\n\r\n.circle-small {\r\n  width: 30px;\r\n  height: 30px;\r\n  border-radius: 50%;\r\n}\r\n.vh100 {\r\n  height: 100vh;\r\n}\r\n.overflow-y-hidden {\r\n  overflow-y: hidden;\r\n}\r\n.justify-end {\r\n  justify-content: flex-end;\r\n}\r\n.flex-x {\r\n  display: flex;\r\n}\r\n.font-size-m {\r\n  font-size: var(--font-size-medium);\r\n}\r\n\r\n.pos-fixed {\r\n  position: fixed;\r\n}\r\n.hiddenOnMobile {\r\n  display: none;\r\n}\r\n.active-hr {\r\n  border-bottom: 2px solid var(--color-active);\r\n}\r\n@media only screen and (min-width: 768px) {\r\n  .hiddenOnMobile {\r\n    display: block;\r\n    text-align: center;\r\n  }\r\n}\r\n.inline-auto {\r\n  margin-inline: auto;\r\n}\r\n\r\n.d-block {\r\n  display: block;\r\n}\r\n.padding-big {\r\n  padding: 20px;\r\n}\r\n.active-on-hover {\r\n  transition: all 0.3s ease;\r\n}\r\n.active-on-hover:hover {\r\n  background-color: var(--color-active);\r\n  color: white;\r\n  scale: 1.05;\r\n}\r\n.active-on-hover:active {\r\n  scale: 0.99;\r\n}\r\n.preview-card {\r\n  max-width: 560px;\r\n  position: relative;\r\n}\r\n\r\n.preview-card .click {\r\n  margin-inline: auto;\r\n  display: block;\r\n  background-color: transparent !important;\r\n  display: flex;\r\n  justify-content: center;\r\n  height: 100%;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  align-items: center;\r\n  cursor: pointer;\r\n  font-size: 100px;\r\n  animation-fill-mode: backwards;\r\n}\r\n\r\n.preview-card .click:hover {\r\n  background-color: rgba(0, 0, 0, 0.5);\r\n  animation: scaleOnHover 0.5s ease 1 both;\r\n}\r\n\r\n@keyframes scaleOnHover {\r\n  from {\r\n    scale: 1;\r\n  }\r\n  to {\r\n    scale: 1.05;\r\n  }\r\n}\r\n\r\n.video-modal {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: var(--backdrop-background);\r\n  z-index: 1;\r\n}\r\n\r\n.video-modal .modal-content {\r\n  position: relative;\r\n  background-color: transparent;\r\n  display: flex;\r\n  flex-direction: column;\r\n  border-radius: 8px;\r\n  box-shadow: 0 0 20px rgba(153, 153, 153, 0.3);\r\n  width: fit-content;\r\n}\r\n.video-modal .click svg {\r\n  width: 150px;\r\n}\r\n\r\n.video-modal .close {\r\n  background-color: var(--color-active);\r\n  margin-top: 10px;\r\n  border-radius: 10px;\r\n  font-size: 21px;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  padding: 10px;\r\n  width: 100%;\r\n  opacity: 0.8;\r\n  color: white;\r\n  font-weight: 600;\r\n}\r\n\r\n.video-modal .close:hover {\r\n  opacity: 1;\r\n  background-color: var(--color-active);\r\n}\r\n\r\n.chat-modal {\r\n  background-color: var(--app-bg-color);\r\n  overflow-y: hidden;\r\n  position: fixed;\r\n\r\n  z-index: 2;\r\n  padding: 10px;\r\n  border-radius: 10px;\r\n  bottom: 80px;\r\n  height: 570px;\r\n  border: var(--opaque-blue-editor) 2px solid;\r\n  width: min(100vw - 20px, 500px);\r\n  right: 10px;\r\n}\r\n\r\n.chat-modal section {\r\n  margin-top: 10px;\r\n}\r\n\r\n.chat-modal .chat-header {\r\n  position: relative;\r\n  align-items: center;\r\n  justify-content: center;\r\n  text-align: center;\r\n}\r\n\r\n.chat-modal .chat-header button {\r\n  color: var(--background-color-code);\r\n  position: absolute;\r\n  top: 50%;\r\n  right: 0px;\r\n  transform: translateY(-50%);\r\n}\r\n\r\n/* .chat-modal .chat-header button svg path {\r\n  stroke: var(--bg-color-code);\r\n} */\r\n\r\n.chat-modal .chat-messages {\r\n  overflow-y: scroll;\r\n  height: 66%;\r\n  /* background-color: red; */\r\n}\r\n\r\n.chat-modal .chat-input {\r\n  display: flex;\r\n  position: relative;\r\n  width: 100%;\r\n  align-items: center;\r\n}\r\n\r\n.chat-modal .chat-input textarea {\r\n  width: 100%;\r\n  padding: 5px;\r\n  resize: vertical;\r\n  border-radius: 8px;\r\n  padding-right: 40px;\r\n  border: 0;\r\n  border: 1px solid var(--font-color-secondary);\r\n  outline: none;\r\n  min-height: 70px;\r\n  font-size: 16px;\r\n}\r\n\r\n.chat-modal .chat-input button {\r\n  position: absolute;\r\n  padding: 10px;\r\n  display: flex;\r\n  border-radius: 50%;\r\n  right: 10px;\r\n  border: 1px solid var(--font-color-secondary);\r\n}\r\n\r\n.chat-modal .chat-input button svg path {\r\n  stroke: var(--font-color-secondary);\r\n}\r\n\r\n.chat-modal .chat-input button:hover {\r\n  background-color: #02a8ea;\r\n  color: var(--read-font-color);\r\n}\r\n.chat-modal .chat-input :hover svg path {\r\n  stroke: var(--read-font-color);\r\n}\r\n\r\n.chat-modal .chat-footer {\r\n  font-size: 16px;\r\n  color: var(--read-font-color);\r\n  position: relative;\r\n  display: flex;\r\n  justify-content: end;\r\n}\r\n.chat-footer:has(.informative-opener:hover) .informative-message {\r\n  display: block;\r\n}\r\n\r\n.chat-footer .informative-message {\r\n  display: none;\r\n  position: absolute;\r\n  bottom: calc(100% + 10px);\r\n  background-color: var(--app-bg-color);\r\n  border: 1px solid var(--font-color-secondary);\r\n  border-radius: 10px;\r\n  padding: 10px;\r\n}\r\n\r\n.next-button {\r\n  background-color: #9f9f9f;\r\n  margin-top: 5px;\r\n  border-radius: 7px;\r\n  font-weight: 600;\r\n  color: black;\r\n  padding: 10px;\r\n}\r\n\r\n.message {\r\n  background-color: var(--color-hovered);\r\n  padding: 10px;\r\n  border-radius: 9px;\r\n  margin-top: 5px;\r\n  line-height: 25px;\r\n  word-break: break-word;\r\n}\r\n\r\n.message.user {\r\n  background-color: transparent;\r\n}\r\n\r\n.message p:not(:first-child) {\r\n  margin-top: 15px;\r\n}\r\n\r\n.alert {\r\n  background-color: var(--4geeks-yellow);\r\n  padding: 3px 10px;\r\n  border-radius: 10px;\r\n  color: black;\r\n  font-weight: bold;\r\n  text-align: center;\r\n}\r\n.self-closing-modal {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  background-color: var(--backdrop-background);\r\n  width: 100vw !important;\r\n  height: 100% !important;\r\n  display: grid;\r\n  place-content: center;\r\n  z-index: 2;\r\n}\r\n\r\n.self-closing-modal > div.modal-content {\r\n  display: block;\r\n  border-radius: 20px;\r\n  flex-direction: column;\r\n  background-color: var(--modals-bg-color);\r\n  padding: 20px;\r\n  width: min(600px, 98vw);\r\n  gap: 10px;\r\n  margin-inline: auto;\r\n  overflow: auto;\r\n  max-height: 95vh;\r\n  position: relative;\r\n}\r\n\r\n.self-closing-modal .modal-closer {\r\n  position: absolute;\r\n  right: 20px;\r\n  top: 25px;\r\n  z-index: 2;\r\n  cursor: pointer;\r\n}\r\n\r\n.icon-component {\r\n  background-color: red;\r\n}\r\n.input-modal {\r\n  text-align: center;\r\n  background-color: var(--modals-bg-color);\r\n  color: var(--read-font-color);\r\n  padding: 20px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 10px;\r\n}\r\n\r\n.presentator {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100vw;\r\n  height: 100vh;\r\n  background: rgba(141, 141, 141, 0.402);\r\n  z-index: 0;\r\n  cursor: initial;\r\n}\r\n\r\n._badge {\r\n  position: fixed;\r\n  width: min(\r\n    90%,\r\n    330px\r\n  ); /* Ajustado de 50vw a un valor fijo para mejor control */\r\n  /* max-height: fit-content; */\r\n  border-radius: 5px; /* Suavizado de las esquinas */\r\n  text-align: left;\r\n  background-color: rgb(255, 255, 255);\r\n  border: 1px solid rgba(127, 127, 127, 0.3);\r\n  padding: 15px;\r\n  top: 50vh;\r\n  left: 50%;\r\n  /* transform: translateX(-50%); */\r\n  z-index: 2;\r\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Sombra más sutil */\r\n\r\n  > h2 {\r\n    color: rgb(0, 0, 0);\r\n    margin-bottom: 10px;\r\n    font-size: 25px;\r\n  }\r\n  > div._content > * {\r\n    margin-top: 5px;\r\n    line-height: 1.5rem;\r\n  }\r\n  > ._footer {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    flex-direction: row;\r\n  }\r\n  > p {\r\n    color: black;\r\n    font-size: 1rem; /* Tamaño de fuente reducido para mejor legibilidad */\r\n    font-weight: 400;\r\n    margin-top: 0;\r\n  }\r\n}\r\n.reset-modal {\r\n  text-align: center;\r\n}\r\n.reset-modal > section {\r\n  display: flex;\r\n  justify-content: center;\r\n  width: 100%;\r\n  gap: 20px;\r\n}\r\n.login-modal {\r\n  font-size: 16px;\r\n}\r\n\r\n.login-modal h2 {\r\n  text-align: center;\r\n}\r\n\r\n.login-modal > div div:has(button) {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  gap: 5px;\r\n}\r\n\r\n.login-modal button {\r\n  font-size: 16px;\r\n}\r\n.login-modal input {\r\n  font-size: 16px;\r\n}\r\n.sidebar-component {\r\n  width: 100vw;\r\n  height: 100vh;\r\n  position: absolute;\r\n  left: 101%;\r\n  top: 0;\r\n  font-size: 17px;\r\n  z-index: 2;\r\n  background-color: var(--app-bg-color);\r\n  animation: appear-4-right 0.5s ease 1 forwards;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n}\r\n\r\n.sidebar-component section h2 {\r\n  text-align: center;\r\n  padding: 10px;\r\n  margin-block: 0;\r\n  width: 100%;\r\n}\r\n\r\n.sidebar-component > section:not(:last-child) {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  padding: 2px 14px;\r\n}\r\n\r\n.sidebar-component .footer {\r\n  background-color: transparent;\r\n  position: fixed;\r\n  bottom: 0;\r\n  width: var(--app-width);\r\n  padding: 15px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n\r\n}\r\n\r\n.sidebar-component .footer > a {\r\n  padding: 10px;\r\n  text-decoration: none;\r\n  color: var(--read-font-color);\r\n  display: block;\r\n  border-radius: 8px;\r\n}\r\n\r\n.sidebar-component .footer > a:hover {\r\n  background-color: var(--color-hovered);\r\n}\r\n\r\n.sidebar-component .exercise-list {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 5px;\r\n  margin-bottom: 70px;\r\n  padding: 10px;\r\n  max-height: 83vh !important;\r\n  overflow-y: scroll;\r\n  width: var(--app-width);\r\n  margin-inline: auto;\r\n  padding-bottom: 100px;\r\n}\r\n\r\n.exercise-list li.exercise-card {\r\n  background-color: var(--color-blue-opaque);\r\n  margin-left: 0 !important;\r\n  display: flex;\r\n  padding: 10px 11px;\r\n  cursor: pointer;\r\n  justify-content: space-between;\r\n  font-size: 18px;\r\n  border-radius: 15px;\r\n  align-items: center;\r\n  opacity: 1;\r\n}\r\n\r\n.sidebar-component .exercise-list li.exercise-card:hover {\r\n  background-color: var(--color-hovered);\r\n}\r\n\r\n.exercise-list li.exercise-card > div {\r\n  display: flex;\r\n  gap: 10px;\r\n  align-items: center;\r\n}\r\n\r\n.sidebar-disappear {\r\n  animation: disappear-4-right 0.4s ease 1 forwards;\r\n}\r\n\r\n@keyframes appear-4-right {\r\n  0% {\r\n    left: 101%;\r\n  }\r\n\r\n  100% {\r\n    left: 0px;\r\n  }\r\n}\r\n\r\n@keyframes disappear-4-right {\r\n  0% {\r\n    left: 0px;\r\n  }\r\n\r\n  100% {\r\n    left: 101%;\r\n  }\r\n}\r\n._header_13t9m_1 {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  padding: 10px;\r\n  align-items: center;\r\n  background-color: transparent;\r\n}\r\n\r\n._header_13t9m_1 > section {\r\n  display: flex;\r\n  gap: 8px;\r\n}\r\n\r\n._header_13t9m_1 > section > button:disabled {\r\n  cursor: not-allowed;\r\n  opacity: 0.5;\r\n}\r\n._container_1uhni_1 {\r\n  display: flex;\r\n  gap: 8px;\r\n  background-color: var(--container-bg-color);\r\n  flex-wrap: wrap;\r\n}\r\n\r\n._container_1uhni_1 > section {\r\n  padding: 8px;\r\n  /* height: 100%; */\r\n  width: 100%;\r\n  max-height: 83vh;\r\n  overflow: auto;\r\n}\r\n\r\n._container_1uhni_1 > section:first-child {\r\n  background-color: white;\r\n}\r\n\r\n._container_1uhni_1 h3:first-child {\r\n  text-align: center;\r\n  font-family: monospace;\r\n}\r\n\r\n\r\n._appTabs_1uhni_51 {\r\n  display: flex;\r\n  background-color: var(--tabs-bg-color);\r\n  justify-content: space-between;\r\n  width: 100%;\r\n}\r\n._appTabs_1uhni_51 > div {\r\n  width: 100%;\r\n  text-align: center;\r\n  padding: 10px;\r\n  color: #728ec0;\r\n  border-bottom: 1px solid transparent;\r\n  cursor: pointer;\r\n}\r\n\r\n._appTabs_1uhni_51 > div[data-visible="true"] {\r\n  background-color: var(--bg-color);\r\n  color: var(--color-active);\r\n  border-bottom: 3px solid var(--color-active);\r\n}\r\n._hiddenOnMobile_1uhni_91 {\r\n  display: none;\r\n}\r\n\r\n@media only screen and (min-width: 768px) {\r\n  ._container_1uhni_1 {\r\n    display: flex;\r\n    gap: 8px;\r\n    flex-wrap: nowrap;\r\n    /* padding: 3px; */\r\n  }\r\n\r\n  ._container_1uhni_1 > section {\r\n    padding: 8px;\r\n    width: 100%;\r\n  }\r\n  ._appTabs_1uhni_51 {\r\n    display: none;\r\n  }\r\n  ._hiddenOnMobile_1uhni_91 {\r\n    display: block;\r\n    text-align: center;\r\n  }\r\n}\r\n.tabs {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 2px;\r\n}\r\n.tab {\r\n  display: flex;\r\n  background-color: var(--bg-color);\r\n  border-top-right-radius: 6px;\r\n  border-top-left-radius: 6px;\r\n}\r\n\r\n.tabs button {\r\n  padding: 5px 6px;\r\n  cursor: pointer;\r\n  transition: background-color 0.3s ease;\r\n}\r\n\r\n.tab .close-tab {\r\n  color: black !important;\r\n}\r\n.tab.active {\r\n  background-color: var(--opaque-blue-editor);\r\n}\r\n\r\n.tab.active button {\r\n  color: var(--color-active);\r\n}\r\n\r\n.tabs button.add-tab {\r\n  color: rgb(0, 0, 0);\r\n  border: none;\r\n}\r\n\r\n.theme-selector {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 10px;\r\n  display: none;\r\n}\r\n.theme-selector select {\r\n  border-radius: 8px;\r\n  padding: 3px;\r\n}\r\n\r\n.editor {\r\n  border: 7px solid #a5d9f8;\r\n  border-radius: 5px;\r\n  border-top-left-radius: 0;\r\n  position: relative;\r\n  \r\n}\r\n\r\n.editor-monaco .view-lines,\r\n.editor-monaco .margin-view-overlays {\r\n  height: min(300px, fit-content) !important;\r\n}\r\n.terminal {\r\n  border-radius: 5px;\r\n  border: 8px solid #a5d9f8;\r\n  margin-top: -8px;\r\n  padding: 8px;\r\n  height: 300px;\r\n  overflow-y: auto;\r\n  position: relative;\r\n\r\n  /* padding-bottom: 20px; */\r\n}\r\n.terminal.html {\r\n  height: min(400px, fit-content);\r\n  overflow-y: auto;\r\n  border: none;\r\n  padding-bottom: 8px;\r\n}\r\n.terminal.only {\r\n  margin-top: 0;\r\n  border: 0;\r\n  max-height: 500px;\r\n  & .editor-footer {\r\n    margin-top: 20px;\r\n    display: block;\r\n    position: relative;\r\n  }\r\n}\r\n.terminal.hidden {\r\n  display: none;\r\n}\r\n.terminal > h5 {\r\n  border-bottom: 1px solid #dadada;\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n}\r\n\r\n.terminal > pre {\r\n  background-color: var(--bg-color);\r\n  border: none;\r\n  max-width: 100%;\r\n  height: fit-content F;\r\n  word-break: break-word !important;\r\n  white-space: pre-wrap;\r\n}\r\n.terminal > pre > code {\r\n  word-wrap: break-word;\r\n}\r\n.editor-footer {\r\n  background-color: var(--bg-color);\r\n  position: absolute;\r\n  bottom: 8px;\r\n  padding: 8px;\r\n  width: calc(100% - 16px);\r\n  left: 8px;\r\n  border-radius: 8px;\r\n  font-size: 12px;\r\n}\r\n\r\n.editor-footer.UNMODIFIED {\r\n  background-color: var(--modals-bg-color);\r\n}\r\n.editor-footer.MODIFIED {\r\n  background-color: var(--modals-bg-color);\r\n}\r\n\r\n.editor .editor-footer.success {\r\n  background-color: var(--soft-green);\r\n}\r\n\r\n.editor .editor-footer.error {\r\n  color: white !important;\r\n  background-color: var(--soft-red);\r\n}\r\n\r\n.editor-footer .not-started {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 9px;\r\n  color: var(--color-active);\r\n  padding: 4px;\r\n  justify-content: space-between;\r\n  font-size: 12px;\r\n}\r\n.editor-footer .not-started span {\r\n  font-size: 12px;\r\n}\r\n\r\n.editor-footer .not-started > div:first-child {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 5px;\r\n}\r\n.editor-footer .footer-actions {\r\n  padding: 4px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  gap: 4px;\r\n}\r\n\r\n.editor-footer .footer-actions > div > button,\r\n.editor-footer .footer-actions > button,\r\n.editor-footer .footer-actions > div {\r\n  width: 100%;\r\n  padding: 5px;\r\n  border-radius: 4px;\r\n  display: flex;\r\n  font-size: 12px;\r\n  justify-content: center;\r\n  align-items: center;\r\n  gap: 5px;\r\n  color: var(--color-active);\r\n}\r\n.editor-footer.success {\r\n  background-color: var(--soft-green);\r\n\r\n  & .footer-actions > button svg path {\r\n    stroke: var(--color-success);\r\n  }\r\n  & .footer-actions > div > button > svg path {\r\n    stroke: var(--color-success);\r\n  }\r\n  & .footer-actions > div {\r\n    color: var(--color-success);\r\n  }\r\n  & .footer-actions > button {\r\n    color: black;\r\n  }\r\n  & .footer-actions > div > button {\r\n    color: black;\r\n  }\r\n}\r\n.editor-footer.error {\r\n  background-color: var(--soft-red);\r\n\r\n  & .footer-actions > button svg path {\r\n    stroke: var(--color-fail);\r\n  }\r\n  & .footer-actions > div > button > svg path {\r\n    stroke: var(--color-fail);\r\n  }\r\n  & .footer-actions > div > button {\r\n    color: var(--color-fail);\r\n  }\r\n  & .footer-actions > button {\r\n    color: var(--color-fail);\r\n  }\r\n  & .footer-actions > div {\r\n    color: var(--color-fail);\r\n  }\r\n}\r\n\r\n.footer-actions button {\r\n  font-size: 15px !important;\r\n}\r\n.editor-footer .footer-actions > button svg,\r\n.editor-footer .footer-actions > div svg {\r\n  height: 15px;\r\n}\r\n.editor-footer .footer-actions > button svg path,\r\n.editor-footer .footer-actions > div > button > svg path {\r\n  stroke: var(--color-active);\r\n}\r\n\r\n.editor-footer .footer-actions button.active {\r\n  background-color: var(--color-active);\r\n  color: white;\r\n}\r\n.editor-footer .footer-actions button.active svg path {\r\n  stroke: white;\r\n}\r\n.app-header {\r\n  animation: scale-navbar auto linear both;\r\n  animation-timeline: scroll();\r\n  animation-range: 10px 150px;\r\n  position: sticky;\r\n  top: 0;\r\n}\r\n\r\n.app-header:hover {\r\n  opacity: 1 !important;\r\n}\r\n\r\n.navbar-component {\r\n  padding: 10px 10px;\r\n  background-color: var(--bg-color);\r\n  display: flex;\r\n  width: 100%;\r\n  transition: all 2s;\r\n  margin: 0 auto;\r\n  max-width: 1145px;\r\n  justify-content: space-between;\r\n}\r\n\r\n.navbar-component > section {\r\n  display: flex;\r\n  gap: 3px;\r\n  align-items: center;\r\n}\r\n.navbar-component > section > button,\r\n.navbar-component > section > div {\r\n  border: 1px solid var(--color-active);\r\n  border-radius: 5px;\r\n}\r\n\r\n.lesson-options {\r\n  display: flex;\r\n  align-items: center;\r\n  background-color: var(--bg-color);\r\n  margin: 0 auto;\r\n  max-width: 1145px;\r\n  padding: 8px;\r\n  justify-content: space-between;\r\n}\r\n\r\n.lesson-options > div {\r\n  display: flex;\r\n  gap: 10px;\r\n  align-items: center;\r\n}\r\n\r\n.lesson-options button:disabled {\r\n  opacity: 0.5;\r\n  cursor: not-allowed;\r\n}\r\n\r\n@keyframes scale-navbar {\r\n  from {\r\n  }\r\n\r\n  to {\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n.feedback-dropdown {\r\n  position: absolute;\r\n  width: 250px !important;\r\n  padding: 2px;\r\n  border: 1px solid var(--color-active);\r\n  background-color: var(--modals-bg-color);\r\n  border-radius: 7px;\r\n  max-width: 300px;\r\n  font-size: var(--font-size-small);\r\n  display: flex;\r\n  gap: 5px;\r\n  align-items: baseline !important;\r\n  z-index: 4;\r\n  flex-direction: column;\r\n}\r\n.feedback-dropdown.up {\r\n  bottom: 103%;\r\n  right: 0;\r\n}\r\n.feedback-dropdown.down {\r\n  top: 103%;\r\n  left: -75%;\r\n}\r\n\r\n.feedback-dropdown > * {\r\n  width: fit-content;\r\n}\r\n\r\n.feedback-dropdown > button {\r\n  color: var(--color-active);\r\n  width: 100%;\r\n  padding: 7px;\r\n  text-align: left;\r\n  display: flex;\r\n  justify-content: left;\r\n  align-items: center;\r\n}\r\n\r\n.feedback-dropdown > button:hover {\r\n  background-color: var(--color-blue-opaque);\r\n}\r\n\r\n.feedback-dropdown > p {\r\n  padding: 3px;\r\n  background-color: var(--bg-color);\r\n  margin: 0;\r\n  font-size: var(--font-size-mini);\r\n  color: var(--read-font-color);\r\n}\r\n\r\n.feedback-dropdown > p > a {\r\n  font-weight: 600;\r\n  color: var(--color-active);\r\n  cursor: pointer;\r\n}\r\n\r\n#feedback-button {\r\n  min-width: fit-content;\r\n}\r\n\r\n.language-dropdown {\r\n  display: flex;\r\n  position: absolute;\r\n  top: 101%;\r\n  left: 50%;\r\n  transform: translate(-50%, 0);\r\n  border: 1px solid var(--color-hovered);\r\n  padding: 6px;\r\n  border-radius: 9px;\r\n  flex-direction: column;\r\n  z-index: 2;\r\n  background-color: var(--bg-color);\r\n}\r\n\r\n.language-dropdown > button {\r\n  display: flex;\r\n  gap: 7px;\r\n  align-items: center;\r\n}\r\n\r\n.language-component {\r\n  width: fit-content !important;\r\n  border: 1px solid var(--bg-color);\r\n  padding: 7px;\r\n  position: relative;\r\n  border-radius: 10px;\r\n  background-color: transparent;\r\n}\r\n\r\n.language-component > button {\r\n  display: flex;\r\n  gap: 6px;\r\n  align-items: center;\r\n}\r\n\r\n.task-list-item {\r\n  padding: 10px;\r\n  display: flex;\r\n  gap: 10px;\r\n  align-items: center;\r\n  border-radius: 50vh;\r\n  color: var(--read-font-color);\r\n  transition: all 0.3s ease;\r\n}\r\n.task-list-item:hover {\r\n  background-color: var(--color-blue-opaque);\r\n  cursor: pointer;\r\n}\r\n.task-list-item-checkbox {\r\n  width: 20px;\r\n  height: 20px;\r\n  margin-inline: 10px;\r\n  appearance: none;\r\n  background: var(--soft-blue-color) !important;\r\n  border-radius: 50%;\r\n  cursor: pointer;\r\n  border: 1px solid var(--color-active);\r\n}\r\n.task-list-item .task-list-item-checkbox:checked {\r\n  background-color: var(--color-active) !important;\r\n}\r\n.task-list-item.bg-success {\r\n  color: white;\r\n  /* background-color: var(--soft-green) !important; */\r\n}\r\n.task-list-item.bg-fail {\r\n  color: white;\r\n  /* background-color: var(--soft-red) !important; */\r\n  animation: toSelected 0.5s ease forwards;\r\n}\r\n\r\n.task-list-item:has(.task-list-item-checkbox:checked) {\r\n  background-color: var(--color-blue-opaque);\r\n}\r\n\r\n\r\n/* \r\n@keyframes toSelected {\r\n  from {\r\n    scale: 1;\r\n  }\r\n  to {\r\n    background: var(--color-blue-opaque) !important;\r\n    scale: 1.01;\r\n  }\r\n} */\r\n';
  document.head.appendChild(__vite_style__);
  function _mergeNamespaces(n2, m2) {
    for (var i2 = 0; i2 < m2.length; i2++) {
      const e2 = m2[i2];
      if (typeof e2 !== "string" && !Array.isArray(e2)) {
        for (const k2 in e2) {
          if (k2 !== "default" && !(k2 in n2)) {
            const d2 = Object.getOwnPropertyDescriptor(e2, k2);
            if (d2) {
              Object.defineProperty(n2, k2, d2.get ? d2 : {
                enumerable: true,
                get: () => e2[k2]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
  }
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n2) {
    if (n2.__esModule)
      return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a2 = function a3() {
        if (this instanceof a3) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a2.prototype = f2.prototype;
    } else
      a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k2) {
      var d2 = Object.getOwnPropertyDescriptor(n2, k2);
      Object.defineProperty(a2, k2, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n2[k2];
        }
      });
    });
    return a2;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  var react = { exports: {} };
  var react_production_min = {};
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var l$4 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$3 = Symbol.for("react.profiler"), t$3 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
  function A$2(a2) {
    if (null === a2 || "object" !== typeof a2)
      return null;
    a2 = z$1 && a2[z$1] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B$1 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C$1 = Object.assign, D$3 = {};
  function E$1(a2, b2, e2) {
    this.props = a2;
    this.context = b2;
    this.refs = D$3;
    this.updater = e2 || B$1;
  }
  E$1.prototype.isReactComponent = {};
  E$1.prototype.setState = function(a2, b2) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b2, "setState");
  };
  E$1.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F$1() {
  }
  F$1.prototype = E$1.prototype;
  function G$2(a2, b2, e2) {
    this.props = a2;
    this.context = b2;
    this.refs = D$3;
    this.updater = e2 || B$1;
  }
  var H$2 = G$2.prototype = new F$1();
  H$2.constructor = G$2;
  C$1(H$2, E$1.prototype);
  H$2.isPureReactComponent = true;
  var I$2 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
  function M$2(a2, b2, e2) {
    var d2, c2 = {}, k2 = null, h2 = null;
    if (null != b2)
      for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
        J$1.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
    var g2 = arguments.length - 2;
    if (1 === g2)
      c2.children = e2;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
        f2[m2] = arguments[m2 + 2];
      c2.children = f2;
    }
    if (a2 && a2.defaultProps)
      for (d2 in g2 = a2.defaultProps, g2)
        void 0 === c2[d2] && (c2[d2] = g2[d2]);
    return { $$typeof: l$4, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
  }
  function N$1(a2, b2) {
    return { $$typeof: l$4, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O$2(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$4;
  }
  function escape$2(a2) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a3) {
      return b2[a3];
    });
  }
  var P$3 = /\/+/g;
  function Q$2(a2, b2) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$2("" + a2.key) : b2.toString(36);
  }
  function R$1(a2, b2, e2, d2, c2) {
    var k2 = typeof a2;
    if ("undefined" === k2 || "boolean" === k2)
      a2 = null;
    var h2 = false;
    if (null === a2)
      h2 = true;
    else
      switch (k2) {
        case "string":
        case "number":
          h2 = true;
          break;
        case "object":
          switch (a2.$$typeof) {
            case l$4:
            case n$5:
              h2 = true;
          }
      }
    if (h2)
      return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$2(h2, 0) : d2, I$2(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$3, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
        return a3;
      })) : null != c2 && (O$2(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$3, "$&/") + "/") + a2)), b2.push(c2)), 1;
    h2 = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I$2(a2))
      for (var g2 = 0; g2 < a2.length; g2++) {
        k2 = a2[g2];
        var f2 = d2 + Q$2(k2, g2);
        h2 += R$1(k2, b2, e2, f2, c2);
      }
    else if (f2 = A$2(a2), "function" === typeof f2)
      for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
        k2 = k2.value, f2 = d2 + Q$2(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
    else if ("object" === k2)
      throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S$2(a2, b2, e2) {
    if (null == a2)
      return a2;
    var d2 = [], c2 = 0;
    R$1(a2, d2, "", "", function(a3) {
      return b2.call(e2, a3, c2++);
    });
    return d2;
  }
  function T$2(a2) {
    if (-1 === a2._status) {
      var b2 = a2._result;
      b2 = b2();
      b2.then(function(b3) {
        if (0 === a2._status || -1 === a2._status)
          a2._status = 1, a2._result = b3;
      }, function(b3) {
        if (0 === a2._status || -1 === a2._status)
          a2._status = 2, a2._result = b3;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b2);
    }
    if (1 === a2._status)
      return a2._result.default;
    throw a2._result;
  }
  var U$2 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$1 };
  function X$2() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
    S$2(a2, function() {
      b2.apply(this, arguments);
    }, e2);
  }, count: function(a2) {
    var b2 = 0;
    S$2(a2, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a2) {
    return S$2(a2, function(a3) {
      return a3;
    }) || [];
  }, only: function(a2) {
    if (!O$2(a2))
      throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E$1;
  react_production_min.Fragment = p$5;
  react_production_min.Profiler = r$3;
  react_production_min.PureComponent = G$2;
  react_production_min.StrictMode = q$3;
  react_production_min.Suspense = w$2;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
  react_production_min.act = X$2;
  react_production_min.cloneElement = function(a2, b2, e2) {
    if (null === a2 || void 0 === a2)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
      void 0 !== b2.key && (c2 = "" + b2.key);
      if (a2.type && a2.type.defaultProps)
        var g2 = a2.type.defaultProps;
      for (f2 in b2)
        J$1.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2)
      d2.children = e2;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++)
        g2[m2] = arguments[m2 + 2];
      d2.children = g2;
    }
    return { $$typeof: l$4, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u$4, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t$3, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M$2;
  react_production_min.createFactory = function(a2) {
    var b2 = M$2.bind(null, a2);
    b2.type = a2;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v$4, render: a2 };
  };
  react_production_min.isValidElement = O$2;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y, _payload: { _status: -1, _result: a2 }, _init: T$2 };
  };
  react_production_min.memo = function(a2, b2) {
    return { $$typeof: x, type: a2, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.startTransition = function(a2) {
    var b2 = V$2.transition;
    V$2.transition = {};
    try {
      a2();
    } finally {
      V$2.transition = b2;
    }
  };
  react_production_min.unstable_act = X$2;
  react_production_min.useCallback = function(a2, b2) {
    return U$2.current.useCallback(a2, b2);
  };
  react_production_min.useContext = function(a2) {
    return U$2.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U$2.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b2) {
    return U$2.current.useEffect(a2, b2);
  };
  react_production_min.useId = function() {
    return U$2.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b2, e2) {
    return U$2.current.useImperativeHandle(a2, b2, e2);
  };
  react_production_min.useInsertionEffect = function(a2, b2) {
    return U$2.current.useInsertionEffect(a2, b2);
  };
  react_production_min.useLayoutEffect = function(a2, b2) {
    return U$2.current.useLayoutEffect(a2, b2);
  };
  react_production_min.useMemo = function(a2, b2) {
    return U$2.current.useMemo(a2, b2);
  };
  react_production_min.useReducer = function(a2, b2, e2) {
    return U$2.current.useReducer(a2, b2, e2);
  };
  react_production_min.useRef = function(a2) {
    return U$2.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U$2.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b2, e2) {
    return U$2.current.useSyncExternalStore(a2, b2, e2);
  };
  react_production_min.useTransition = function() {
    return U$2.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  {
    react.exports = react_production_min;
  }
  var reactExports = react.exports;
  const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
  const React$2 = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: React$1
  }, [reactExports]);
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f$1 = reactExports, k$2 = Symbol.for("react.element"), l$3 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$4 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: true, ref: true, __self: true, __source: true };
  function q$2(c2, a2, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2)
      m$3.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps)
      for (b2 in a2 = c2.defaultProps, a2)
        void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k$2, type: c2, key: e2, ref: h2, props: d2, _owner: n$4.current };
  }
  reactJsxRuntime_production_min.Fragment = l$3;
  reactJsxRuntime_production_min.jsx = q$2;
  reactJsxRuntime_production_min.jsxs = q$2;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  var client = {};
  var reactDom = { exports: {} };
  var reactDom_production_min = {};
  var scheduler = { exports: {} };
  var scheduler_production_min = {};
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function(exports) {
    function f2(a2, b2) {
      var c2 = a2.length;
      a2.push(b2);
      a:
        for (; 0 < c2; ) {
          var d2 = c2 - 1 >>> 1, e2 = a2[d2];
          if (0 < g2(e2, b2))
            a2[d2] = b2, a2[c2] = e2, c2 = d2;
          else
            break a;
        }
    }
    function h2(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k2(a2) {
      if (0 === a2.length)
        return null;
      var b2 = a2[0], c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a:
          for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
            var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
            if (0 > g2(C2, c2))
              n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
            else if (n2 < e2 && 0 > g2(x2, c2))
              a2[d2] = x2, a2[n2] = c2, d2 = n2;
            else
              break a;
          }
      }
      return b2;
    }
    function g2(a2, b2) {
      var c2 = a2.sortIndex - b2.sortIndex;
      return 0 !== c2 ? c2 : a2.id - b2.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a2) {
      for (var b2 = h2(t2); null !== b2; ) {
        if (null === b2.callback)
          k2(t2);
        else if (b2.startTime <= a2)
          k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
        else
          break;
        b2 = h2(t2);
      }
    }
    function H2(a2) {
      B2 = false;
      G2(a2);
      if (!A2)
        if (null !== h2(r2))
          A2 = true, I2(J2);
        else {
          var b2 = h2(t2);
          null !== b2 && K2(H2, b2.startTime - a2);
        }
    }
    function J2(a2, b2) {
      A2 = false;
      B2 && (B2 = false, E2(L2), L2 = -1);
      z2 = true;
      var c2 = y2;
      try {
        G2(b2);
        for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
          var d2 = v2.callback;
          if ("function" === typeof d2) {
            v2.callback = null;
            y2 = v2.priorityLevel;
            var e2 = d2(v2.expirationTime <= b2);
            b2 = exports.unstable_now();
            "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
            G2(b2);
          } else
            k2(r2);
          v2 = h2(r2);
        }
        if (null !== v2)
          var w2 = true;
        else {
          var m2 = h2(t2);
          null !== m2 && K2(H2, m2.startTime - b2);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y2 = c2, z2 = false;
      }
    }
    var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return exports.unstable_now() - Q2 < P2 ? false : true;
    }
    function R2() {
      if (null !== O2) {
        var a2 = exports.unstable_now();
        Q2 = a2;
        var b2 = true;
        try {
          b2 = O2(true, a2);
        } finally {
          b2 ? S2() : (N2 = false, O2 = null);
        }
      } else
        N2 = false;
    }
    var S2;
    if ("function" === typeof F2)
      S2 = function() {
        F2(R2);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var T2 = new MessageChannel(), U2 = T2.port2;
      T2.port1.onmessage = R2;
      S2 = function() {
        U2.postMessage(null);
      };
    } else
      S2 = function() {
        D2(R2, 0);
      };
    function I2(a2) {
      O2 = a2;
      N2 || (N2 = true, S2());
    }
    function K2(a2, b2) {
      L2 = D2(function() {
        a2(exports.unstable_now());
      }, b2);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A2 || z2 || (A2 = true, I2(J2));
    };
    exports.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports.unstable_next = function(a2) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = y2;
      }
      var c2 = y2;
      y2 = b2;
      try {
        return a2();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a2, b2) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c2 = y2;
      y2 = a2;
      try {
        return b2();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_scheduleCallback = function(a2, b2, c2) {
      var d2 = exports.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
      switch (a2) {
        case 1:
          var e2 = -1;
          break;
        case 2:
          e2 = 250;
          break;
        case 5:
          e2 = 1073741823;
          break;
        case 4:
          e2 = 1e4;
          break;
        default:
          e2 = 5e3;
      }
      e2 = c2 + e2;
      a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
      c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
      return a2;
    };
    exports.unstable_shouldYield = M2;
    exports.unstable_wrapCallback = function(a2) {
      var b2 = y2;
      return function() {
        var c2 = y2;
        y2 = b2;
        try {
          return a2.apply(this, arguments);
        } finally {
          y2 = c2;
        }
      };
    };
  })(scheduler_production_min);
  {
    scheduler.exports = scheduler_production_min;
  }
  var schedulerExports = scheduler.exports;
  /**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var aa = reactExports, ca = schedulerExports;
  function p$3(a2) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
      b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a2, b2) {
    ha(a2, b2);
    ha(a2 + "Capture", b2);
  }
  function ha(a2, b2) {
    ea[a2] = b2;
    for (a2 = 0; a2 < b2.length; a2++)
      da.add(b2[a2]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a2) {
    if (ja.call(ma, a2))
      return true;
    if (ja.call(la, a2))
      return false;
    if (ka.test(a2))
      return ma[a2] = true;
    la[a2] = true;
    return false;
  }
  function pa(a2, b2, c2, d2) {
    if (null !== c2 && 0 === c2.type)
      return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2)
          return false;
        if (null !== c2)
          return !c2.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa(a2, b2, c2, d2) {
    if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
      return true;
    if (d2)
      return false;
    if (null !== c2)
      switch (c2.type) {
        case 3:
          return !b2;
        case 4:
          return false === b2;
        case 5:
          return isNaN(b2);
        case 6:
          return isNaN(b2) || 1 > b2;
      }
    return false;
  }
  function v$3(a2, b2, c2, d2, e2, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = e2;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z[a2] = new v$3(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b2 = a2[0];
    z[b2] = new v$3(b2, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z[a2] = new v$3(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z[a2] = new v$3(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z[a2] = new v$3(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z[a2] = new v$3(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z[a2] = new v$3(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z[a2] = new v$3(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z[a2] = new v$3(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b2 = a2.replace(
      ra,
      sa
    );
    z[b2] = new v$3(b2, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z[b2] = new v$3(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z[b2] = new v$3(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta(a2, b2, c2, d2) {
    var e2 = z.hasOwnProperty(b2) ? z[b2] : null;
    if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
      qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a2) {
    if (null === a2 || "object" !== typeof a2)
      return null;
    a2 = Ja && a2[Ja] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A$1 = Object.assign, La;
  function Ma(a2) {
    if (void 0 === La)
      try {
        throw Error();
      } catch (c2) {
        var b2 = c2.stack.trim().match(/\n( *(at )?)/);
        La = b2 && b2[1] || "";
      }
    return "\n" + La + a2;
  }
  var Na = false;
  function Oa(a2, b2) {
    if (!a2 || Na)
      return "";
    Na = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2)
        if (b2 = function() {
          throw Error();
        }, Object.defineProperty(b2.prototype, "props", { set: function() {
          throw Error();
        } }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b2, []);
          } catch (l2) {
            var d2 = l2;
          }
          Reflect.construct(a2, [], b2);
        } else {
          try {
            b2.call();
          } catch (l2) {
            d2 = l2;
          }
          a2.call(b2.prototype);
        }
      else {
        try {
          throw Error();
        } catch (l2) {
          d2 = l2;
        }
        a2();
      }
    } catch (l2) {
      if (l2 && d2 && "string" === typeof l2.stack) {
        for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
          h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--)
          if (e2[g2] !== f2[h2]) {
            if (1 !== g2 || 1 !== h2) {
              do
                if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                  var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                  a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                  return k2;
                }
              while (1 <= g2 && 0 <= h2);
            }
            break;
          }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c2;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma(a2.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa(a2.type, false), a2;
      case 11:
        return a2 = Oa(a2.type.render, false), a2;
      case 1:
        return a2 = Oa(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa(a2) {
    if (null == a2)
      return null;
    if ("function" === typeof a2)
      return a2.displayName || a2.name || null;
    if ("string" === typeof a2)
      return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a2)
      switch (a2.$$typeof) {
        case Ca:
          return (a2.displayName || "Context") + ".Consumer";
        case Ba:
          return (a2._context.displayName || "Context") + ".Provider";
        case Da:
          var b2 = a2.render;
          a2 = a2.displayName;
          a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
          return a2;
        case Ga:
          return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
        case Ha:
          b2 = a2._payload;
          a2 = a2._init;
          try {
            return Qa(a2(b2));
          } catch (c2) {
          }
      }
    return null;
  }
  function Ra(a2) {
    var b2 = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b2.displayName || "Context") + ".Consumer";
      case 10:
        return (b2._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b2;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b2);
      case 8:
        return b2 === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b2)
          return b2.displayName || b2.name || null;
        if ("string" === typeof b2)
          return b2;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b2 = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua(a2) {
    var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
    if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e2 = c2.get, f2 = c2.set;
      Object.defineProperty(a2, b2, { configurable: true, get: function() {
        return e2.call(this);
      }, set: function(a3) {
        d2 = "" + a3;
        f2.call(this, a3);
      } });
      Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a3) {
        d2 = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b2];
      } };
    }
  }
  function Va(a2) {
    a2._valueTracker || (a2._valueTracker = Ua(a2));
  }
  function Wa(a2) {
    if (!a2)
      return false;
    var b2 = a2._valueTracker;
    if (!b2)
      return true;
    var c2 = b2.getValue();
    var d2 = "";
    a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d2;
    return a2 !== c2 ? (b2.setValue(a2), true) : false;
  }
  function Xa(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2)
      return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b2) {
      return a2.body;
    }
  }
  function Ya(a2, b2) {
    var c2 = b2.checked;
    return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
  }
  function Za(a2, b2) {
    var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c2 = Sa(null != b2.value ? b2.value : c2);
    a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function ab(a2, b2) {
    b2 = b2.checked;
    null != b2 && ta(a2, "checked", b2, false);
  }
  function bb(a2, b2) {
    ab(a2, b2);
    var c2 = Sa(b2.value), d2 = b2.type;
    if (null != c2)
      if ("number" === d2) {
        if (0 === c2 && "" === a2.value || a2.value != c2)
          a2.value = "" + c2;
      } else
        a2.value !== "" + c2 && (a2.value = "" + c2);
    else if ("submit" === d2 || "reset" === d2) {
      a2.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
  }
  function db(a2, b2, c2) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d2 = b2.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
        return;
      b2 = "" + a2._wrapperState.initialValue;
      c2 || b2 === a2.value || (a2.value = b2);
      a2.defaultValue = b2;
    }
    c2 = a2.name;
    "" !== c2 && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c2 && (a2.name = c2);
  }
  function cb(a2, b2, c2) {
    if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
      null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a2, b2, c2, d2) {
    a2 = a2.options;
    if (b2) {
      b2 = {};
      for (var e2 = 0; e2 < c2.length; e2++)
        b2["$" + c2[e2]] = true;
      for (c2 = 0; c2 < a2.length; c2++)
        e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa(c2);
      b2 = null;
      for (e2 = 0; e2 < a2.length; e2++) {
        if (a2[e2].value === c2) {
          a2[e2].selected = true;
          d2 && (a2[e2].defaultSelected = true);
          return;
        }
        null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a2, b2) {
    if (null != b2.dangerouslySetInnerHTML)
      throw Error(p$3(91));
    return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b2) {
    var c2 = b2.value;
    if (null == c2) {
      c2 = b2.children;
      b2 = b2.defaultValue;
      if (null != c2) {
        if (null != b2)
          throw Error(p$3(92));
        if (eb(c2)) {
          if (1 < c2.length)
            throw Error(p$3(93));
          c2 = c2[0];
        }
        b2 = c2;
      }
      null == b2 && (b2 = "");
      c2 = b2;
    }
    a2._wrapperState = { initialValue: Sa(c2) };
  }
  function ib(a2, b2) {
    var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
    null != d2 && (a2.defaultValue = "" + d2);
  }
  function jb(a2) {
    var b2 = a2.textContent;
    b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b2) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b2, c2, d2, e2);
      });
    } : a2;
  }(function(a2, b2) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
      a2.innerHTML = b2;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = mb.firstChild; a2.firstChild; )
        a2.removeChild(a2.firstChild);
      for (; b2.firstChild; )
        a2.appendChild(b2.firstChild);
    }
  });
  function ob(a2, b2) {
    if (b2) {
      var c2 = a2.firstChild;
      if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b2;
        return;
      }
    }
    a2.textContent = b2;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b2) {
      b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b2] = pb[a2];
    });
  });
  function rb(a2, b2, c2) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
  }
  function sb(a2, b2) {
    a2 = a2.style;
    for (var c2 in b2)
      if (b2.hasOwnProperty(c2)) {
        var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
        "float" === c2 && (c2 = "cssFloat");
        d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
      }
  }
  var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b2) {
    if (b2) {
      if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
        throw Error(p$3(137, a2));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children)
          throw Error(p$3(60));
        if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
          throw Error(p$3(61));
      }
      if (null != b2.style && "object" !== typeof b2.style)
        throw Error(p$3(62));
    }
  }
  function vb(a2, b2) {
    if (-1 === a2.indexOf("-"))
      return "string" === typeof b2.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb)
        throw Error(p$3(280));
      var b2 = a2.stateNode;
      b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b2)
        for (a2 = 0; a2 < b2.length; a2++)
          Bb(b2[a2]);
    }
  }
  function Gb(a2, b2) {
    return a2(b2);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b2, c2) {
    if (Ib)
      return a2(b2, c2);
    Ib = true;
    try {
      return Gb(a2, b2, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab)
        Hb(), Fb();
    }
  }
  function Kb(a2, b2) {
    var c2 = a2.stateNode;
    if (null === c2)
      return null;
    var d2 = Db(c2);
    if (null === d2)
      return null;
    c2 = d2[b2];
    a:
      switch (b2) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
          a2 = !d2;
          break a;
        default:
          a2 = false;
      }
    if (a2)
      return null;
    if (c2 && "function" !== typeof c2)
      throw Error(p$3(231, b2, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia)
    try {
      var Mb = {};
      Object.defineProperty(Mb, "passive", { get: function() {
        Lb = true;
      } });
      window.addEventListener("test", Mb, Mb);
      window.removeEventListener("test", Mb, Mb);
    } catch (a2) {
      Lb = false;
    }
  function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c2, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else
        throw Error(p$3(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a2) {
    var b2 = a2, c2 = a2;
    if (a2.alternate)
      for (; b2.return; )
        b2 = b2.return;
    else {
      a2 = b2;
      do
        b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
      while (a2);
    }
    return 3 === b2.tag ? c2 : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b2 = a2.memoizedState;
      null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
      if (null !== b2)
        return b2.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2)
      throw Error(p$3(188));
  }
  function Yb(a2) {
    var b2 = a2.alternate;
    if (!b2) {
      b2 = Vb(a2);
      if (null === b2)
        throw Error(p$3(188));
      return b2 !== a2 ? null : a2;
    }
    for (var c2 = a2, d2 = b2; ; ) {
      var e2 = c2.return;
      if (null === e2)
        break;
      var f2 = e2.alternate;
      if (null === f2) {
        d2 = e2.return;
        if (null !== d2) {
          c2 = d2;
          continue;
        }
        break;
      }
      if (e2.child === f2.child) {
        for (f2 = e2.child; f2; ) {
          if (f2 === c2)
            return Xb(e2), a2;
          if (f2 === d2)
            return Xb(e2), b2;
          f2 = f2.sibling;
        }
        throw Error(p$3(188));
      }
      if (c2.return !== d2.return)
        c2 = e2, d2 = f2;
      else {
        for (var g2 = false, h2 = e2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = e2;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e2;
            c2 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = f2;
              d2 = e2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c2 = e2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2)
            throw Error(p$3(189));
        }
      }
      if (c2.alternate !== d2)
        throw Error(p$3(190));
    }
    if (3 !== c2.tag)
      throw Error(p$3(188));
    return c2.stateNode.current === c2 ? a2 : b2;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag)
      return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b2 = $b(a2);
      if (null !== b2)
        return b2;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a2) {
    if (lc && "function" === typeof lc.onCommitFiberRoot)
      try {
        lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
      } catch (b2) {
      }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b2) {
    var c2 = a2.pendingLanes;
    if (0 === c2)
      return 0;
    var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e2;
      0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
    } else
      g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
    if (0 === d2)
      return 0;
    if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
      return b2;
    0 !== (d2 & 4) && (d2 |= c2 & 16);
    b2 = a2.entangledLanes;
    if (0 !== b2)
      for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
        c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
    return d2;
  }
  function vc(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b2 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b2 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a2, b2) {
    for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
      if (-1 === k2) {
        if (0 === (h2 & c2) || 0 !== (h2 & d2))
          e2[g2] = vc(h2, b2);
      } else
        k2 <= b2 && (a2.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a2;
  }
  function zc(a2) {
    for (var b2 = [], c2 = 0; 31 > c2; c2++)
      b2.push(a2);
    return b2;
  }
  function Ac(a2, b2, c2) {
    a2.pendingLanes |= b2;
    536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b2 = 31 - oc(b2);
    a2[b2] = c2;
  }
  function Bc(a2, b2) {
    var c2 = a2.pendingLanes & ~b2;
    a2.pendingLanes = b2;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b2;
    a2.mutableReadLanes &= b2;
    a2.entangledLanes &= b2;
    b2 = a2.entanglements;
    var d2 = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c2; ) {
      var e2 = 31 - oc(c2), f2 = 1 << e2;
      b2[e2] = 0;
      d2[e2] = -1;
      a2[e2] = -1;
      c2 &= ~f2;
    }
  }
  function Cc$1(a2, b2) {
    var c2 = a2.entangledLanes |= b2;
    for (a2 = a2.entanglements; c2; ) {
      var d2 = 31 - oc(c2), e2 = 1 << d2;
      e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
      c2 &= ~e2;
    }
  }
  var C = 0;
  function Dc(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b2) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b2.pointerId);
    }
  }
  function Tc(a2, b2, c2, d2, e2, f2) {
    if (null === a2 || a2.nativeEvent !== f2)
      return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
    a2.eventSystemFlags |= d2;
    b2 = a2.targetContainers;
    null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
    return a2;
  }
  function Uc(a2, b2, c2, d2, e2) {
    switch (b2) {
      case "focusin":
        return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
      case "dragenter":
        return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
      case "mouseover":
        return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
      case "pointerover":
        var f2 = e2.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
        return true;
      case "gotpointercapture":
        return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
    }
    return false;
  }
  function Vc(a2) {
    var b2 = Wc(a2.target);
    if (null !== b2) {
      var c2 = Vb(b2);
      if (null !== c2) {
        if (b2 = c2.tag, 13 === b2) {
          if (b2 = Wb(c2), null !== b2) {
            a2.blockedOn = b2;
            Ic(a2.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn)
      return false;
    for (var b2 = a2.targetContainers; 0 < b2.length; ) {
      var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
      if (null === c2) {
        c2 = a2.nativeEvent;
        var d2 = new c2.constructor(c2.type, c2);
        wb = d2;
        c2.target.dispatchEvent(d2);
        wb = null;
      } else
        return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
      b2.shift();
    }
    return true;
  }
  function Zc(a2, b2, c2) {
    Xc(a2) && c2.delete(b2);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a2, b2) {
    a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b2(b3) {
      return ad(b3, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d2 = Kc[c2];
        d2.blockedOn === a2 && (d2.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a2);
    null !== Mc && ad(Mc, a2);
    null !== Nc && ad(Nc, a2);
    Oc.forEach(b2);
    Pc.forEach(b2);
    for (c2 = 0; c2 < Qc.length; c2++)
      d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
      Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b2, c2, d2) {
    var e2 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a2, b2, c2, d2);
    } finally {
      C = e2, cd.transition = f2;
    }
  }
  function gd(a2, b2, c2, d2) {
    var e2 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a2, b2, c2, d2);
    } finally {
      C = e2, cd.transition = f2;
    }
  }
  function fd(a2, b2, c2, d2) {
    if (dd) {
      var e2 = Yc(a2, b2, c2, d2);
      if (null === e2)
        hd(a2, b2, d2, id, c2), Sc(a2, d2);
      else if (Uc(e2, a2, b2, c2, d2))
        d2.stopPropagation();
      else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
        for (; null !== e2; ) {
          var f2 = Cb(e2);
          null !== f2 && Ec(f2);
          f2 = Yc(a2, b2, c2, d2);
          null === f2 && hd(a2, b2, d2, id, c2);
          if (f2 === e2)
            break;
          e2 = f2;
        }
        null !== e2 && d2.stopPropagation();
      } else
        hd(a2, b2, d2, null, c2);
    }
  }
  var id = null;
  function Yc(a2, b2, c2, d2) {
    id = null;
    a2 = xb(d2);
    a2 = Wc(a2);
    if (null !== a2)
      if (b2 = Vb(a2), null === b2)
        a2 = null;
      else if (c2 = b2.tag, 13 === c2) {
        a2 = Wb(b2);
        if (null !== a2)
          return a2;
        a2 = null;
      } else if (3 === c2) {
        if (b2.stateNode.current.memoizedState.isDehydrated)
          return 3 === b2.tag ? b2.stateNode.containerInfo : null;
        a2 = null;
      } else
        b2 !== a2 && (a2 = null);
    id = a2;
    return null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md)
      return md;
    var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
    for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
      ;
    var g2 = c2 - a2;
    for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
      ;
    return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a2) {
    var b2 = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b2(b3, d2, e2, f2, g2) {
      this._reactName = b3;
      this._targetInst = e2;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c2 in a2)
        a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A$1(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2)
      return a2.movementX;
    a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
    return wd;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A$1({}, ud, { key: function(a2) {
    if (a2.key) {
      var b2 = Md[a2.key] || a2.key;
      if ("Unidentified" !== b2)
        return b2;
    }
    return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$2 = null;
  ia && "documentMode" in document && (be$2 = document.documentMode);
  var ce = ia && "TextEvent" in window && !be$2, de$2 = ia && (!ae$1 || be$2 && 8 < be$2 && 11 >= be$2), ee$2 = String.fromCharCode(32), fe$2 = false;
  function ge$1(a2, b2) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he$2(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie$1 = false;
  function je(a2, b2) {
    switch (a2) {
      case "compositionend":
        return he$2(b2);
      case "keypress":
        if (32 !== b2.which)
          return null;
        fe$2 = true;
        return ee$2;
      case "textInput":
        return a2 = b2.data, a2 === ee$2 && fe$2 ? null : a2;
      default:
        return null;
    }
  }
  function ke(a2, b2) {
    if (ie$1)
      return "compositionend" === a2 || !ae$1 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length)
            return b2.char;
          if (b2.which)
            return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de$2 && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le$2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b2 ? !!le$2[a2.type] : "textarea" === b2 ? true : false;
  }
  function ne$1(a2, b2, c2, d2) {
    Eb(d2);
    b2 = oe$1(b2, "onChange");
    0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
  }
  var pe$1 = null, qe = null;
  function re$2(a2) {
    se$2(a2, 0);
  }
  function te$1(a2) {
    var b2 = ue$1(a2);
    if (Wa(b2))
      return a2;
  }
  function ve$1(a2, b2) {
    if ("change" === a2)
      return b2;
  }
  var we = false;
  if (ia) {
    var xe$1;
    if (ia) {
      var ye$1 = "oninput" in document;
      if (!ye$1) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye$1 = "function" === typeof ze.oninput;
      }
      xe$1 = ye$1;
    } else
      xe$1 = false;
    we = xe$1 && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae$1() {
    pe$1 && (pe$1.detachEvent("onpropertychange", Be), qe = pe$1 = null);
  }
  function Be(a2) {
    if ("value" === a2.propertyName && te$1(qe)) {
      var b2 = [];
      ne$1(b2, qe, a2, xb(a2));
      Jb(re$2, b2);
    }
  }
  function Ce$1(a2, b2, c2) {
    "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe = c2, pe$1.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae$1();
  }
  function De$1(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
      return te$1(qe);
  }
  function Ee$2(a2, b2) {
    if ("click" === a2)
      return te$1(b2);
  }
  function Fe(a2, b2) {
    if ("input" === a2 || "change" === a2)
      return te$1(b2);
  }
  function Ge(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var He$1 = "function" === typeof Object.is ? Object.is : Ge;
  function Ie$1(a2, b2) {
    if (He$1(a2, b2))
      return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
      return false;
    var c2 = Object.keys(a2), d2 = Object.keys(b2);
    if (c2.length !== d2.length)
      return false;
    for (d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      if (!ja.call(b2, e2) || !He$1(a2[e2], b2[e2]))
        return false;
    }
    return true;
  }
  function Je(a2) {
    for (; a2 && a2.firstChild; )
      a2 = a2.firstChild;
    return a2;
  }
  function Ke(a2, b2) {
    var c2 = Je(a2);
    a2 = 0;
    for (var d2; c2; ) {
      if (3 === c2.nodeType) {
        d2 = a2 + c2.textContent.length;
        if (a2 <= b2 && d2 >= b2)
          return { node: c2, offset: b2 - a2 };
        a2 = d2;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je(c2);
    }
  }
  function Le(a2, b2) {
    return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Me$1() {
    for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b2.contentWindow.location.href;
      } catch (d2) {
        c2 = false;
      }
      if (c2)
        a2 = b2.contentWindow;
      else
        break;
      b2 = Xa(a2.document);
    }
    return b2;
  }
  function Ne(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
  }
  function Oe$1(a2) {
    var b2 = Me$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
    if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
      if (null !== d2 && Ne(c2)) {
        if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
          c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
        else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
          d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
          !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
          e2 = Ke(c2, f2);
          var g2 = Ke(
            c2,
            d2
          );
          e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
        }
      }
      b2 = [];
      for (a2 = c2; a2 = a2.parentNode; )
        1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b2.length; c2++)
        a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re$1 = null, Se$1 = null, Te$1 = false;
  function Ue(a2, b2, c2) {
    var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te$1 || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
  }
  function Ve$1(a2, b2) {
    var c2 = {};
    c2[a2.toLowerCase()] = b2.toLowerCase();
    c2["Webkit" + a2] = "webkit" + b2;
    c2["Moz" + a2] = "moz" + b2;
    return c2;
  }
  var We = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a2) {
    if (Xe[a2])
      return Xe[a2];
    if (!We[a2])
      return a2;
    var b2 = We[a2], c2;
    for (c2 in b2)
      if (b2.hasOwnProperty(c2) && c2 in Ye)
        return Xe[a2] = b2[c2];
    return a2;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b2) {
    df.set(a2, b2);
    fa(b2, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b2, c2) {
    var d2 = a2.type || "unknown-event";
    a2.currentTarget = c2;
    Ub(d2, b2, void 0, a2);
    a2.currentTarget = null;
  }
  function se$2(a2, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d2 = a2[c2], e2 = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b2)
          for (var g2 = d2.length - 1; 0 <= g2; g2--) {
            var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
            h2 = h2.listener;
            if (k2 !== f2 && e2.isPropagationStopped())
              break a;
            nf(e2, h2, l2);
            f2 = k2;
          }
        else
          for (g2 = 0; g2 < d2.length; g2++) {
            h2 = d2[g2];
            k2 = h2.instance;
            l2 = h2.currentTarget;
            h2 = h2.listener;
            if (k2 !== f2 && e2.isPropagationStopped())
              break a;
            nf(e2, h2, l2);
            f2 = k2;
          }
      }
    }
    if (Qb)
      throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D$2(a2, b2) {
    var c2 = b2[of];
    void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
    var d2 = a2 + "__bubble";
    c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
  }
  function qf(a2, b2, c2) {
    var d2 = 0;
    b2 && (d2 |= 4);
    pf(c2, a2, d2, b2);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da.forEach(function(b3) {
        "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
      });
      var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
    }
  }
  function pf(a2, b2, c2, d2) {
    switch (jd(b2)) {
      case 1:
        var e2 = ed;
        break;
      case 4:
        e2 = gd;
        break;
      default:
        e2 = fd;
    }
    c2 = e2.bind(null, b2, c2, a2);
    e2 = void 0;
    !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
    d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
  }
  function hd(a2, b2, c2, d2, e2) {
    var f2 = d2;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
      a:
        for (; ; ) {
          if (null === d2)
            return;
          var g2 = d2.tag;
          if (3 === g2 || 4 === g2) {
            var h2 = d2.stateNode.containerInfo;
            if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
              break;
            if (4 === g2)
              for (g2 = d2.return; null !== g2; ) {
                var k2 = g2.tag;
                if (3 === k2 || 4 === k2) {
                  if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                    return;
                }
                g2 = g2.return;
              }
            for (; null !== h2; ) {
              g2 = Wc(h2);
              if (null === g2)
                return;
              k2 = g2.tag;
              if (5 === k2 || 6 === k2) {
                d2 = f2 = g2;
                continue a;
              }
              h2 = h2.parentNode;
            }
          }
          d2 = d2.return;
        }
    Jb(function() {
      var d3 = f2, e3 = xb(c2), g3 = [];
      a: {
        var h3 = df.get(a2);
        if (void 0 !== h3) {
          var k3 = td, n2 = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c2))
                break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c2.button)
                break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w2 = d3, u2; null !== w2; ) {
            u2 = w2;
            var F2 = u2.stateNode;
            5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
            if (J2)
              break;
            w2 = w2.return;
          }
          0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a2 || "pointerover" === a2;
          k3 = "mouseout" === a2 || "pointerout" === a2;
          if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
            break a;
          if (k3 || h3) {
            h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                n2 = null;
            } else
              k3 = null, n2 = d3;
            if (k3 !== n2) {
              t2 = Bd;
              F2 = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2)
                t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J2 = null == k3 ? h3 : ue$1(k3);
              u2 = null == n2 ? h3 : ue$1(n2);
              h3 = new t2(F2, w2 + "leave", k3, c2, e3);
              h3.target = J2;
              h3.relatedTarget = u2;
              F2 = null;
              Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
              J2 = F2;
              if (k3 && n2)
                b: {
                  t2 = k3;
                  x2 = n2;
                  w2 = 0;
                  for (u2 = t2; u2; u2 = vf(u2))
                    w2++;
                  u2 = 0;
                  for (F2 = x2; F2; F2 = vf(F2))
                    u2++;
                  for (; 0 < w2 - u2; )
                    t2 = vf(t2), w2--;
                  for (; 0 < u2 - w2; )
                    x2 = vf(x2), u2--;
                  for (; w2--; ) {
                    if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                      break b;
                    t2 = vf(t2);
                    x2 = vf(x2);
                  }
                  t2 = null;
                }
              else
                t2 = null;
              null !== k3 && wf(g3, h3, k3, t2, false);
              null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue$1(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type)
            var na = ve$1;
          else if (me(h3))
            if (we)
              na = Fe;
            else {
              na = De$1;
              var xa = Ce$1;
            }
          else
            (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$2);
          if (na && (na = na(a2, d3))) {
            ne$1(g3, na, c2, e3);
            break a;
          }
          xa && xa(a2, h3, d3);
          "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d3 ? ue$1(d3) : window;
        switch (a2) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable)
              Qe = xa, Re$1 = d3, Se$1 = null;
            break;
          case "focusout":
            Se$1 = Re$1 = Qe = null;
            break;
          case "mousedown":
            Te$1 = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te$1 = false;
            Ue(g3, c2, e3);
            break;
          case "selectionchange":
            if (Pe)
              break;
          case "keydown":
          case "keyup":
            Ue(g3, c2, e3);
        }
        var $a;
        if (ae$1)
          b: {
            switch (a2) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
        else
          ie$1 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
        ba && (de$2 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$1(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$2(c2), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a2, c2) : ke(a2, c2))
          d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
      }
      se$2(g3, b2);
    });
  }
  function tf(a2, b2, c2) {
    return { instance: a2, listener: b2, currentTarget: c2 };
  }
  function oe$1(a2, b2) {
    for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
      var e2 = a2, f2 = e2.stateNode;
      5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
      a2 = a2.return;
    }
    return d2;
  }
  function vf(a2) {
    if (null === a2)
      return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf(a2, b2, c2, d2, e2) {
    for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
      var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d2)
        break;
      5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
      c2 = c2.return;
    }
    0 !== g2.length && a2.push({ event: b2, listeners: g2 });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
  }
  function Af(a2, b2, c2) {
    b2 = zf(b2);
    if (zf(a2) !== b2 && c2)
      throw Error(p$3(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a2, b2) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If);
  } : Ff;
  function If(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b2) {
    var c2 = b2, d2 = 0;
    do {
      var e2 = c2.nextSibling;
      a2.removeChild(c2);
      if (e2 && 8 === e2.nodeType)
        if (c2 = e2.data, "/$" === c2) {
          if (0 === d2) {
            a2.removeChild(e2);
            bd(b2);
            return;
          }
          d2--;
        } else
          "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
      c2 = e2;
    } while (c2);
    bd(b2);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b2 = a2.nodeType;
      if (1 === b2 || 3 === b2)
        break;
      if (8 === b2) {
        b2 = a2.data;
        if ("$" === b2 || "$!" === b2 || "$?" === b2)
          break;
        if ("/$" === b2)
          return null;
      }
    }
    return a2;
  }
  function Mf(a2) {
    a2 = a2.previousSibling;
    for (var b2 = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c2 = a2.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b2)
            return a2;
          b2--;
        } else
          "/$" === c2 && b2++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a2) {
    var b2 = a2[Of];
    if (b2)
      return b2;
    for (var c2 = a2.parentNode; c2; ) {
      if (b2 = c2[uf] || c2[Of]) {
        c2 = b2.alternate;
        if (null !== b2.child || null !== c2 && null !== c2.child)
          for (a2 = Mf(a2); null !== a2; ) {
            if (c2 = a2[Of])
              return c2;
            a2 = Mf(a2);
          }
        return b2;
      }
      a2 = c2;
      c2 = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue$1(a2) {
    if (5 === a2.tag || 6 === a2.tag)
      return a2.stateNode;
    throw Error(p$3(33));
  }
  function Db(a2) {
    return a2[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a2) {
    return { current: a2 };
  }
  function E(a2) {
    0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G$1(a2, b2) {
    Tf++;
    Sf[Tf] = a2.current;
    a2.current = b2;
  }
  var Vf = {}, H$1 = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a2, b2) {
    var c2 = a2.type.contextTypes;
    if (!c2)
      return Vf;
    var d2 = a2.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
      return d2.__reactInternalMemoizedMaskedChildContext;
    var e2 = {}, f2;
    for (f2 in c2)
      e2[f2] = b2[f2];
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
    return e2;
  }
  function Zf(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E(Wf);
    E(H$1);
  }
  function ag(a2, b2, c2) {
    if (H$1.current !== Vf)
      throw Error(p$3(168));
    G$1(H$1, b2);
    G$1(Wf, c2);
  }
  function bg(a2, b2, c2) {
    var d2 = a2.stateNode;
    b2 = b2.childContextTypes;
    if ("function" !== typeof d2.getChildContext)
      return c2;
    d2 = d2.getChildContext();
    for (var e2 in d2)
      if (!(e2 in b2))
        throw Error(p$3(108, Ra(a2) || "Unknown", e2));
    return A$1({}, c2, d2);
  }
  function cg(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H$1.current;
    G$1(H$1, a2);
    G$1(Wf, Wf.current);
    return true;
  }
  function dg(a2, b2, c2) {
    var d2 = a2.stateNode;
    if (!d2)
      throw Error(p$3(169));
    c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H$1), G$1(H$1, a2)) : E(Wf);
    G$1(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function ig(a2) {
    fg = true;
    hg(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b2 = C;
      try {
        var c2 = eg;
        for (C = 1; a2 < c2.length; a2++) {
          var d2 = c2[a2];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg = null;
        fg = false;
      } catch (e2) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
      } finally {
        C = b2, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b2) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a2;
    ng = b2;
  }
  function ug(a2, b2, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a2;
    var d2 = rg;
    a2 = sg;
    var e2 = 32 - oc(d2) - 1;
    d2 &= ~(1 << e2);
    c2 += 1;
    var f2 = 32 - oc(b2) + e2;
    if (30 < f2) {
      var g2 = e2 - e2 % 5;
      f2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      e2 -= g2;
      rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
      sg = f2 + a2;
    } else
      rg = 1 << f2 | c2 << e2 | d2, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; )
      mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; )
      qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I$1 = false, zg = null;
  function Ag(a2, b2) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b2;
    c2.return = a2;
    b2 = a2.deletions;
    null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
  }
  function Cg(a2, b2) {
    switch (a2.tag) {
      case 5:
        var c2 = a2.type;
        b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
      case 6:
        return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
      case 13:
        return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg(a2) {
    if (I$1) {
      var b2 = yg;
      if (b2) {
        var c2 = b2;
        if (!Cg(a2, b2)) {
          if (Dg(a2))
            throw Error(p$3(418));
          b2 = Lf(c2.nextSibling);
          var d2 = xg;
          b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = false, xg = a2);
        }
      } else {
        if (Dg(a2))
          throw Error(p$3(418));
        a2.flags = a2.flags & -4097 | 2;
        I$1 = false;
        xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
      a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg)
      return false;
    if (!I$1)
      return Fg(a2), I$1 = true, false;
    var b2;
    (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
    if (b2 && (b2 = yg)) {
      if (Dg(a2))
        throw Hg(), Error(p$3(418));
      for (; b2; )
        Ag(a2, b2), b2 = Lf(b2.nextSibling);
    }
    Fg(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2)
        throw Error(p$3(317));
      a: {
        a2 = a2.nextSibling;
        for (b2 = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("/$" === c2) {
              if (0 === b2) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b2--;
            } else
              "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else
      yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; )
      a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I$1 = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a2, b2, c2) {
    a2 = c2.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag)
            throw Error(p$3(309));
          var d2 = c2.stateNode;
        }
        if (!d2)
          throw Error(p$3(147, a2));
        var e2 = d2, f2 = "" + a2;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
          return b2.ref;
        b2 = function(a3) {
          var b3 = e2.refs;
          null === a3 ? delete b3[f2] : b3[f2] = a3;
        };
        b2._stringRef = f2;
        return b2;
      }
      if ("string" !== typeof a2)
        throw Error(p$3(284));
      if (!c2._owner)
        throw Error(p$3(290, a2));
    }
    return a2;
  }
  function Mg(a2, b2) {
    a2 = Object.prototype.toString.call(b2);
    throw Error(p$3(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
  }
  function Ng(a2) {
    var b2 = a2._init;
    return b2(a2._payload);
  }
  function Og(a2) {
    function b2(b3, c3) {
      if (a2) {
        var d3 = b3.deletions;
        null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
      }
    }
    function c2(c3, d3) {
      if (!a2)
        return null;
      for (; null !== d3; )
        b2(c3, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a3, b3) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
        null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
      return a3;
    }
    function e2(a3, b3) {
      a3 = Pg(a3, b3);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f2(b3, c3, d3) {
      b3.index = d3;
      if (!a2)
        return b3.flags |= 1048576, c3;
      d3 = b3.alternate;
      if (null !== d3)
        return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
      b3.flags |= 2;
      return c3;
    }
    function g2(b3) {
      a2 && null === b3.alternate && (b3.flags |= 2);
      return b3;
    }
    function h2(a3, b3, c3, d3) {
      if (null === b3 || 6 !== b3.tag)
        return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e2(b3, c3);
      b3.return = a3;
      return b3;
    }
    function k2(a3, b3, c3, d3) {
      var f3 = c3.type;
      if (f3 === ya)
        return m2(a3, b3, c3.props.children, d3, c3.key);
      if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type))
        return d3 = e2(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
      d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
      d3.ref = Lg(a3, b3, c3);
      d3.return = a3;
      return d3;
    }
    function l2(a3, b3, c3, d3) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
        return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e2(b3, c3.children || []);
      b3.return = a3;
      return b3;
    }
    function m2(a3, b3, c3, d3, f3) {
      if (null === b3 || 7 !== b3.tag)
        return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
      b3 = e2(b3, c3);
      b3.return = a3;
      return b3;
    }
    function q2(a3, b3, c3) {
      if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
        return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case va:
            return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
          case wa:
            return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
          case Ha:
            var d3 = b3._init;
            return q2(a3, d3(b3._payload), c3);
        }
        if (eb(b3) || Ka(b3))
          return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
        Mg(a3, b3);
      }
      return null;
    }
    function r2(a3, b3, c3, d3) {
      var e3 = null !== b3 ? b3.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
        return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va:
            return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
          case wa:
            return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
          case Ha:
            return e3 = c3._init, r2(
              a3,
              b3,
              e3(c3._payload),
              d3
            );
        }
        if (eb(c3) || Ka(c3))
          return null !== e3 ? null : m2(a3, b3, c3, d3, null);
        Mg(a3, c3);
      }
      return null;
    }
    function y2(a3, b3, c3, d3, e3) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
        return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
          case wa:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
          case Ha:
            var f3 = d3._init;
            return y2(a3, b3, c3, f3(d3._payload), e3);
        }
        if (eb(d3) || Ka(d3))
          return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
        Mg(b3, d3);
      }
      return null;
    }
    function n2(e3, g3, h3, k3) {
      for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n3 = r2(e3, u2, h3[w2], k3);
        if (null === n3) {
          null === u2 && (u2 = x2);
          break;
        }
        a2 && u2 && null === n3.alternate && b2(e3, u2);
        g3 = f2(n3, g3, w2);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x2;
      }
      if (w2 === h3.length)
        return c2(e3, u2), I$1 && tg(e3, w2), l3;
      if (null === u2) {
        for (; w2 < h3.length; w2++)
          u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I$1 && tg(e3, w2);
        return l3;
      }
      for (u2 = d2(e3, u2); w2 < h3.length; w2++)
        x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
      a2 && u2.forEach(function(a3) {
        return b2(e3, a3);
      });
      I$1 && tg(e3, w2);
      return l3;
    }
    function t2(e3, g3, h3, k3) {
      var l3 = Ka(h3);
      if ("function" !== typeof l3)
        throw Error(p$3(150));
      h3 = l3.call(h3);
      if (null == h3)
        throw Error(p$3(151));
      for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t3 = r2(e3, m3, n3.value, k3);
        if (null === t3) {
          null === m3 && (m3 = x2);
          break;
        }
        a2 && m3 && null === t3.alternate && b2(e3, m3);
        g3 = f2(t3, g3, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x2;
      }
      if (n3.done)
        return c2(
          e3,
          m3
        ), I$1 && tg(e3, w2), l3;
      if (null === m3) {
        for (; !n3.done; w2++, n3 = h3.next())
          n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I$1 && tg(e3, w2);
        return l3;
      }
      for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
        n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a2 && m3.forEach(function(a3) {
        return b2(e3, a3);
      });
      I$1 && tg(e3, w2);
      return l3;
    }
    function J2(a3, d3, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l3.tag) {
                      c2(a3, l3.sibling);
                      d3 = e2(l3, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props);
                    d3.ref = Lg(a3, l3, f3);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                  c2(a3, l3);
                  break;
                } else
                  b2(a3, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
            }
            return g2(a3);
          case wa:
            a: {
              for (l3 = f3.key; null !== d3; ) {
                if (d3.key === l3)
                  if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                    c2(a3, d3.sibling);
                    d3 = e2(d3, f3.children || []);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  } else {
                    c2(a3, d3);
                    break;
                  }
                else
                  b2(a3, d3);
                d3 = d3.sibling;
              }
              d3 = Sg(f3, a3.mode, h3);
              d3.return = a3;
              a3 = d3;
            }
            return g2(a3);
          case Ha:
            return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
        }
        if (eb(f3))
          return n2(a3, d3, f3, h3);
        if (Ka(f3))
          return t2(a3, d3, f3, h3);
        Mg(a3, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
    }
    return J2;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a2) {
    var b2 = Wg.current;
    E(Wg);
    a2._currentValue = b2;
  }
  function bh(a2, b2, c2) {
    for (; null !== a2; ) {
      var d2 = a2.alternate;
      (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
      if (a2 === c2)
        break;
      a2 = a2.return;
    }
  }
  function ch(a2, b2) {
    Xg = a2;
    Zg = Yg = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
  }
  function eh(a2) {
    var b2 = a2._currentValue;
    if (Zg !== a2)
      if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
        if (null === Xg)
          throw Error(p$3(308));
        Yg = a2;
        Xg.dependencies = { lanes: 0, firstContext: a2 };
      } else
        Yg = Yg.next = a2;
    return b2;
  }
  var fh = null;
  function gh(a2) {
    null === fh ? fh = [a2] : fh.push(a2);
  }
  function hh(a2, b2, c2, d2) {
    var e2 = b2.interleaved;
    null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
    b2.interleaved = c2;
    return ih(a2, d2);
  }
  function ih(a2, b2) {
    a2.lanes |= b2;
    var c2 = a2.alternate;
    null !== c2 && (c2.lanes |= b2);
    c2 = a2;
    for (a2 = a2.return; null !== a2; )
      a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var jh = false;
  function kh(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a2, b2) {
    a2 = a2.updateQueue;
    b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function mh(a2, b2) {
    return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a2, b2, c2) {
    var d2 = a2.updateQueue;
    if (null === d2)
      return null;
    d2 = d2.shared;
    if (0 !== (K & 2)) {
      var e2 = d2.pending;
      null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
      d2.pending = b2;
      return ih(a2, c2);
    }
    e2 = d2.interleaved;
    null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
    d2.interleaved = b2;
    return ih(a2, c2);
  }
  function oh(a2, b2, c2) {
    b2 = b2.updateQueue;
    if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc$1(a2, c2);
    }
  }
  function ph(a2, b2) {
    var c2 = a2.updateQueue, d2 = a2.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
      var e2 = null, f2 = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
          c2 = c2.next;
        } while (null !== c2);
        null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
      } else
        e2 = f2 = b2;
      c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a2.updateQueue = c2;
      return;
    }
    a2 = c2.lastBaseUpdate;
    null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
    c2.lastBaseUpdate = b2;
  }
  function qh(a2, b2, c2, d2) {
    var e2 = a2.updateQueue;
    jh = false;
    var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
    if (null !== h2) {
      e2.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var m2 = a2.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q2 = e2.baseState;
      g2 = 0;
      m2 = l2 = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y2 = h2.eventTime;
        if ((d2 & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n2 = a2, t2 = h2;
            r2 = b2;
            y2 = c2;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q2 = n2.call(y2, q2, r2);
                  break a;
                }
                q2 = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                if (null === r2 || void 0 === r2)
                  break a;
                q2 = A$1({}, q2, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
        } else
          y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
        h2 = h2.next;
        if (null === h2)
          if (h2 = e2.shared.pending, null === h2)
            break;
          else
            r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q2);
      e2.baseState = k2;
      e2.firstBaseUpdate = l2;
      e2.lastBaseUpdate = m2;
      b2 = e2.shared.interleaved;
      if (null !== b2) {
        e2 = b2;
        do
          g2 |= e2.lane, e2 = e2.next;
        while (e2 !== b2);
      } else
        null === f2 && (e2.shared.lanes = 0);
      rh |= g2;
      a2.lanes = g2;
      a2.memoizedState = q2;
    }
  }
  function sh(a2, b2, c2) {
    a2 = b2.effects;
    b2.effects = null;
    if (null !== a2)
      for (b2 = 0; b2 < a2.length; b2++) {
        var d2 = a2[b2], e2 = d2.callback;
        if (null !== e2) {
          d2.callback = null;
          d2 = c2;
          if ("function" !== typeof e2)
            throw Error(p$3(191, e2));
          e2.call(d2);
        }
      }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a2) {
    if (a2 === th)
      throw Error(p$3(174));
    return a2;
  }
  function yh(a2, b2) {
    G$1(wh, b2);
    G$1(vh, a2);
    G$1(uh, th);
    a2 = b2.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
    }
    E(uh);
    G$1(uh, b2);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a2) {
    xh(wh.current);
    var b2 = xh(uh.current);
    var c2 = lb(b2, a2.type);
    b2 !== c2 && (G$1(vh, a2), G$1(uh, c2));
  }
  function Bh(a2) {
    vh.current === a2 && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a2) {
    for (var b2 = a2; null !== b2; ) {
      if (13 === b2.tag) {
        var c2 = b2.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
          return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 128))
          return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a2 = 0; a2 < Dh.length; a2++)
      Dh[a2]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M$1 = null, N = null, O$1 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P$2() {
    throw Error(p$3(321));
  }
  function Mh(a2, b2) {
    if (null === b2)
      return false;
    for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
      if (!He$1(a2[c2], b2[c2]))
        return false;
    return true;
  }
  function Nh(a2, b2, c2, d2, e2, f2) {
    Hh = f2;
    M$1 = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
    a2 = c2(d2, e2);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2)
          throw Error(p$3(301));
        f2 += 1;
        O$1 = N = null;
        b2.updateQueue = null;
        Fh.current = Qh;
        a2 = c2(d2, e2);
      } while (Jh);
    }
    Fh.current = Rh;
    b2 = null !== N && null !== N.next;
    Hh = 0;
    O$1 = N = M$1 = null;
    Ih = false;
    if (b2)
      throw Error(p$3(300));
    return a2;
  }
  function Sh() {
    var a2 = 0 !== Kh;
    Kh = 0;
    return a2;
  }
  function Th() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O$1 ? M$1.memoizedState = O$1 = a2 : O$1 = O$1.next = a2;
    return O$1;
  }
  function Uh() {
    if (null === N) {
      var a2 = M$1.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else
      a2 = N.next;
    var b2 = null === O$1 ? M$1.memoizedState : O$1.next;
    if (null !== b2)
      O$1 = b2, N = a2;
    else {
      if (null === a2)
        throw Error(p$3(310));
      N = a2;
      a2 = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O$1 ? M$1.memoizedState = O$1 = a2 : O$1 = O$1.next = a2;
    }
    return O$1;
  }
  function Vh(a2, b2) {
    return "function" === typeof b2 ? b2(a2) : b2;
  }
  function Wh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2)
      throw Error(p$3(311));
    c2.lastRenderedReducer = a2;
    var d2 = N, e2 = d2.baseQueue, f2 = c2.pending;
    if (null !== f2) {
      if (null !== e2) {
        var g2 = e2.next;
        e2.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e2 = f2;
      c2.pending = null;
    }
    if (null !== e2) {
      f2 = e2.next;
      d2 = d2.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2)
          null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
        else {
          var q2 = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
          M$1.lanes |= m2;
          rh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g2 = d2 : k2.next = h2;
      He$1(d2, b2.memoizedState) || (dh = true);
      b2.memoizedState = d2;
      b2.baseState = g2;
      b2.baseQueue = k2;
      c2.lastRenderedState = d2;
    }
    a2 = c2.interleaved;
    if (null !== a2) {
      e2 = a2;
      do
        f2 = e2.lane, M$1.lanes |= f2, rh |= f2, e2 = e2.next;
      while (e2 !== a2);
    } else
      null === e2 && (c2.lanes = 0);
    return [b2.memoizedState, c2.dispatch];
  }
  function Xh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2)
      throw Error(p$3(311));
    c2.lastRenderedReducer = a2;
    var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
    if (null !== e2) {
      c2.pending = null;
      var g2 = e2 = e2.next;
      do
        f2 = a2(f2, g2.action), g2 = g2.next;
      while (g2 !== e2);
      He$1(f2, b2.memoizedState) || (dh = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c2.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function Yh() {
  }
  function Zh(a2, b2) {
    var c2 = M$1, d2 = Uh(), e2 = b2(), f2 = !He$1(d2.memoizedState, e2);
    f2 && (d2.memoizedState = e2, dh = true);
    d2 = d2.queue;
    $h(ai.bind(null, c2, d2, a2), [a2]);
    if (d2.getSnapshot !== b2 || f2 || null !== O$1 && O$1.memoizedState.tag & 1) {
      c2.flags |= 2048;
      bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
      if (null === Q$1)
        throw Error(p$3(349));
      0 !== (Hh & 30) || di(c2, b2, e2);
    }
    return e2;
  }
  function di(a2, b2, c2) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b2, value: c2 };
    b2 = M$1.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
  }
  function ci(a2, b2, c2, d2) {
    b2.value = c2;
    b2.getSnapshot = d2;
    ei(b2) && fi(a2);
  }
  function ai(a2, b2, c2) {
    return c2(function() {
      ei(b2) && fi(a2);
    });
  }
  function ei(a2) {
    var b2 = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c2 = b2();
      return !He$1(a2, c2);
    } catch (d2) {
      return true;
    }
  }
  function fi(a2) {
    var b2 = ih(a2, 1);
    null !== b2 && gi(b2, a2, 1, -1);
  }
  function hi(a2) {
    var b2 = Th();
    "function" === typeof a2 && (a2 = a2());
    b2.memoizedState = b2.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
    b2.queue = a2;
    a2 = a2.dispatch = ii.bind(null, M$1, a2);
    return [b2.memoizedState, a2];
  }
  function bi(a2, b2, c2, d2) {
    a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
    b2 = M$1.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
    return a2;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a2, b2, c2, d2) {
    var e2 = Th();
    M$1.flags |= a2;
    e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
  }
  function li(a2, b2, c2, d2) {
    var e2 = Uh();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== N) {
      var g2 = N.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Mh(d2, g2.deps)) {
        e2.memoizedState = bi(b2, c2, f2, d2);
        return;
      }
    }
    M$1.flags |= a2;
    e2.memoizedState = bi(1 | b2, c2, f2, d2);
  }
  function mi(a2, b2) {
    return ki(8390656, 8, a2, b2);
  }
  function $h(a2, b2) {
    return li(2048, 8, a2, b2);
  }
  function ni(a2, b2) {
    return li(4, 2, a2, b2);
  }
  function oi(a2, b2) {
    return li(4, 4, a2, b2);
  }
  function pi(a2, b2) {
    if ("function" === typeof b2)
      return a2 = a2(), b2(a2), function() {
        b2(null);
      };
    if (null !== b2 && void 0 !== b2)
      return a2 = a2(), b2.current = a2, function() {
        b2.current = null;
      };
  }
  function qi(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return li(4, 4, pi.bind(null, b2, a2), c2);
  }
  function ri() {
  }
  function si(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
      return d2[0];
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ti(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1]))
      return d2[0];
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ui(a2, b2, c2) {
    if (0 === (Hh & 21))
      return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
    He$1(c2, b2) || (c2 = yc(), M$1.lanes |= c2, rh |= c2, a2.baseState = true);
    return b2;
  }
  function vi(a2, b2) {
    var c2 = C;
    C = 0 !== c2 && 4 > c2 ? c2 : 4;
    a2(true);
    var d2 = Gh.transition;
    Gh.transition = {};
    try {
      a2(false), b2();
    } finally {
      C = c2, Gh.transition = d2;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a2, b2, c2) {
    var d2 = yi(a2);
    c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2))
      Ai(b2, c2);
    else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
      var e2 = R();
      gi(c2, a2, d2, e2);
      Bi(c2, b2, d2);
    }
  }
  function ii(a2, b2, c2) {
    var d2 = yi(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2))
      Ai(b2, e2);
    else {
      var f2 = a2.alternate;
      if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
        try {
          var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
          e2.hasEagerState = true;
          e2.eagerState = h2;
          if (He$1(h2, g2)) {
            var k2 = b2.interleaved;
            null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
            b2.interleaved = e2;
            return;
          }
        } catch (l2) {
        } finally {
        }
      c2 = hh(a2, b2, e2, d2);
      null !== c2 && (e2 = R(), gi(c2, a2, d2, e2), Bi(c2, b2, d2));
    }
  }
  function zi(a2) {
    var b2 = a2.alternate;
    return a2 === M$1 || null !== b2 && b2 === M$1;
  }
  function Ai(a2, b2) {
    Jh = Ih = true;
    var c2 = a2.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a2.pending = b2;
  }
  function Bi(a2, b2, c2) {
    if (0 !== (c2 & 4194240)) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc$1(a2, c2);
    }
  }
  var Rh = { readContext: eh, useCallback: P$2, useContext: P$2, useEffect: P$2, useImperativeHandle: P$2, useInsertionEffect: P$2, useLayoutEffect: P$2, useMemo: P$2, useReducer: P$2, useRef: P$2, useState: P$2, useDebugValue: P$2, useDeferredValue: P$2, useTransition: P$2, useMutableSource: P$2, useSyncExternalStore: P$2, useId: P$2, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
    Th().memoizedState = [a2, void 0 === b2 ? null : b2];
    return a2;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b2, a2),
      c2
    );
  }, useLayoutEffect: function(a2, b2) {
    return ki(4194308, 4, a2, b2);
  }, useInsertionEffect: function(a2, b2) {
    return ki(4, 2, a2, b2);
  }, useMemo: function(a2, b2) {
    var c2 = Th();
    b2 = void 0 === b2 ? null : b2;
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }, useReducer: function(a2, b2, c2) {
    var d2 = Th();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
    d2.queue = a2;
    a2 = a2.dispatch = xi.bind(null, M$1, a2);
    return [d2.memoizedState, a2];
  }, useRef: function(a2) {
    var b2 = Th();
    a2 = { current: a2 };
    return b2.memoizedState = a2;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
    return Th().memoizedState = a2;
  }, useTransition: function() {
    var a2 = hi(false), b2 = a2[0];
    a2 = vi.bind(null, a2[1]);
    Th().memoizedState = a2;
    return [b2, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b2, c2) {
    var d2 = M$1, e2 = Th();
    if (I$1) {
      if (void 0 === c2)
        throw Error(p$3(407));
      c2 = c2();
    } else {
      c2 = b2();
      if (null === Q$1)
        throw Error(p$3(349));
      0 !== (Hh & 30) || di(d2, b2, c2);
    }
    e2.memoizedState = c2;
    var f2 = { value: c2, getSnapshot: b2 };
    e2.queue = f2;
    mi(ai.bind(
      null,
      d2,
      f2,
      a2
    ), [a2]);
    d2.flags |= 2048;
    bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
    return c2;
  }, useId: function() {
    var a2 = Th(), b2 = Q$1.identifierPrefix;
    if (I$1) {
      var c2 = sg;
      var d2 = rg;
      c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
      b2 = ":" + b2 + "R" + c2;
      c2 = Kh++;
      0 < c2 && (b2 += "H" + c2.toString(32));
      b2 += ":";
    } else
      c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
    return a2.memoizedState = b2;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a2) {
      var b2 = Uh();
      return ui(b2, N.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
      return [a2, b2];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a2) {
    var b2 = Uh();
    return null === N ? b2.memoizedState = a2 : ui(b2, N.memoizedState, a2);
  }, useTransition: function() {
    var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a2, b2) {
    if (a2 && a2.defaultProps) {
      b2 = A$1({}, b2);
      a2 = a2.defaultProps;
      for (var c2 in a2)
        void 0 === b2[c2] && (b2[c2] = a2[c2]);
      return b2;
    }
    return b2;
  }
  function Di(a2, b2, c2, d2) {
    b2 = a2.memoizedState;
    c2 = c2(d2, b2);
    c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
    a2.memoizedState = c2;
    0 === a2.lanes && (a2.updateQueue.baseState = c2);
  }
  var Ei = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e2);
    null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
  }, enqueueReplaceState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e2);
    null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
  }, enqueueForceUpdate: function(a2, b2) {
    a2 = a2._reactInternals;
    var c2 = R(), d2 = yi(a2), e2 = mh(c2, d2);
    e2.tag = 2;
    void 0 !== b2 && null !== b2 && (e2.callback = b2);
    b2 = nh(a2, e2, d2);
    null !== b2 && (gi(b2, a2, d2, c2), oh(b2, a2, d2));
  } };
  function Fi(a2, b2, c2, d2, e2, f2, g2) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e2, f2) : true;
  }
  function Gi(a2, b2, c2) {
    var d2 = false, e2 = Vf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
    b2 = new b2(c2, f2);
    a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = Ei;
    a2.stateNode = b2;
    b2._reactInternals = a2;
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function Hi(a2, b2, c2, d2) {
    a2 = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
    b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
  }
  function Ii(a2, b2, c2, d2) {
    var e2 = a2.stateNode;
    e2.props = c2;
    e2.state = a2.memoizedState;
    e2.refs = {};
    kh(a2);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H$1.current, e2.context = Yf(a2, f2));
    e2.state = a2.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (Di(a2, b2, f2, c2), e2.state = a2.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d2), e2.state = a2.memoizedState);
    "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
  }
  function Ji(a2, b2) {
    try {
      var c2 = "", d2 = b2;
      do
        c2 += Pa(d2), d2 = d2.return;
      while (d2);
      var e2 = c2;
    } catch (f2) {
      e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a2, source: b2, stack: e2, digest: null };
  }
  function Ki(a2, b2, c2) {
    return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
  }
  function Li(a2, b2) {
    try {
      console.error(b2.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d2 = b2.value;
    c2.callback = function() {
      Oi || (Oi = true, Pi = d2);
      Li(a2, b2);
    };
    return c2;
  }
  function Qi(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    var d2 = a2.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e2 = b2.value;
      c2.payload = function() {
        return d2(e2);
      };
      c2.callback = function() {
        Li(a2, b2);
      };
    }
    var f2 = a2.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
      Li(a2, b2);
      "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c3 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Si(a2, b2, c2) {
    var d2 = a2.pingCache;
    if (null === d2) {
      d2 = a2.pingCache = new Mi();
      var e2 = /* @__PURE__ */ new Set();
      d2.set(b2, e2);
    } else
      e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
    e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
  }
  function Ui(a2) {
    do {
      var b2;
      if (b2 = 13 === a2.tag)
        b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
      if (b2)
        return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Vi(a2, b2, c2, d2, e2) {
    if (0 === (a2.mode & 1))
      return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e2;
    return a2;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a2, b2, c2, d2) {
    b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
  }
  function Yi(a2, b2, c2, d2, e2) {
    c2 = c2.render;
    var f2 = b2.ref;
    ch(b2, e2);
    d2 = Nh(a2, b2, c2, d2, f2, e2);
    c2 = Sh();
    if (null !== a2 && !dh)
      return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
    I$1 && c2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, d2, e2);
    return b2.child;
  }
  function $i(a2, b2, c2, d2, e2) {
    if (null === a2) {
      var f2 = c2.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
        return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e2);
      a2 = Rg(c2.type, null, d2, b2, b2.mode, e2);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    f2 = a2.child;
    if (0 === (a2.lanes & e2)) {
      var g2 = f2.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie$1;
      if (c2(g2, d2) && a2.ref === b2.ref)
        return Zi(a2, b2, e2);
    }
    b2.flags |= 1;
    a2 = Pg(f2, d2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  function bj(a2, b2, c2, d2, e2) {
    if (null !== a2) {
      var f2 = a2.memoizedProps;
      if (Ie$1(f2, d2) && a2.ref === b2.ref)
        if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
          0 !== (a2.flags & 131072) && (dh = true);
        else
          return b2.lanes = a2.lanes, Zi(a2, b2, e2);
    }
    return cj(a2, b2, c2, d2, e2);
  }
  function dj(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d2.mode)
      if (0 === (b2.mode & 1))
        b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(ej, fj), fj |= c2;
      else {
        if (0 === (c2 & 1073741824))
          return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(ej, fj), fj |= a2, null;
        b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
        d2 = null !== f2 ? f2.baseLanes : c2;
        G$1(ej, fj);
        fj |= d2;
      }
    else
      null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(ej, fj), fj |= d2;
    Xi(a2, b2, e2, c2);
    return b2.child;
  }
  function gj(a2, b2) {
    var c2 = b2.ref;
    if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
      b2.flags |= 512, b2.flags |= 2097152;
  }
  function cj(a2, b2, c2, d2, e2) {
    var f2 = Zf(c2) ? Xf : H$1.current;
    f2 = Yf(b2, f2);
    ch(b2, e2);
    c2 = Nh(a2, b2, c2, d2, f2, e2);
    d2 = Sh();
    if (null !== a2 && !dh)
      return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
    I$1 && d2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, c2, e2);
    return b2.child;
  }
  function hj(a2, b2, c2, d2, e2) {
    if (Zf(c2)) {
      var f2 = true;
      cg(b2);
    } else
      f2 = false;
    ch(b2, e2);
    if (null === b2.stateNode)
      ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
    else if (null === a2) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H$1.current, l2 = Yf(b2, l2));
      var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
      jh = false;
      var r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e2);
      k2 = b2.memoizedState;
      h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
    } else {
      g2 = b2.stateNode;
      lh(a2, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
      g2.props = l2;
      q2 = b2.pendingProps;
      r2 = g2.context;
      k2 = c2.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H$1.current, k2 = Yf(b2, k2));
      var y2 = c2.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
      jh = false;
      r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e2);
      var n2 = b2.memoizedState;
      h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
    }
    return jj(a2, b2, c2, d2, f2, e2);
  }
  function jj(a2, b2, c2, d2, e2, f2) {
    gj(a2, b2);
    var g2 = 0 !== (b2.flags & 128);
    if (!d2 && !g2)
      return e2 && dg(b2, c2, false), Zi(a2, b2, f2);
    d2 = b2.stateNode;
    Wi.current = b2;
    var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
    b2.flags |= 1;
    null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
    b2.memoizedState = d2.state;
    e2 && dg(b2, c2, true);
    return b2.child;
  }
  function kj(a2) {
    var b2 = a2.stateNode;
    b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
    yh(a2, b2.containerInfo);
  }
  function lj(a2, b2, c2, d2, e2) {
    Ig();
    Jg(e2);
    b2.flags |= 256;
    Xi(a2, b2, c2, d2);
    return b2.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function oj(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
    if (h2)
      f2 = true, b2.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState)
      e2 |= 1;
    G$1(L, e2 & 1);
    if (null === a2) {
      Eg(b2);
      a2 = b2.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
        return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
      g2 = d2.children;
      a2 = d2.fallback;
      return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
    }
    e2 = a2.memoizedState;
    if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
      return rj(a2, b2, g2, d2, h2, e2, c2);
    if (f2) {
      f2 = d2.fallback;
      g2 = b2.mode;
      e2 = a2.child;
      h2 = e2.sibling;
      var k2 = { mode: "hidden", children: d2.children };
      0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
      null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
      f2.return = b2;
      d2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      d2 = f2;
      f2 = b2.child;
      g2 = a2.child.memoizedState;
      g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a2.childLanes & ~c2;
      b2.memoizedState = mj;
      return d2;
    }
    f2 = a2.child;
    a2 = f2.sibling;
    d2 = Pg(f2, { mode: "visible", children: d2.children });
    0 === (b2.mode & 1) && (d2.lanes = c2);
    d2.return = b2;
    d2.sibling = null;
    null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
    b2.child = d2;
    b2.memoizedState = null;
    return d2;
  }
  function qj(a2, b2) {
    b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
    b2.return = a2;
    return a2.child = b2;
  }
  function sj(a2, b2, c2, d2) {
    null !== d2 && Jg(d2);
    Ug(b2, a2.child, null, c2);
    a2 = qj(b2, b2.pendingProps.children);
    a2.flags |= 2;
    b2.memoizedState = null;
    return a2;
  }
  function rj(a2, b2, c2, d2, e2, f2, g2) {
    if (c2) {
      if (b2.flags & 256)
        return b2.flags &= -257, d2 = Ki(Error(p$3(422))), sj(a2, b2, g2, d2);
      if (null !== b2.memoizedState)
        return b2.child = a2.child, b2.flags |= 128, null;
      f2 = d2.fallback;
      e2 = b2.mode;
      d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
      f2 = Tg(f2, e2, g2, null);
      f2.flags |= 2;
      d2.return = b2;
      f2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
      b2.child.memoizedState = nj(g2);
      b2.memoizedState = mj;
      return f2;
    }
    if (0 === (b2.mode & 1))
      return sj(a2, b2, g2, null);
    if ("$!" === e2.data) {
      d2 = e2.nextSibling && e2.nextSibling.dataset;
      if (d2)
        var h2 = d2.dgst;
      d2 = h2;
      f2 = Error(p$3(419));
      d2 = Ki(f2, d2, void 0);
      return sj(a2, b2, g2, d2);
    }
    h2 = 0 !== (g2 & a2.childLanes);
    if (dh || h2) {
      d2 = Q$1;
      if (null !== d2) {
        switch (g2 & -g2) {
          case 4:
            e2 = 2;
            break;
          case 16:
            e2 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e2 = 32;
            break;
          case 536870912:
            e2 = 268435456;
            break;
          default:
            e2 = 0;
        }
        e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
        0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi(d2, a2, e2, -1));
      }
      tj();
      d2 = Ki(Error(p$3(421)));
      return sj(a2, b2, g2, d2);
    }
    if ("$?" === e2.data)
      return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e2._reactRetry = b2, null;
    a2 = f2.treeContext;
    yg = Lf(e2.nextSibling);
    xg = b2;
    I$1 = true;
    zg = null;
    null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
    b2 = qj(b2, d2.children);
    b2.flags |= 4096;
    return b2;
  }
  function vj(a2, b2, c2) {
    a2.lanes |= b2;
    var d2 = a2.alternate;
    null !== d2 && (d2.lanes |= b2);
    bh(a2.return, b2, c2);
  }
  function wj(a2, b2, c2, d2, e2) {
    var f2 = a2.memoizedState;
    null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
  }
  function xj(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
    Xi(a2, b2, d2.children, c2);
    d2 = L.current;
    if (0 !== (d2 & 2))
      d2 = d2 & 1 | 2, b2.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128))
        a:
          for (a2 = b2.child; null !== a2; ) {
            if (13 === a2.tag)
              null !== a2.memoizedState && vj(a2, c2, b2);
            else if (19 === a2.tag)
              vj(a2, c2, b2);
            else if (null !== a2.child) {
              a2.child.return = a2;
              a2 = a2.child;
              continue;
            }
            if (a2 === b2)
              break a;
            for (; null === a2.sibling; ) {
              if (null === a2.return || a2.return === b2)
                break a;
              a2 = a2.return;
            }
            a2.sibling.return = a2.return;
            a2 = a2.sibling;
          }
      d2 &= 1;
    }
    G$1(L, d2);
    if (0 === (b2.mode & 1))
      b2.memoizedState = null;
    else
      switch (e2) {
        case "forwards":
          c2 = b2.child;
          for (e2 = null; null !== c2; )
            a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
          c2 = e2;
          null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
          wj(b2, false, e2, c2, f2);
          break;
        case "backwards":
          c2 = null;
          e2 = b2.child;
          for (b2.child = null; null !== e2; ) {
            a2 = e2.alternate;
            if (null !== a2 && null === Ch(a2)) {
              b2.child = e2;
              break;
            }
            a2 = e2.sibling;
            e2.sibling = c2;
            c2 = e2;
            e2 = a2;
          }
          wj(b2, true, c2, null, f2);
          break;
        case "together":
          wj(b2, false, null, null, void 0);
          break;
        default:
          b2.memoizedState = null;
      }
    return b2.child;
  }
  function ij(a2, b2) {
    0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
  }
  function Zi(a2, b2, c2) {
    null !== a2 && (b2.dependencies = a2.dependencies);
    rh |= b2.lanes;
    if (0 === (c2 & b2.childLanes))
      return null;
    if (null !== a2 && b2.child !== a2.child)
      throw Error(p$3(153));
    if (null !== b2.child) {
      a2 = b2.child;
      c2 = Pg(a2, a2.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a2.sibling; )
        a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  function yj(a2, b2, c2) {
    switch (b2.tag) {
      case 3:
        kj(b2);
        Ig();
        break;
      case 5:
        Ah(b2);
        break;
      case 1:
        Zf(b2.type) && cg(b2);
        break;
      case 4:
        yh(b2, b2.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b2.type._context, e2 = b2.memoizedProps.value;
        G$1(Wg, d2._currentValue);
        d2._currentValue = e2;
        break;
      case 13:
        d2 = b2.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated)
            return G$1(L, L.current & 1), b2.flags |= 128, null;
          if (0 !== (c2 & b2.child.childLanes))
            return oj(a2, b2, c2);
          G$1(L, L.current & 1);
          a2 = Zi(a2, b2, c2);
          return null !== a2 ? a2.sibling : null;
        }
        G$1(L, L.current & 1);
        break;
      case 19:
        d2 = 0 !== (c2 & b2.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d2)
            return xj(a2, b2, c2);
          b2.flags |= 128;
        }
        e2 = b2.memoizedState;
        null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
        G$1(L, L.current);
        if (d2)
          break;
        else
          return null;
      case 22:
      case 23:
        return b2.lanes = 0, dj(a2, b2, c2);
    }
    return Zi(a2, b2, c2);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a2, b2) {
    for (var c2 = b2.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag)
        a2.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2)
        break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2)
          return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a2, b2, c2, d2) {
    var e2 = a2.memoizedProps;
    if (e2 !== d2) {
      a2 = b2.stateNode;
      xh(uh.current);
      var f2 = null;
      switch (c2) {
        case "input":
          e2 = Ya(a2, e2);
          d2 = Ya(a2, d2);
          f2 = [];
          break;
        case "select":
          e2 = A$1({}, e2, { value: void 0 });
          d2 = A$1({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e2 = gb(a2, e2);
          d2 = gb(a2, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
      }
      ub(c2, d2);
      var g2;
      c2 = null;
      for (l2 in e2)
        if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
          if ("style" === l2) {
            var h2 = e2[l2];
            for (g2 in h2)
              h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
          } else
            "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d2) {
        var k2 = d2[l2];
        h2 = null != e2 ? e2[l2] : void 0;
        if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
          if ("style" === l2)
            if (h2) {
              for (g2 in h2)
                !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
              for (g2 in k2)
                k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
            } else
              c2 || (f2 || (f2 = []), f2.push(
                l2,
                c2
              )), c2 = k2;
          else
            "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c2 && (f2 = f2 || []).push("style", c2);
      var l2 = f2;
      if (b2.updateQueue = l2)
        b2.flags |= 4;
    }
  };
  Cj = function(a2, b2, c2, d2) {
    c2 !== d2 && (b2.flags |= 4);
  };
  function Dj(a2, b2) {
    if (!I$1)
      switch (a2.tailMode) {
        case "hidden":
          b2 = a2.tail;
          for (var c2 = null; null !== b2; )
            null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
          null === c2 ? a2.tail = null : c2.sibling = null;
          break;
        case "collapsed":
          c2 = a2.tail;
          for (var d2 = null; null !== c2; )
            null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
          null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
      }
  }
  function S$1(a2) {
    var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
    if (b2)
      for (var e2 = a2.child; null !== e2; )
        c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
    else
      for (e2 = a2.child; null !== e2; )
        c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
    a2.subtreeFlags |= d2;
    a2.childLanes = c2;
    return b2;
  }
  function Ej(a2, b2, c2) {
    var d2 = b2.pendingProps;
    wg(b2);
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S$1(b2), null;
      case 1:
        return Zf(b2.type) && $f(), S$1(b2), null;
      case 3:
        d2 = b2.stateNode;
        zh();
        E(Wf);
        E(H$1);
        Eh();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a2 || null === a2.child)
          Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a2, b2);
        S$1(b2);
        return null;
      case 5:
        Bh(b2);
        var e2 = xh(wh.current);
        c2 = b2.type;
        if (null !== a2 && null != b2.stateNode)
          Bj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b2.stateNode)
              throw Error(p$3(166));
            S$1(b2);
            return null;
          }
          a2 = xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.type;
            var f2 = b2.memoizedProps;
            d2[Of] = b2;
            d2[Pf] = f2;
            a2 = 0 !== (b2.mode & 1);
            switch (c2) {
              case "dialog":
                D$2("cancel", d2);
                D$2("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", d2);
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$2(lf[e2], d2);
                break;
              case "source":
                D$2("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  d2
                );
                D$2("load", d2);
                break;
              case "details":
                D$2("toggle", d2);
                break;
              case "input":
                Za(d2, f2);
                D$2("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                D$2("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), D$2("invalid", d2);
            }
            ub(c2, f2);
            e2 = null;
            for (var g2 in f2)
              if (f2.hasOwnProperty(g2)) {
                var h2 = f2[g2];
                "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                  d2.textContent,
                  h2,
                  a2
                ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$2("scroll", d2);
              }
            switch (c2) {
              case "input":
                Va(d2);
                db(d2, f2, true);
                break;
              case "textarea":
                Va(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = Bf);
            }
            d2 = e2;
            b2.updateQueue = d2;
            null !== d2 && (b2.flags |= 4);
          } else {
            g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
            a2[Of] = b2;
            a2[Pf] = d2;
            zj(a2, b2, false, false);
            b2.stateNode = a2;
            a: {
              g2 = vb(c2, d2);
              switch (c2) {
                case "dialog":
                  D$2("cancel", a2);
                  D$2("close", a2);
                  e2 = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D$2("load", a2);
                  e2 = d2;
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D$2(lf[e2], a2);
                  e2 = d2;
                  break;
                case "source":
                  D$2("error", a2);
                  e2 = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D$2(
                    "error",
                    a2
                  );
                  D$2("load", a2);
                  e2 = d2;
                  break;
                case "details":
                  D$2("toggle", a2);
                  e2 = d2;
                  break;
                case "input":
                  Za(a2, d2);
                  e2 = Ya(a2, d2);
                  D$2("invalid", a2);
                  break;
                case "option":
                  e2 = d2;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d2.multiple };
                  e2 = A$1({}, d2, { value: void 0 });
                  D$2("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d2);
                  e2 = gb(a2, d2);
                  D$2("invalid", a2);
                  break;
                default:
                  e2 = d2;
              }
              ub(c2, e2);
              h2 = e2;
              for (f2 in h2)
                if (h2.hasOwnProperty(f2)) {
                  var k2 = h2[f2];
                  "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$2("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
                }
              switch (c2) {
                case "input":
                  Va(a2);
                  db(a2, d2, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a2.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                    a2,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e2.onClick && (a2.onclick = Bf);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        }
        S$1(b2);
        return null;
      case 6:
        if (a2 && null != b2.stateNode)
          Cj(a2, b2, a2.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b2.stateNode)
            throw Error(p$3(166));
          c2 = xh(wh.current);
          xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.memoizedProps;
            d2[Of] = b2;
            if (f2 = d2.nodeValue !== c2) {
              if (a2 = xg, null !== a2)
                switch (a2.tag) {
                  case 3:
                    Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                    break;
                  case 5:
                    true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                }
            }
            f2 && (b2.flags |= 4);
          } else
            d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
        }
        S$1(b2);
        return null;
      case 13:
        E(L);
        d2 = b2.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
            Hg(), Ig(), b2.flags |= 98560, f2 = false;
          else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
            if (null === a2) {
              if (!f2)
                throw Error(p$3(318));
              f2 = b2.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2)
                throw Error(p$3(317));
              f2[Of] = b2;
            } else
              Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
            S$1(b2);
            f2 = false;
          } else
            null !== zg && (Fj(zg), zg = null), f2 = true;
          if (!f2)
            return b2.flags & 65536 ? b2 : null;
        }
        if (0 !== (b2.flags & 128))
          return b2.lanes = c2, b2;
        d2 = null !== d2;
        d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T$1 && (T$1 = 3) : tj()));
        null !== b2.updateQueue && (b2.flags |= 4);
        S$1(b2);
        return null;
      case 4:
        return zh(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
      case 10:
        return ah(b2.type._context), S$1(b2), null;
      case 17:
        return Zf(b2.type) && $f(), S$1(b2), null;
      case 19:
        E(L);
        f2 = b2.memoizedState;
        if (null === f2)
          return S$1(b2), null;
        d2 = 0 !== (b2.flags & 128);
        g2 = f2.rendering;
        if (null === g2)
          if (d2)
            Dj(f2, false);
          else {
            if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128))
              for (a2 = b2.child; null !== a2; ) {
                g2 = Ch(a2);
                if (null !== g2) {
                  b2.flags |= 128;
                  Dj(f2, false);
                  d2 = g2.updateQueue;
                  null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                  b2.subtreeFlags = 0;
                  d2 = c2;
                  for (c2 = b2.child; null !== c2; )
                    f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                  G$1(L, L.current & 1 | 2);
                  return b2.child;
                }
                a2 = a2.sibling;
              }
            null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
          }
        else {
          if (!d2)
            if (a2 = Ch(g2), null !== a2) {
              if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
                return S$1(b2), null;
            } else
              2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
        }
        if (null !== f2.tail)
          return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G$1(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
        S$1(b2);
        return null;
      case 22:
      case 23:
        return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p$3(156, b2.tag));
  }
  function Ij(a2, b2) {
    wg(b2);
    switch (b2.tag) {
      case 1:
        return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 3:
        return zh(), E(Wf), E(H$1), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 5:
        return Bh(b2), null;
      case 13:
        E(L);
        a2 = b2.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b2.alternate)
            throw Error(p$3(340));
          Ig();
        }
        a2 = b2.flags;
        return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b2.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U$1 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
  function Lj(a2, b2) {
    var c2 = a2.ref;
    if (null !== c2)
      if ("function" === typeof c2)
        try {
          c2(null);
        } catch (d2) {
          W$1(a2, b2, d2);
        }
      else
        c2.current = null;
  }
  function Mj(a2, b2, c2) {
    try {
      c2();
    } catch (d2) {
      W$1(a2, b2, d2);
    }
  }
  var Nj = false;
  function Oj(a2, b2) {
    Cf = dd;
    a2 = Me$1();
    if (Ne(a2)) {
      if ("selectionStart" in a2)
        var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
      else
        a: {
          c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
          var d2 = c2.getSelection && c2.getSelection();
          if (d2 && 0 !== d2.rangeCount) {
            c2 = d2.anchorNode;
            var e2 = d2.anchorOffset, f2 = d2.focusNode;
            d2 = d2.focusOffset;
            try {
              c2.nodeType, f2.nodeType;
            } catch (F2) {
              c2 = null;
              break a;
            }
            var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
            b:
              for (; ; ) {
                for (var y2; ; ) {
                  q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                  q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                  3 === q2.nodeType && (g2 += q2.nodeValue.length);
                  if (null === (y2 = q2.firstChild))
                    break;
                  r2 = q2;
                  q2 = y2;
                }
                for (; ; ) {
                  if (q2 === a2)
                    break b;
                  r2 === c2 && ++l2 === e2 && (h2 = g2);
                  r2 === f2 && ++m2 === d2 && (k2 = g2);
                  if (null !== (y2 = q2.nextSibling))
                    break;
                  q2 = r2;
                  r2 = q2.parentNode;
                }
                q2 = y2;
              }
            c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
          } else
            c2 = null;
        }
      c2 = c2 || { start: 0, end: 0 };
    } else
      c2 = null;
    Df = { focusedElem: a2, selectionRange: c2 };
    dd = false;
    for (V$1 = b2; null !== V$1; )
      if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
        a2.return = b2, V$1 = a2;
      else
        for (; null !== V$1; ) {
          b2 = V$1;
          try {
            var n2 = b2.alternate;
            if (0 !== (b2.flags & 1024))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (null !== n2) {
                    var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
                    x2.__reactInternalSnapshotBeforeUpdate = w2;
                  }
                  break;
                case 3:
                  var u2 = b2.stateNode.containerInfo;
                  1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(p$3(163));
              }
          } catch (F2) {
            W$1(b2, b2.return, F2);
          }
          a2 = b2.sibling;
          if (null !== a2) {
            a2.return = b2.return;
            V$1 = a2;
            break;
          }
          V$1 = b2.return;
        }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a2, b2, c2) {
    var d2 = b2.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e2 = d2 = d2.next;
      do {
        if ((e2.tag & a2) === a2) {
          var f2 = e2.destroy;
          e2.destroy = void 0;
          void 0 !== f2 && Mj(b2, c2, f2);
        }
        e2 = e2.next;
      } while (e2 !== d2);
    }
  }
  function Qj(a2, b2) {
    b2 = b2.updateQueue;
    b2 = null !== b2 ? b2.lastEffect : null;
    if (null !== b2) {
      var c2 = b2 = b2.next;
      do {
        if ((c2.tag & a2) === a2) {
          var d2 = c2.create;
          c2.destroy = d2();
        }
        c2 = c2.next;
      } while (c2 !== b2);
    }
  }
  function Rj(a2) {
    var b2 = a2.ref;
    if (null !== b2) {
      var c2 = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c2;
          break;
        default:
          a2 = c2;
      }
      "function" === typeof b2 ? b2(a2) : b2.current = a2;
    }
  }
  function Sj(a2) {
    var b2 = a2.alternate;
    null !== b2 && (a2.alternate = null, Sj(b2));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Tj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Uj(a2) {
    a:
      for (; ; ) {
        for (; null === a2.sibling; ) {
          if (null === a2.return || Tj(a2.return))
            return null;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
          if (a2.flags & 2)
            continue a;
          if (null === a2.child || 4 === a2.tag)
            continue a;
          else
            a2.child.return = a2, a2 = a2.child;
        }
        if (!(a2.flags & 2))
          return a2.stateNode;
      }
  }
  function Vj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2)
      a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
    else if (4 !== d2 && (a2 = a2.child, null !== a2))
      for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
        Vj(a2, b2, c2), a2 = a2.sibling;
  }
  function Wj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2)
      a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
    else if (4 !== d2 && (a2 = a2.child, null !== a2))
      for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
        Wj(a2, b2, c2), a2 = a2.sibling;
  }
  var X$1 = null, Xj = false;
  function Yj(a2, b2, c2) {
    for (c2 = c2.child; null !== c2; )
      Zj(a2, b2, c2), c2 = c2.sibling;
  }
  function Zj(a2, b2, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount)
      try {
        lc.onCommitFiberUnmount(kc, c2);
      } catch (h2) {
      }
    switch (c2.tag) {
      case 5:
        U$1 || Lj(c2, b2);
      case 6:
        var d2 = X$1, e2 = Xj;
        X$1 = null;
        Yj(a2, b2, c2);
        X$1 = d2;
        Xj = e2;
        null !== X$1 && (Xj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X$1 && (Xj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
        break;
      case 4:
        d2 = X$1;
        e2 = Xj;
        X$1 = c2.stateNode.containerInfo;
        Xj = true;
        Yj(a2, b2, c2);
        X$1 = d2;
        Xj = e2;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e2 = d2 = d2.next;
          do {
            var f2 = e2, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
            e2 = e2.next;
          } while (e2 !== d2);
        }
        Yj(a2, b2, c2);
        break;
      case 1:
        if (!U$1 && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
          try {
            d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
          } catch (h2) {
            W$1(c2, b2, h2);
          }
        Yj(a2, b2, c2);
        break;
      case 21:
        Yj(a2, b2, c2);
        break;
      case 22:
        c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Yj(a2, b2, c2), U$1 = d2) : Yj(a2, b2, c2);
        break;
      default:
        Yj(a2, b2, c2);
    }
  }
  function ak(a2) {
    var b2 = a2.updateQueue;
    if (null !== b2) {
      a2.updateQueue = null;
      var c2 = a2.stateNode;
      null === c2 && (c2 = a2.stateNode = new Kj());
      b2.forEach(function(b3) {
        var d2 = bk.bind(null, a2, b3);
        c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
      });
    }
  }
  function ck(a2, b2) {
    var c2 = b2.deletions;
    if (null !== c2)
      for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        try {
          var f2 = a2, g2 = b2, h2 = g2;
          a:
            for (; null !== h2; ) {
              switch (h2.tag) {
                case 5:
                  X$1 = h2.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X$1 = h2.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X$1 = h2.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h2 = h2.return;
            }
          if (null === X$1)
            throw Error(p$3(160));
          Zj(f2, g2, e2);
          X$1 = null;
          Xj = false;
          var k2 = e2.alternate;
          null !== k2 && (k2.return = null);
          e2.return = null;
        } catch (l2) {
          W$1(e2, b2, l2);
        }
      }
    if (b2.subtreeFlags & 12854)
      for (b2 = b2.child; null !== b2; )
        dk(b2, a2), b2 = b2.sibling;
  }
  function dk(a2, b2) {
    var c2 = a2.alternate, d2 = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4) {
          try {
            Pj(3, a2, a2.return), Qj(3, a2);
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
          try {
            Pj(5, a2, a2.return);
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
        }
        break;
      case 1:
        ck(b2, a2);
        ek(a2);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        break;
      case 5:
        ck(b2, a2);
        ek(a2);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        if (a2.flags & 32) {
          var e2 = a2.stateNode;
          try {
            ob(e2, "");
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
        }
        if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
          var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k2)
            try {
              "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
              vb(h2, g2);
              var l2 = vb(h2, f2);
              for (g2 = 0; g2 < k2.length; g2 += 2) {
                var m2 = k2[g2], q2 = k2[g2 + 1];
                "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
              }
              switch (h2) {
                case "input":
                  bb(e2, f2);
                  break;
                case "textarea":
                  ib(e2, f2);
                  break;
                case "select":
                  var r2 = e2._wrapperState.wasMultiple;
                  e2._wrapperState.wasMultiple = !!f2.multiple;
                  var y2 = f2.value;
                  null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                    e2,
                    !!f2.multiple,
                    f2.defaultValue,
                    true
                  ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
              }
              e2[Pf] = f2;
            } catch (t2) {
              W$1(a2, a2.return, t2);
            }
        }
        break;
      case 6:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4) {
          if (null === a2.stateNode)
            throw Error(p$3(162));
          e2 = a2.stateNode;
          f2 = a2.memoizedProps;
          try {
            e2.nodeValue = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
        }
        break;
      case 3:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
          try {
            bd(b2.containerInfo);
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
        break;
      case 4:
        ck(b2, a2);
        ek(a2);
        break;
      case 13:
        ck(b2, a2);
        ek(a2);
        e2 = a2.child;
        e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
        d2 & 4 && ak(a2);
        break;
      case 22:
        m2 = null !== c2 && null !== c2.memoizedState;
        a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, ck(b2, a2), U$1 = l2) : ck(b2, a2);
        ek(a2);
        if (d2 & 8192) {
          l2 = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
            for (V$1 = a2, m2 = a2.child; null !== m2; ) {
              for (q2 = V$1 = m2; null !== V$1; ) {
                r2 = V$1;
                y2 = r2.child;
                switch (r2.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Pj(4, r2, r2.return);
                    break;
                  case 1:
                    Lj(r2, r2.return);
                    var n2 = r2.stateNode;
                    if ("function" === typeof n2.componentWillUnmount) {
                      d2 = r2;
                      c2 = r2.return;
                      try {
                        b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                      } catch (t2) {
                        W$1(d2, c2, t2);
                      }
                    }
                    break;
                  case 5:
                    Lj(r2, r2.return);
                    break;
                  case 22:
                    if (null !== r2.memoizedState) {
                      gk(q2);
                      continue;
                    }
                }
                null !== y2 ? (y2.return = r2, V$1 = y2) : gk(q2);
              }
              m2 = m2.sibling;
            }
          a:
            for (m2 = null, q2 = a2; ; ) {
              if (5 === q2.tag) {
                if (null === m2) {
                  m2 = q2;
                  try {
                    e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                  } catch (t2) {
                    W$1(a2, a2.return, t2);
                  }
                }
              } else if (6 === q2.tag) {
                if (null === m2)
                  try {
                    q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                  } catch (t2) {
                    W$1(a2, a2.return, t2);
                  }
              } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
                q2.child.return = q2;
                q2 = q2.child;
                continue;
              }
              if (q2 === a2)
                break a;
              for (; null === q2.sibling; ) {
                if (null === q2.return || q2.return === a2)
                  break a;
                m2 === q2 && (m2 = null);
                q2 = q2.return;
              }
              m2 === q2 && (m2 = null);
              q2.sibling.return = q2.return;
              q2 = q2.sibling;
            }
        }
        break;
      case 19:
        ck(b2, a2);
        ek(a2);
        d2 & 4 && ak(a2);
        break;
      case 21:
        break;
      default:
        ck(
          b2,
          a2
        ), ek(a2);
    }
  }
  function ek(a2) {
    var b2 = a2.flags;
    if (b2 & 2) {
      try {
        a: {
          for (var c2 = a2.return; null !== c2; ) {
            if (Tj(c2)) {
              var d2 = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p$3(160));
        }
        switch (d2.tag) {
          case 5:
            var e2 = d2.stateNode;
            d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
            var f2 = Uj(a2);
            Wj(a2, f2, e2);
            break;
          case 3:
          case 4:
            var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
            Vj(a2, h2, g2);
            break;
          default:
            throw Error(p$3(161));
        }
      } catch (k2) {
        W$1(a2, a2.return, k2);
      }
      a2.flags &= -3;
    }
    b2 & 4096 && (a2.flags &= -4097);
  }
  function hk(a2, b2, c2) {
    V$1 = a2;
    ik(a2);
  }
  function ik(a2, b2, c2) {
    for (var d2 = 0 !== (a2.mode & 1); null !== V$1; ) {
      var e2 = V$1, f2 = e2.child;
      if (22 === e2.tag && d2) {
        var g2 = null !== e2.memoizedState || Jj;
        if (!g2) {
          var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
          h2 = Jj;
          var l2 = U$1;
          Jj = g2;
          if ((U$1 = k2) && !l2)
            for (V$1 = e2; null !== V$1; )
              g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : jk(e2);
          for (; null !== f2; )
            V$1 = f2, ik(f2), f2 = f2.sibling;
          V$1 = e2;
          Jj = h2;
          U$1 = l2;
        }
        kk(a2);
      } else
        0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : kk(a2);
    }
  }
  function kk(a2) {
    for (; null !== V$1; ) {
      var b2 = V$1;
      if (0 !== (b2.flags & 8772)) {
        var c2 = b2.alternate;
        try {
          if (0 !== (b2.flags & 8772))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                U$1 || Qj(5, b2);
                break;
              case 1:
                var d2 = b2.stateNode;
                if (b2.flags & 4 && !U$1)
                  if (null === c2)
                    d2.componentDidMount();
                  else {
                    var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
                    d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                  }
                var f2 = b2.updateQueue;
                null !== f2 && sh(b2, f2, d2);
                break;
              case 3:
                var g2 = b2.updateQueue;
                if (null !== g2) {
                  c2 = null;
                  if (null !== b2.child)
                    switch (b2.child.tag) {
                      case 5:
                        c2 = b2.child.stateNode;
                        break;
                      case 1:
                        c2 = b2.child.stateNode;
                    }
                  sh(b2, g2, c2);
                }
                break;
              case 5:
                var h2 = b2.stateNode;
                if (null === c2 && b2.flags & 4) {
                  c2 = h2;
                  var k2 = b2.memoizedProps;
                  switch (b2.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k2.autoFocus && c2.focus();
                      break;
                    case "img":
                      k2.src && (c2.src = k2.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (null === b2.memoizedState) {
                  var l2 = b2.alternate;
                  if (null !== l2) {
                    var m2 = l2.memoizedState;
                    if (null !== m2) {
                      var q2 = m2.dehydrated;
                      null !== q2 && bd(q2);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(p$3(163));
            }
          U$1 || b2.flags & 512 && Rj(b2);
        } catch (r2) {
          W$1(b2, b2.return, r2);
        }
      }
      if (b2 === a2) {
        V$1 = null;
        break;
      }
      c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V$1 = c2;
        break;
      }
      V$1 = b2.return;
    }
  }
  function gk(a2) {
    for (; null !== V$1; ) {
      var b2 = V$1;
      if (b2 === a2) {
        V$1 = null;
        break;
      }
      var c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V$1 = c2;
        break;
      }
      V$1 = b2.return;
    }
  }
  function jk(a2) {
    for (; null !== V$1; ) {
      var b2 = V$1;
      try {
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b2.return;
            try {
              Qj(4, b2);
            } catch (k2) {
              W$1(b2, c2, k2);
            }
            break;
          case 1:
            var d2 = b2.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e2 = b2.return;
              try {
                d2.componentDidMount();
              } catch (k2) {
                W$1(b2, e2, k2);
              }
            }
            var f2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W$1(b2, f2, k2);
            }
            break;
          case 5:
            var g2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W$1(b2, g2, k2);
            }
        }
      } catch (k2) {
        W$1(b2, b2.return, k2);
      }
      if (b2 === a2) {
        V$1 = null;
        break;
      }
      var h2 = b2.sibling;
      if (null !== h2) {
        h2.return = b2.return;
        V$1 = h2;
        break;
      }
      V$1 = b2.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q$1 = null, Y$2 = null, Z$3 = 0, fj = 0, ej = Uf(0), T$1 = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a2) {
    if (0 === (a2.mode & 1))
      return 1;
    if (0 !== (K & 2) && 0 !== Z$3)
      return Z$3 & -Z$3;
    if (null !== Kg.transition)
      return 0 === Bk && (Bk = yc()), Bk;
    a2 = C;
    if (0 !== a2)
      return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd(a2.type);
    return a2;
  }
  function gi(a2, b2, c2, d2) {
    if (50 < yk)
      throw yk = 0, zk = null, Error(p$3(185));
    Ac(a2, c2, d2);
    if (0 === (K & 2) || a2 !== Q$1)
      a2 === Q$1 && (0 === (K & 2) && (qk |= c2), 4 === T$1 && Ck(a2, Z$3)), Dk(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a2, b2) {
    var c2 = a2.callbackNode;
    wc(a2, b2);
    var d2 = uc(a2, a2 === Q$1 ? Z$3 : 0);
    if (0 === d2)
      null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
      null != c2 && bc(c2);
      if (1 === b2)
        0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
          0 === (K & 6) && jg();
        }), c2 = null;
      else {
        switch (Dc(d2)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Fk(c2, Gk.bind(null, a2));
      }
      a2.callbackPriority = b2;
      a2.callbackNode = c2;
    }
  }
  function Gk(a2, b2) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6))
      throw Error(p$3(327));
    var c2 = a2.callbackNode;
    if (Hk() && a2.callbackNode !== c2)
      return null;
    var d2 = uc(a2, a2 === Q$1 ? Z$3 : 0);
    if (0 === d2)
      return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
      b2 = Ik(a2, d2);
    else {
      b2 = d2;
      var e2 = K;
      K |= 2;
      var f2 = Jk();
      if (Q$1 !== a2 || Z$3 !== b2)
        uk = null, Gj = B() + 500, Kk(a2, b2);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a2, h2);
        }
      while (1);
      $g();
      mk.current = f2;
      K = e2;
      null !== Y$2 ? b2 = 0 : (Q$1 = null, Z$3 = 0, b2 = T$1);
    }
    if (0 !== b2) {
      2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Nk(a2, e2)));
      if (1 === b2)
        throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
      if (6 === b2)
        Ck(a2, d2);
      else {
        e2 = a2.current.alternate;
        if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2))
          throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
        a2.finishedWork = e2;
        a2.finishedLanes = d2;
        switch (b2) {
          case 0:
          case 1:
            throw Error(p$3(345));
          case 2:
            Pk(a2, tk, uk);
            break;
          case 3:
            Ck(a2, d2);
            if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
              if (0 !== uc(a2, 0))
                break;
              e2 = a2.suspendedLanes;
              if ((e2 & d2) !== d2) {
                R();
                a2.pingedLanes |= a2.suspendedLanes & e2;
                break;
              }
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 4:
            Ck(a2, d2);
            if ((d2 & 4194240) === d2)
              break;
            b2 = a2.eventTimes;
            for (e2 = -1; 0 < d2; ) {
              var g2 = 31 - oc(d2);
              f2 = 1 << g2;
              g2 = b2[g2];
              g2 > e2 && (e2 = g2);
              d2 &= ~f2;
            }
            d2 = e2;
            d2 = B() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
            if (10 < d2) {
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 5:
            Pk(a2, tk, uk);
            break;
          default:
            throw Error(p$3(329));
        }
      }
    }
    Dk(a2, B());
    return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
  }
  function Nk(a2, b2) {
    var c2 = sk;
    a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
    a2 = Ik(a2, b2);
    2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
    return a2;
  }
  function Fj(a2) {
    null === tk ? tk = a2 : tk.push.apply(tk, a2);
  }
  function Ok(a2) {
    for (var b2 = a2; ; ) {
      if (b2.flags & 16384) {
        var c2 = b2.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2))
          for (var d2 = 0; d2 < c2.length; d2++) {
            var e2 = c2[d2], f2 = e2.getSnapshot;
            e2 = e2.value;
            try {
              if (!He$1(f2(), e2))
                return false;
            } catch (g2) {
              return false;
            }
          }
      }
      c2 = b2.child;
      if (b2.subtreeFlags & 16384 && null !== c2)
        c2.return = b2, b2 = c2;
      else {
        if (b2 === a2)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2)
            return true;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return true;
  }
  function Ck(a2, b2) {
    b2 &= ~rk;
    b2 &= ~qk;
    a2.suspendedLanes |= b2;
    a2.pingedLanes &= ~b2;
    for (a2 = a2.expirationTimes; 0 < b2; ) {
      var c2 = 31 - oc(b2), d2 = 1 << c2;
      a2[c2] = -1;
      b2 &= ~d2;
    }
  }
  function Ek(a2) {
    if (0 !== (K & 6))
      throw Error(p$3(327));
    Hk();
    var b2 = uc(a2, 0);
    if (0 === (b2 & 1))
      return Dk(a2, B()), null;
    var c2 = Ik(a2, b2);
    if (0 !== a2.tag && 2 === c2) {
      var d2 = xc(a2);
      0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
    }
    if (1 === c2)
      throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B()), c2;
    if (6 === c2)
      throw Error(p$3(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b2;
    Pk(a2, tk, uk);
    Dk(a2, B());
    return null;
  }
  function Qk(a2, b2) {
    var c2 = K;
    K |= 1;
    try {
      return a2(b2);
    } finally {
      K = c2, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a2) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b2 = K;
    K |= 1;
    var c2 = ok.transition, d2 = C;
    try {
      if (ok.transition = null, C = 1, a2)
        return a2();
    } finally {
      C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a2, b2) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c2 = a2.timeoutHandle;
    -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
    if (null !== Y$2)
      for (c2 = Y$2.return; null !== c2; ) {
        var d2 = c2;
        wg(d2);
        switch (d2.tag) {
          case 1:
            d2 = d2.type.childContextTypes;
            null !== d2 && void 0 !== d2 && $f();
            break;
          case 3:
            zh();
            E(Wf);
            E(H$1);
            Eh();
            break;
          case 5:
            Bh(d2);
            break;
          case 4:
            zh();
            break;
          case 13:
            E(L);
            break;
          case 19:
            E(L);
            break;
          case 10:
            ah(d2.type._context);
            break;
          case 22:
          case 23:
            Hj();
        }
        c2 = c2.return;
      }
    Q$1 = a2;
    Y$2 = a2 = Pg(a2.current, null);
    Z$3 = fj = b2;
    T$1 = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b2 = 0; b2 < fh.length; b2++)
        if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
          c2.interleaved = null;
          var e2 = d2.next, f2 = c2.pending;
          if (null !== f2) {
            var g2 = f2.next;
            f2.next = e2;
            d2.next = g2;
          }
          c2.pending = d2;
        }
      fh = null;
    }
    return a2;
  }
  function Mk(a2, b2) {
    do {
      var c2 = Y$2;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d2 = M$1.memoizedState; null !== d2; ) {
            var e2 = d2.queue;
            null !== e2 && (e2.pending = null);
            d2 = d2.next;
          }
          Ih = false;
        }
        Hh = 0;
        O$1 = N = M$1 = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c2 || null === c2.return) {
          T$1 = 1;
          pk = b2;
          Y$2 = null;
          break;
        }
        a: {
          var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
          b2 = Z$3;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m2 = h2, q2 = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui(g2);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g2, h2, f2, b2);
              y2.mode & 1 && Si(f2, l2, b2);
              b2 = y2;
              k2 = l2;
              var n2 = b2.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b2.updateQueue = t2;
              } else
                n2.add(k2);
              break a;
            } else {
              if (0 === (b2 & 1)) {
                Si(f2, l2, b2);
                tj();
                break a;
              }
              k2 = Error(p$3(426));
            }
          } else if (I$1 && h2.mode & 1) {
            var J2 = Ui(g2);
            if (null !== J2) {
              0 === (J2.flags & 65536) && (J2.flags |= 256);
              Vi(J2, g2, h2, f2, b2);
              Jg(Ji(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h2);
          4 !== T$1 && (T$1 = 2);
          null === sk ? sk = [f2] : sk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var x2 = Ni(f2, k2, b2);
                ph(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var F2 = Qi(f2, h2, b2);
                  ph(f2, F2);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c2);
      } catch (na) {
        b2 = na;
        Y$2 === c2 && null !== c2 && (Y$2 = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a2 = mk.current;
    mk.current = Rh;
    return null === a2 ? Rh : a2;
  }
  function tj() {
    if (0 === T$1 || 3 === T$1 || 2 === T$1)
      T$1 = 4;
    null === Q$1 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q$1, Z$3);
  }
  function Ik(a2, b2) {
    var c2 = K;
    K |= 2;
    var d2 = Jk();
    if (Q$1 !== a2 || Z$3 !== b2)
      uk = null, Kk(a2, b2);
    do
      try {
        Tk();
        break;
      } catch (e2) {
        Mk(a2, e2);
      }
    while (1);
    $g();
    K = c2;
    mk.current = d2;
    if (null !== Y$2)
      throw Error(p$3(261));
    Q$1 = null;
    Z$3 = 0;
    return T$1;
  }
  function Tk() {
    for (; null !== Y$2; )
      Uk(Y$2);
  }
  function Lk() {
    for (; null !== Y$2 && !cc(); )
      Uk(Y$2);
  }
  function Uk(a2) {
    var b2 = Vk(a2.alternate, a2, fj);
    a2.memoizedProps = a2.pendingProps;
    null === b2 ? Sk(a2) : Y$2 = b2;
    nk.current = null;
  }
  function Sk(a2) {
    var b2 = a2;
    do {
      var c2 = b2.alternate;
      a2 = b2.return;
      if (0 === (b2.flags & 32768)) {
        if (c2 = Ej(c2, b2, fj), null !== c2) {
          Y$2 = c2;
          return;
        }
      } else {
        c2 = Ij(c2, b2);
        if (null !== c2) {
          c2.flags &= 32767;
          Y$2 = c2;
          return;
        }
        if (null !== a2)
          a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T$1 = 6;
          Y$2 = null;
          return;
        }
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y$2 = b2;
        return;
      }
      Y$2 = b2 = a2;
    } while (null !== b2);
    0 === T$1 && (T$1 = 5);
  }
  function Pk(a2, b2, c2) {
    var d2 = C, e2 = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a2, b2, c2, d2);
    } finally {
      ok.transition = e2, C = d2;
    }
    return null;
  }
  function Wk(a2, b2, c2, d2) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6))
      throw Error(p$3(327));
    c2 = a2.finishedWork;
    var e2 = a2.finishedLanes;
    if (null === c2)
      return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c2 === a2.current)
      throw Error(p$3(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f2 = c2.lanes | c2.childLanes;
    Bc(a2, f2);
    a2 === Q$1 && (Y$2 = Q$1 = null, Z$3 = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g2 = C;
      C = 1;
      var h2 = K;
      K |= 4;
      nk.current = null;
      Oj(a2, c2);
      dk(c2, a2);
      Oe$1(Df);
      dd = !!Cf;
      Df = Cf = null;
      a2.current = c2;
      hk(c2);
      dc();
      K = h2;
      C = g2;
      ok.transition = f2;
    } else
      a2.current = c2;
    vk && (vk = false, wk = a2, xk = e2);
    f2 = a2.pendingLanes;
    0 === f2 && (Ri = null);
    mc(c2.stateNode);
    Dk(a2, B());
    if (null !== b2)
      for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
        e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
    if (Oi)
      throw Oi = false, a2 = Pi, Pi = null, a2;
    0 !== (xk & 1) && 0 !== a2.tag && Hk();
    f2 = a2.pendingLanes;
    0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a2 = Dc(xk), b2 = ok.transition, c2 = C;
      try {
        ok.transition = null;
        C = 16 > a2 ? 16 : a2;
        if (null === wk)
          var d2 = false;
        else {
          a2 = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6))
            throw Error(p$3(331));
          var e2 = K;
          K |= 4;
          for (V$1 = a2.current; null !== V$1; ) {
            var f2 = V$1, g2 = f2.child;
            if (0 !== (V$1.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V$1 = l2; null !== V$1; ) {
                    var m2 = V$1;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (null !== q2)
                      q2.return = m2, V$1 = q2;
                    else
                      for (; null !== V$1; ) {
                        m2 = V$1;
                        var r2 = m2.sibling, y2 = m2.return;
                        Sj(m2);
                        if (m2 === l2) {
                          V$1 = null;
                          break;
                        }
                        if (null !== r2) {
                          r2.return = y2;
                          V$1 = r2;
                          break;
                        }
                        V$1 = y2;
                      }
                  }
                }
                var n2 = f2.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J2 = t2.sibling;
                      t2.sibling = null;
                      t2 = J2;
                    } while (null !== t2);
                  }
                }
                V$1 = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
              g2.return = f2, V$1 = g2;
            else
              b:
                for (; null !== V$1; ) {
                  f2 = V$1;
                  if (0 !== (f2.flags & 2048))
                    switch (f2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(9, f2, f2.return);
                    }
                  var x2 = f2.sibling;
                  if (null !== x2) {
                    x2.return = f2.return;
                    V$1 = x2;
                    break b;
                  }
                  V$1 = f2.return;
                }
          }
          var w2 = a2.current;
          for (V$1 = w2; null !== V$1; ) {
            g2 = V$1;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
              u2.return = g2, V$1 = u2;
            else
              b:
                for (g2 = w2; null !== V$1; ) {
                  h2 = V$1;
                  if (0 !== (h2.flags & 2048))
                    try {
                      switch (h2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, h2);
                      }
                    } catch (na) {
                      W$1(h2, h2.return, na);
                    }
                  if (h2 === g2) {
                    V$1 = null;
                    break b;
                  }
                  var F2 = h2.sibling;
                  if (null !== F2) {
                    F2.return = h2.return;
                    V$1 = F2;
                    break b;
                  }
                  V$1 = h2.return;
                }
          }
          K = e2;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot)
            try {
              lc.onPostCommitFiberRoot(kc, a2);
            } catch (na) {
            }
          d2 = true;
        }
        return d2;
      } finally {
        C = c2, ok.transition = b2;
      }
    }
    return false;
  }
  function Xk(a2, b2, c2) {
    b2 = Ji(c2, b2);
    b2 = Ni(a2, b2, 1);
    a2 = nh(a2, b2, 1);
    b2 = R();
    null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
  }
  function W$1(a2, b2, c2) {
    if (3 === a2.tag)
      Xk(a2, a2, c2);
    else
      for (; null !== b2; ) {
        if (3 === b2.tag) {
          Xk(b2, a2, c2);
          break;
        } else if (1 === b2.tag) {
          var d2 = b2.stateNode;
          if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
            a2 = Ji(c2, a2);
            a2 = Qi(b2, a2, 1);
            b2 = nh(b2, a2, 1);
            a2 = R();
            null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
            break;
          }
        }
        b2 = b2.return;
      }
  }
  function Ti(a2, b2, c2) {
    var d2 = a2.pingCache;
    null !== d2 && d2.delete(b2);
    b2 = R();
    a2.pingedLanes |= a2.suspendedLanes & c2;
    Q$1 === a2 && (Z$3 & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z$3 & 130023424) === Z$3 && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
    Dk(a2, b2);
  }
  function Yk(a2, b2) {
    0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = R();
    a2 = ih(a2, b2);
    null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
  }
  function uj(a2) {
    var b2 = a2.memoizedState, c2 = 0;
    null !== b2 && (c2 = b2.retryLane);
    Yk(a2, c2);
  }
  function bk(a2, b2) {
    var c2 = 0;
    switch (a2.tag) {
      case 13:
        var d2 = a2.stateNode;
        var e2 = a2.memoizedState;
        null !== e2 && (c2 = e2.retryLane);
        break;
      case 19:
        d2 = a2.stateNode;
        break;
      default:
        throw Error(p$3(314));
    }
    null !== d2 && d2.delete(b2);
    Yk(a2, c2);
  }
  var Vk;
  Vk = function(a2, b2, c2) {
    if (null !== a2)
      if (a2.memoizedProps !== b2.pendingProps || Wf.current)
        dh = true;
      else {
        if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
          return dh = false, yj(a2, b2, c2);
        dh = 0 !== (a2.flags & 131072) ? true : false;
      }
    else
      dh = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        var d2 = b2.type;
        ij(a2, b2);
        a2 = b2.pendingProps;
        var e2 = Yf(b2, H$1.current);
        ch(b2, c2);
        e2 = Nh(null, b2, d2, a2, e2, c2);
        var f2 = Sh();
        b2.flags |= 1;
        "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
        return b2;
      case 16:
        d2 = b2.elementType;
        a: {
          ij(a2, b2);
          a2 = b2.pendingProps;
          e2 = d2._init;
          d2 = e2(d2._payload);
          b2.type = d2;
          e2 = b2.tag = Zk(d2);
          a2 = Ci(d2, a2);
          switch (e2) {
            case 0:
              b2 = cj(null, b2, d2, a2, c2);
              break a;
            case 1:
              b2 = hj(null, b2, d2, a2, c2);
              break a;
            case 11:
              b2 = Yi(null, b2, d2, a2, c2);
              break a;
            case 14:
              b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
              break a;
          }
          throw Error(p$3(
            306,
            d2,
            ""
          ));
        }
        return b2;
      case 0:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a2, b2, d2, e2, c2);
      case 1:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a2, b2, d2, e2, c2);
      case 3:
        a: {
          kj(b2);
          if (null === a2)
            throw Error(p$3(387));
          d2 = b2.pendingProps;
          f2 = b2.memoizedState;
          e2 = f2.element;
          lh(a2, b2);
          qh(b2, d2, null, c2);
          var g2 = b2.memoizedState;
          d2 = g2.element;
          if (f2.isDehydrated)
            if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
              e2 = Ji(Error(p$3(423)), b2);
              b2 = lj(a2, b2, d2, c2, e2);
              break a;
            } else if (d2 !== e2) {
              e2 = Ji(Error(p$3(424)), b2);
              b2 = lj(a2, b2, d2, c2, e2);
              break a;
            } else
              for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; )
                c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d2 === e2) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
            Xi(a2, b2, d2, c2);
          }
          b2 = b2.child;
        }
        return b2;
      case 5:
        return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
      case 6:
        return null === a2 && Eg(b2), null;
      case 13:
        return oj(a2, b2, c2);
      case 4:
        return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
      case 11:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a2, b2, d2, e2, c2);
      case 7:
        return Xi(a2, b2, b2.pendingProps, c2), b2.child;
      case 8:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 12:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 10:
        a: {
          d2 = b2.type._context;
          e2 = b2.pendingProps;
          f2 = b2.memoizedProps;
          g2 = e2.value;
          G$1(Wg, d2._currentValue);
          d2._currentValue = g2;
          if (null !== f2)
            if (He$1(f2.value, g2)) {
              if (f2.children === e2.children && !Wf.current) {
                b2 = Zi(a2, b2, c2);
                break a;
              }
            } else
              for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                var h2 = f2.dependencies;
                if (null !== h2) {
                  g2 = f2.child;
                  for (var k2 = h2.firstContext; null !== k2; ) {
                    if (k2.context === d2) {
                      if (1 === f2.tag) {
                        k2 = mh(-1, c2 & -c2);
                        k2.tag = 2;
                        var l2 = f2.updateQueue;
                        if (null !== l2) {
                          l2 = l2.shared;
                          var m2 = l2.pending;
                          null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                          l2.pending = k2;
                        }
                      }
                      f2.lanes |= c2;
                      k2 = f2.alternate;
                      null !== k2 && (k2.lanes |= c2);
                      bh(
                        f2.return,
                        c2,
                        b2
                      );
                      h2.lanes |= c2;
                      break;
                    }
                    k2 = k2.next;
                  }
                } else if (10 === f2.tag)
                  g2 = f2.type === b2.type ? null : f2.child;
                else if (18 === f2.tag) {
                  g2 = f2.return;
                  if (null === g2)
                    throw Error(p$3(341));
                  g2.lanes |= c2;
                  h2 = g2.alternate;
                  null !== h2 && (h2.lanes |= c2);
                  bh(g2, c2, b2);
                  g2 = f2.sibling;
                } else
                  g2 = f2.child;
                if (null !== g2)
                  g2.return = f2;
                else
                  for (g2 = f2; null !== g2; ) {
                    if (g2 === b2) {
                      g2 = null;
                      break;
                    }
                    f2 = g2.sibling;
                    if (null !== f2) {
                      f2.return = g2.return;
                      g2 = f2;
                      break;
                    }
                    g2 = g2.return;
                  }
                f2 = g2;
              }
          Xi(a2, b2, e2.children, c2);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
      case 14:
        return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a2, b2, d2, e2, c2);
      case 15:
        return bj(a2, b2, b2.type, b2.pendingProps, c2);
      case 17:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a2, c2);
      case 19:
        return xj(a2, b2, c2);
      case 22:
        return dj(a2, b2, c2);
    }
    throw Error(p$3(156, b2.tag));
  };
  function Fk(a2, b2) {
    return ac(a2, b2);
  }
  function $k(a2, b2, c2, d2) {
    this.tag = a2;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a2, b2, c2, d2) {
    return new $k(a2, b2, c2, d2);
  }
  function aj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function Zk(a2) {
    if ("function" === typeof a2)
      return aj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da)
        return 11;
      if (a2 === Ga)
        return 14;
    }
    return 2;
  }
  function Pg(a2, b2) {
    var c2 = a2.alternate;
    null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a2.flags & 14680064;
    c2.childLanes = a2.childLanes;
    c2.lanes = a2.lanes;
    c2.child = a2.child;
    c2.memoizedProps = a2.memoizedProps;
    c2.memoizedState = a2.memoizedState;
    c2.updateQueue = a2.updateQueue;
    b2 = a2.dependencies;
    c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c2.sibling = a2.sibling;
    c2.index = a2.index;
    c2.ref = a2.ref;
    return c2;
  }
  function Rg(a2, b2, c2, d2, e2, f2) {
    var g2 = 2;
    d2 = a2;
    if ("function" === typeof a2)
      aj(a2) && (g2 = 1);
    else if ("string" === typeof a2)
      g2 = 5;
    else
      a:
        switch (a2) {
          case ya:
            return Tg(c2.children, e2, f2, b2);
          case za:
            g2 = 8;
            e2 |= 8;
            break;
          case Aa:
            return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
          case Ea:
            return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
          case Fa:
            return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
          case Ia:
            return pj(c2, e2, f2, b2);
          default:
            if ("object" === typeof a2 && null !== a2)
              switch (a2.$$typeof) {
                case Ba:
                  g2 = 10;
                  break a;
                case Ca:
                  g2 = 9;
                  break a;
                case Da:
                  g2 = 11;
                  break a;
                case Ga:
                  g2 = 14;
                  break a;
                case Ha:
                  g2 = 16;
                  d2 = null;
                  break a;
              }
            throw Error(p$3(130, null == a2 ? a2 : typeof a2, ""));
        }
    b2 = Bg(g2, c2, b2, e2);
    b2.elementType = a2;
    b2.type = d2;
    b2.lanes = f2;
    return b2;
  }
  function Tg(a2, b2, c2, d2) {
    a2 = Bg(7, a2, d2, b2);
    a2.lanes = c2;
    return a2;
  }
  function pj(a2, b2, c2, d2) {
    a2 = Bg(22, a2, d2, b2);
    a2.elementType = Ia;
    a2.lanes = c2;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function Qg(a2, b2, c2) {
    a2 = Bg(6, a2, null, b2);
    a2.lanes = c2;
    return a2;
  }
  function Sg(a2, b2, c2) {
    b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
    b2.lanes = c2;
    b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b2;
  }
  function al(a2, b2, c2, d2, e2) {
    this.tag = b2;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e2;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    a2 = new al(a2, b2, c2, h2, k2);
    1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
    f2 = Bg(3, null, null, b2);
    a2.current = f2;
    f2.stateNode = a2;
    f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f2);
    return a2;
  }
  function cl(a2, b2, c2) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
  }
  function dl(a2) {
    if (!a2)
      return Vf;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag)
        throw Error(p$3(170));
      var b2 = a2;
      do {
        switch (b2.tag) {
          case 3:
            b2 = b2.stateNode.context;
            break a;
          case 1:
            if (Zf(b2.type)) {
              b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b2 = b2.return;
      } while (null !== b2);
      throw Error(p$3(171));
    }
    if (1 === a2.tag) {
      var c2 = a2.type;
      if (Zf(c2))
        return bg(a2, c2, b2);
    }
    return b2;
  }
  function el(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    a2 = bl(c2, d2, true, a2, e2, f2, g2, h2, k2);
    a2.context = dl(null);
    c2 = a2.current;
    d2 = R();
    e2 = yi(c2);
    f2 = mh(d2, e2);
    f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
    nh(c2, f2, e2);
    a2.current.lanes = e2;
    Ac(a2, e2, d2);
    Dk(a2, d2);
    return a2;
  }
  function fl(a2, b2, c2, d2) {
    var e2 = b2.current, f2 = R(), g2 = yi(e2);
    c2 = dl(c2);
    null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
    b2 = mh(f2, g2);
    b2.payload = { element: a2 };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b2.callback = d2);
    a2 = nh(e2, b2, g2);
    null !== a2 && (gi(a2, e2, g2, f2), oh(a2, e2, g2));
    return g2;
  }
  function gl(a2) {
    a2 = a2.current;
    if (!a2.child)
      return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function hl(a2, b2) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c2 = a2.retryLane;
      a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
    }
  }
  function il(a2, b2) {
    hl(a2, b2);
    (a2 = a2.alternate) && hl(a2, b2);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ll(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.render = ll.prototype.render = function(a2) {
    var b2 = this._internalRoot;
    if (null === b2)
      throw Error(p$3(409));
    fl(a2, b2, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b2 = a2.containerInfo;
      Rk(function() {
        fl(null, a2, null, null);
      });
      b2[uf] = null;
    }
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b2 = Hc();
      a2 = { blockedOn: null, target: a2, priority: b2 };
      for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
        ;
      Qc.splice(c2, 0, a2);
      0 === c2 && Vc(a2);
    }
  };
  function nl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function pl() {
  }
  function ql(a2, b2, c2, d2, e2) {
    if (e2) {
      if ("function" === typeof d2) {
        var f2 = d2;
        d2 = function() {
          var a3 = gl(g2);
          f2.call(a3);
        };
      }
      var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
      a2._reactRootContainer = g2;
      a2[uf] = g2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk();
      return g2;
    }
    for (; e2 = a2.lastChild; )
      a2.removeChild(e2);
    if ("function" === typeof d2) {
      var h2 = d2;
      d2 = function() {
        var a3 = gl(k2);
        h2.call(a3);
      };
    }
    var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
    a2._reactRootContainer = k2;
    a2[uf] = k2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk(function() {
      fl(b2, k2, c2, d2);
    });
    return k2;
  }
  function rl(a2, b2, c2, d2, e2) {
    var f2 = c2._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e2) {
        var h2 = e2;
        e2 = function() {
          var a3 = gl(g2);
          h2.call(a3);
        };
      }
      fl(b2, g2, a2, e2);
    } else
      g2 = ql(c2, b2, a2, e2, d2);
    return gl(g2);
  }
  Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b2 = a2.stateNode;
        if (b2.current.memoizedState.isDehydrated) {
          var c2 = tc(b2.pendingLanes);
          0 !== c2 && (Cc$1(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b3 = ih(a2, 1);
          if (null !== b3) {
            var c3 = R();
            gi(b3, a2, 1, c3);
          }
        }), il(a2, 1);
    }
  };
  Fc = function(a2) {
    if (13 === a2.tag) {
      var b2 = ih(a2, 134217728);
      if (null !== b2) {
        var c2 = R();
        gi(b2, a2, 134217728, c2);
      }
      il(a2, 134217728);
    }
  };
  Gc = function(a2) {
    if (13 === a2.tag) {
      var b2 = yi(a2), c2 = ih(a2, b2);
      if (null !== c2) {
        var d2 = R();
        gi(c2, a2, b2, d2);
      }
      il(a2, b2);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a2, b2) {
    var c2 = C;
    try {
      return C = a2, b2();
    } finally {
      C = c2;
    }
  };
  yb = function(a2, b2, c2) {
    switch (b2) {
      case "input":
        bb(a2, c2);
        b2 = c2.name;
        if ("radio" === c2.type && null != b2) {
          for (c2 = a2; c2.parentNode; )
            c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c2.length; b2++) {
            var d2 = c2[b2];
            if (d2 !== a2 && d2.form === a2.form) {
              var e2 = Db(d2);
              if (!e2)
                throw Error(p$3(90));
              Wa(d2);
              bb(d2, e2);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c2);
        break;
      case "select":
        b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber)
      try {
        kc = vl.inject(ul), lc = vl;
      } catch (a2) {
      }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a2, b2) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b2))
      throw Error(p$3(200));
    return cl(a2, b2, null, c2);
  };
  reactDom_production_min.createRoot = function(a2, b2) {
    if (!nl(a2))
      throw Error(p$3(299));
    var c2 = false, d2 = "", e2 = kl;
    null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
    b2 = bl(a2, 1, false, null, null, c2, false, d2, e2);
    a2[uf] = b2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    return new ll(b2);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2)
      return null;
    if (1 === a2.nodeType)
      return a2;
    var b2 = a2._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a2.render)
        throw Error(p$3(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p$3(268, a2));
    }
    a2 = Zb(b2);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Rk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b2, c2) {
    if (!ol(b2))
      throw Error(p$3(200));
    return rl(null, a2, b2, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
    if (!nl(a2))
      throw Error(p$3(405));
    var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
    b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
    a2[uf] = b2.current;
    sf(a2);
    if (d2)
      for (a2 = 0; a2 < d2.length; a2++)
        c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
          c2,
          e2
        );
    return new ml(b2);
  };
  reactDom_production_min.render = function(a2, b2, c2) {
    if (!ol(b2))
      throw Error(p$3(200));
    return rl(null, a2, b2, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!ol(a2))
      throw Error(p$3(40));
    return a2._reactRootContainer ? (Rk(function() {
      rl(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
    if (!ol(c2))
      throw Error(p$3(200));
    if (null == a2 || void 0 === a2._reactInternals)
      throw Error(p$3(38));
    return rl(a2, b2, c2, false, d2);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = reactDom_production_min;
  }
  var reactDomExports = reactDom.exports;
  const index$2 = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
  const ReactDOM = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: index$2
  }, [reactDomExports]);
  var m$2 = reactDomExports;
  {
    client.createRoot = m$2.createRoot;
    client.hydrateRoot = m$2.hydrateRoot;
  }
  /**
   * @remix-run/router v1.20.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  var Action;
  (function(Action2) {
    Action2["Pop"] = "POP";
    Action2["Push"] = "PUSH";
    Action2["Replace"] = "REPLACE";
  })(Action || (Action = {}));
  const PopStateEventType = "popstate";
  function createBrowserHistory(options) {
    if (options === void 0) {
      options = {};
    }
    function createBrowserLocation(window2, globalHistory) {
      let {
        pathname,
        search,
        hash
      } = window2.location;
      return createLocation(
        "",
        {
          pathname,
          search,
          hash
        },
        // state defaults to `null` because `window.history.state` does
        globalHistory.state && globalHistory.state.usr || null,
        globalHistory.state && globalHistory.state.key || "default"
      );
    }
    function createBrowserHref(window2, to) {
      return typeof to === "string" ? to : createPath(to);
    }
    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
  }
  function invariant(value2, message) {
    if (value2 === false || value2 === null || typeof value2 === "undefined") {
      throw new Error(message);
    }
  }
  function warning(cond, message) {
    if (!cond) {
      if (typeof console !== "undefined")
        console.warn(message);
      try {
        throw new Error(message);
      } catch (e2) {
      }
    }
  }
  function createKey() {
    return Math.random().toString(36).substr(2, 8);
  }
  function getHistoryState(location2, index2) {
    return {
      usr: location2.state,
      key: location2.key,
      idx: index2
    };
  }
  function createLocation(current, to, state, key) {
    if (state === void 0) {
      state = null;
    }
    let location2 = _extends$2({
      pathname: typeof current === "string" ? current : current.pathname,
      search: "",
      hash: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state,
      // TODO: This could be cleaned up.  push/replace should probably just take
      // full Locations now and avoid the need to run through this flow at all
      // But that's a pretty big refactor to the current test suite so going to
      // keep as is for the time being and just let any incoming keys take precedence
      key: to && to.key || key || createKey()
    });
    return location2;
  }
  function createPath(_ref) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = _ref;
    if (search && search !== "?")
      pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash && hash !== "#")
      pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
    return pathname;
  }
  function parsePath(path) {
    let parsedPath = {};
    if (path) {
      let hashIndex = path.indexOf("#");
      if (hashIndex >= 0) {
        parsedPath.hash = path.substr(hashIndex);
        path = path.substr(0, hashIndex);
      }
      let searchIndex = path.indexOf("?");
      if (searchIndex >= 0) {
        parsedPath.search = path.substr(searchIndex);
        path = path.substr(0, searchIndex);
      }
      if (path) {
        parsedPath.pathname = path;
      }
    }
    return parsedPath;
  }
  function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
    if (options === void 0) {
      options = {};
    }
    let {
      window: window2 = document.defaultView,
      v5Compat = false
    } = options;
    let globalHistory = window2.history;
    let action = Action.Pop;
    let listener = null;
    let index2 = getIndex();
    if (index2 == null) {
      index2 = 0;
      globalHistory.replaceState(_extends$2({}, globalHistory.state, {
        idx: index2
      }), "");
    }
    function getIndex() {
      let state = globalHistory.state || {
        idx: null
      };
      return state.idx;
    }
    function handlePop() {
      action = Action.Pop;
      let nextIndex = getIndex();
      let delta = nextIndex == null ? null : nextIndex - index2;
      index2 = nextIndex;
      if (listener) {
        listener({
          action,
          location: history2.location,
          delta
        });
      }
    }
    function push(to, state) {
      action = Action.Push;
      let location2 = createLocation(history2.location, to, state);
      if (validateLocation)
        validateLocation(location2, to);
      index2 = getIndex() + 1;
      let historyState = getHistoryState(location2, index2);
      let url2 = history2.createHref(location2);
      try {
        globalHistory.pushState(historyState, "", url2);
      } catch (error2) {
        if (error2 instanceof DOMException && error2.name === "DataCloneError") {
          throw error2;
        }
        window2.location.assign(url2);
      }
      if (v5Compat && listener) {
        listener({
          action,
          location: history2.location,
          delta: 1
        });
      }
    }
    function replace2(to, state) {
      action = Action.Replace;
      let location2 = createLocation(history2.location, to, state);
      if (validateLocation)
        validateLocation(location2, to);
      index2 = getIndex();
      let historyState = getHistoryState(location2, index2);
      let url2 = history2.createHref(location2);
      globalHistory.replaceState(historyState, "", url2);
      if (v5Compat && listener) {
        listener({
          action,
          location: history2.location,
          delta: 0
        });
      }
    }
    function createURL(to) {
      let base2 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
      let href = typeof to === "string" ? to : createPath(to);
      href = href.replace(/ $/, "%20");
      invariant(base2, "No window.location.(origin|href) available to create URL for href: " + href);
      return new URL(href, base2);
    }
    let history2 = {
      get action() {
        return action;
      },
      get location() {
        return getLocation(window2, globalHistory);
      },
      listen(fn) {
        if (listener) {
          throw new Error("A history only accepts one active listener");
        }
        window2.addEventListener(PopStateEventType, handlePop);
        listener = fn;
        return () => {
          window2.removeEventListener(PopStateEventType, handlePop);
          listener = null;
        };
      },
      createHref(to) {
        return createHref(window2, to);
      },
      createURL,
      encodeLocation(to) {
        let url2 = createURL(to);
        return {
          pathname: url2.pathname,
          search: url2.search,
          hash: url2.hash
        };
      },
      push,
      replace: replace2,
      go(n2) {
        return globalHistory.go(n2);
      }
    };
    return history2;
  }
  var ResultType;
  (function(ResultType2) {
    ResultType2["data"] = "data";
    ResultType2["deferred"] = "deferred";
    ResultType2["redirect"] = "redirect";
    ResultType2["error"] = "error";
  })(ResultType || (ResultType = {}));
  const immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
  function isIndexRoute(route) {
    return route.index === true;
  }
  function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
    if (parentPath === void 0) {
      parentPath = [];
    }
    if (manifest === void 0) {
      manifest = {};
    }
    return routes.map((route, index2) => {
      let treePath = [...parentPath, String(index2)];
      let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
      invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
      invariant(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
      if (isIndexRoute(route)) {
        let indexRoute = _extends$2({}, route, mapRouteProperties2(route), {
          id: id2
        });
        manifest[id2] = indexRoute;
        return indexRoute;
      } else {
        let pathOrLayoutRoute = _extends$2({}, route, mapRouteProperties2(route), {
          id: id2,
          children: void 0
        });
        manifest[id2] = pathOrLayoutRoute;
        if (route.children) {
          pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
        }
        return pathOrLayoutRoute;
      }
    });
  }
  function matchRoutes(routes, locationArg, basename) {
    if (basename === void 0) {
      basename = "/";
    }
    return matchRoutesImpl(routes, locationArg, basename, false);
  }
  function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
    let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    let pathname = stripBasename(location2.pathname || "/", basename);
    if (pathname == null) {
      return null;
    }
    let branches = flattenRoutes(routes);
    rankRouteBranches(branches);
    let matches = null;
    for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
      let decoded = decodePath(pathname);
      matches = matchRouteBranch(branches[i2], decoded, allowPartial);
    }
    return matches;
  }
  function convertRouteMatchToUiMatch(match, loaderData) {
    let {
      route,
      pathname,
      params
    } = match;
    return {
      id: route.id,
      pathname,
      params,
      data: loaderData[route.id],
      handle: route.handle
    };
  }
  function flattenRoutes(routes, branches, parentsMeta, parentPath) {
    if (branches === void 0) {
      branches = [];
    }
    if (parentsMeta === void 0) {
      parentsMeta = [];
    }
    if (parentPath === void 0) {
      parentPath = "";
    }
    let flattenRoute = (route, index2, relativePath) => {
      let meta = {
        relativePath: relativePath === void 0 ? route.path || "" : relativePath,
        caseSensitive: route.caseSensitive === true,
        childrenIndex: index2,
        route
      };
      if (meta.relativePath.startsWith("/")) {
        invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
        meta.relativePath = meta.relativePath.slice(parentPath.length);
      }
      let path = joinPaths([parentPath, meta.relativePath]);
      let routesMeta = parentsMeta.concat(meta);
      if (route.children && route.children.length > 0) {
        invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== true,
          "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
        );
        flattenRoutes(route.children, branches, routesMeta, path);
      }
      if (route.path == null && !route.index) {
        return;
      }
      branches.push({
        path,
        score: computeScore(path, route.index),
        routesMeta
      });
    };
    routes.forEach((route, index2) => {
      var _route$path;
      if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
        flattenRoute(route, index2);
      } else {
        for (let exploded of explodeOptionalSegments(route.path)) {
          flattenRoute(route, index2, exploded);
        }
      }
    });
    return branches;
  }
  function explodeOptionalSegments(path) {
    let segments = path.split("/");
    if (segments.length === 0)
      return [];
    let [first, ...rest] = segments;
    let isOptional = first.endsWith("?");
    let required = first.replace(/\?$/, "");
    if (rest.length === 0) {
      return isOptional ? [required, ""] : [required];
    }
    let restExploded = explodeOptionalSegments(rest.join("/"));
    let result = [];
    result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
    if (isOptional) {
      result.push(...restExploded);
    }
    return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
  }
  function rankRouteBranches(branches) {
    branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
  }
  const paramRe = /^:[\w-]+$/;
  const dynamicSegmentValue = 3;
  const indexRouteValue = 2;
  const emptySegmentValue = 1;
  const staticSegmentValue = 10;
  const splatPenalty = -2;
  const isSplat = (s2) => s2 === "*";
  function computeScore(path, index2) {
    let segments = path.split("/");
    let initialScore = segments.length;
    if (segments.some(isSplat)) {
      initialScore += splatPenalty;
    }
    if (index2) {
      initialScore += indexRouteValue;
    }
    return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
  }
  function compareIndexes(a2, b2) {
    let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
    return siblings ? (
      // If two routes are siblings, we should try to match the earlier sibling
      // first. This allows people to have fine-grained control over the matching
      // behavior by simply putting routes with identical paths in the order they
      // want them tried.
      a2[a2.length - 1] - b2[b2.length - 1]
    ) : (
      // Otherwise, it doesn't really make sense to rank non-siblings by index,
      // so they sort equally.
      0
    );
  }
  function matchRouteBranch(branch, pathname, allowPartial) {
    if (allowPartial === void 0) {
      allowPartial = false;
    }
    let {
      routesMeta
    } = branch;
    let matchedParams = {};
    let matchedPathname = "/";
    let matches = [];
    for (let i2 = 0; i2 < routesMeta.length; ++i2) {
      let meta = routesMeta[i2];
      let end = i2 === routesMeta.length - 1;
      let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
      let match = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end
      }, remainingPathname);
      let route = meta.route;
      if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
        match = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        }, remainingPathname);
      }
      if (!match) {
        return null;
      }
      Object.assign(matchedParams, match.params);
      matches.push({
        // TODO: Can this as be avoided?
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match.pathname]),
        pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
        route
      });
      if (match.pathnameBase !== "/") {
        matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
      }
    }
    return matches;
  }
  function matchPath(pattern2, pathname) {
    if (typeof pattern2 === "string") {
      pattern2 = {
        path: pattern2,
        caseSensitive: false,
        end: true
      };
    }
    let [matcher, compiledParams] = compilePath(pattern2.path, pattern2.caseSensitive, pattern2.end);
    let match = pathname.match(matcher);
    if (!match)
      return null;
    let matchedPathname = match[0];
    let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
    let captureGroups = match.slice(1);
    let params = compiledParams.reduce((memo, _ref, index2) => {
      let {
        paramName,
        isOptional
      } = _ref;
      if (paramName === "*") {
        let splatValue = captureGroups[index2] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value2 = captureGroups[index2];
      if (isOptional && !value2) {
        memo[paramName] = void 0;
      } else {
        memo[paramName] = (value2 || "").replace(/%2F/g, "/");
      }
      return memo;
    }, {});
    return {
      params,
      pathname: matchedPathname,
      pathnameBase,
      pattern: pattern2
    };
  }
  function compilePath(path, caseSensitive, end) {
    if (caseSensitive === void 0) {
      caseSensitive = false;
    }
    if (end === void 0) {
      end = true;
    }
    warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
    let params = [];
    let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
      params.push({
        paramName,
        isOptional: isOptional != null
      });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    });
    if (path.endsWith("*")) {
      params.push({
        paramName: "*"
      });
      regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
    } else if (end) {
      regexpSource += "\\/*$";
    } else if (path !== "" && path !== "/") {
      regexpSource += "(?:(?=\\/|$))";
    } else
      ;
    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
    return [matcher, params];
  }
  function decodePath(value2) {
    try {
      return value2.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
    } catch (error2) {
      warning(false, 'The URL path "' + value2 + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error2 + ")."));
      return value2;
    }
  }
  function stripBasename(pathname, basename) {
    if (basename === "/")
      return pathname;
    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
      return null;
    }
    let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
    let nextChar = pathname.charAt(startIndex);
    if (nextChar && nextChar !== "/") {
      return null;
    }
    return pathname.slice(startIndex) || "/";
  }
  function resolvePath(to, fromPathname) {
    if (fromPathname === void 0) {
      fromPathname = "/";
    }
    let {
      pathname: toPathname,
      search = "",
      hash = ""
    } = typeof to === "string" ? parsePath(to) : to;
    let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    return {
      pathname,
      search: normalizeSearch(search),
      hash: normalizeHash(hash)
    };
  }
  function resolvePathname(relativePath, fromPathname) {
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    let relativeSegments = relativePath.split("/");
    relativeSegments.forEach((segment) => {
      if (segment === "..") {
        if (segments.length > 1)
          segments.pop();
      } else if (segment !== ".") {
        segments.push(segment);
      }
    });
    return segments.length > 1 ? segments.join("/") : "/";
  }
  function getInvalidPathError(char, field, dest, path) {
    return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
  }
  function getPathContributingMatches(matches) {
    return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
  }
  function getResolveToMatches(matches, v7_relativeSplatPath) {
    let pathMatches = getPathContributingMatches(matches);
    if (v7_relativeSplatPath) {
      return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
    }
    return pathMatches.map((match) => match.pathnameBase);
  }
  function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
    if (isPathRelative === void 0) {
      isPathRelative = false;
    }
    let to;
    if (typeof toArg === "string") {
      to = parsePath(toArg);
    } else {
      to = _extends$2({}, toArg);
      invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
      invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
      invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
    }
    let isEmptyPath = toArg === "" || to.pathname === "";
    let toPathname = isEmptyPath ? "/" : to.pathname;
    let from;
    if (toPathname == null) {
      from = locationPathname;
    } else {
      let routePathnameIndex = routePathnames.length - 1;
      if (!isPathRelative && toPathname.startsWith("..")) {
        let toSegments = toPathname.split("/");
        while (toSegments[0] === "..") {
          toSegments.shift();
          routePathnameIndex -= 1;
        }
        to.pathname = toSegments.join("/");
      }
      from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
    }
    let path = resolvePath(to, from);
    let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
    if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
      path.pathname += "/";
    }
    return path;
  }
  const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
  const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
  const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
  const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
  class ErrorResponseImpl {
    constructor(status, statusText, data, internal) {
      if (internal === void 0) {
        internal = false;
      }
      this.status = status;
      this.statusText = statusText || "";
      this.internal = internal;
      if (data instanceof Error) {
        this.data = data.toString();
        this.error = data;
      } else {
        this.data = data;
      }
    }
  }
  function isRouteErrorResponse(error2) {
    return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
  }
  const validMutationMethodsArr = ["post", "put", "patch", "delete"];
  const validMutationMethods = new Set(validMutationMethodsArr);
  const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
  const validRequestMethods = new Set(validRequestMethodsArr);
  const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
  const redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
  const IDLE_NAVIGATION = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
  const IDLE_FETCHER = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
  const IDLE_BLOCKER = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
  };
  const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
  const defaultMapRouteProperties = (route) => ({
    hasErrorBoundary: Boolean(route.hasErrorBoundary)
  });
  const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
  function createRouter(init2) {
    const routerWindow = init2.window ? init2.window : typeof window !== "undefined" ? window : void 0;
    const isBrowser = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
    const isServer = !isBrowser;
    invariant(init2.routes.length > 0, "You must provide a non-empty routes array to createRouter");
    let mapRouteProperties2;
    if (init2.mapRouteProperties) {
      mapRouteProperties2 = init2.mapRouteProperties;
    } else if (init2.detectErrorBoundary) {
      let detectErrorBoundary = init2.detectErrorBoundary;
      mapRouteProperties2 = (route) => ({
        hasErrorBoundary: detectErrorBoundary(route)
      });
    } else {
      mapRouteProperties2 = defaultMapRouteProperties;
    }
    let manifest = {};
    let dataRoutes = convertRoutesToDataRoutes(init2.routes, mapRouteProperties2, void 0, manifest);
    let inFlightDataRoutes;
    let basename = init2.basename || "/";
    let dataStrategyImpl = init2.dataStrategy || defaultDataStrategy;
    let patchRoutesOnNavigationImpl = init2.patchRoutesOnNavigation;
    let future = _extends$2({
      v7_fetcherPersist: false,
      v7_normalizeFormMethod: false,
      v7_partialHydration: false,
      v7_prependBasename: false,
      v7_relativeSplatPath: false,
      v7_skipActionErrorRevalidation: false
    }, init2.future);
    let unlistenHistory = null;
    let subscribers = /* @__PURE__ */ new Set();
    let savedScrollPositions = null;
    let getScrollRestorationKey = null;
    let getScrollPosition = null;
    let initialScrollRestored = init2.hydrationData != null;
    let initialMatches = matchRoutes(dataRoutes, init2.history.location, basename);
    let initialErrors = null;
    if (initialMatches == null && !patchRoutesOnNavigationImpl) {
      let error2 = getInternalRouterError(404, {
        pathname: init2.history.location.pathname
      });
      let {
        matches,
        route
      } = getShortCircuitMatches(dataRoutes);
      initialMatches = matches;
      initialErrors = {
        [route.id]: error2
      };
    }
    if (initialMatches && !init2.hydrationData) {
      let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init2.history.location.pathname);
      if (fogOfWar.active) {
        initialMatches = null;
      }
    }
    let initialized;
    if (!initialMatches) {
      initialized = false;
      initialMatches = [];
      if (future.v7_partialHydration) {
        let fogOfWar = checkFogOfWar(null, dataRoutes, init2.history.location.pathname);
        if (fogOfWar.active && fogOfWar.matches) {
          initialMatches = fogOfWar.matches;
        }
      }
    } else if (initialMatches.some((m2) => m2.route.lazy)) {
      initialized = false;
    } else if (!initialMatches.some((m2) => m2.route.loader)) {
      initialized = true;
    } else if (future.v7_partialHydration) {
      let loaderData = init2.hydrationData ? init2.hydrationData.loaderData : null;
      let errors2 = init2.hydrationData ? init2.hydrationData.errors : null;
      if (errors2) {
        let idx = initialMatches.findIndex((m2) => errors2[m2.route.id] !== void 0);
        initialized = initialMatches.slice(0, idx + 1).every((m2) => !shouldLoadRouteOnHydration(m2.route, loaderData, errors2));
      } else {
        initialized = initialMatches.every((m2) => !shouldLoadRouteOnHydration(m2.route, loaderData, errors2));
      }
    } else {
      initialized = init2.hydrationData != null;
    }
    let router2;
    let state = {
      historyAction: init2.history.action,
      location: init2.history.location,
      matches: initialMatches,
      initialized,
      navigation: IDLE_NAVIGATION,
      // Don't restore on initial updateState() if we were SSR'd
      restoreScrollPosition: init2.hydrationData != null ? false : null,
      preventScrollReset: false,
      revalidation: "idle",
      loaderData: init2.hydrationData && init2.hydrationData.loaderData || {},
      actionData: init2.hydrationData && init2.hydrationData.actionData || null,
      errors: init2.hydrationData && init2.hydrationData.errors || initialErrors,
      fetchers: /* @__PURE__ */ new Map(),
      blockers: /* @__PURE__ */ new Map()
    };
    let pendingAction = Action.Pop;
    let pendingPreventScrollReset = false;
    let pendingNavigationController;
    let pendingViewTransitionEnabled = false;
    let appliedViewTransitions = /* @__PURE__ */ new Map();
    let removePageHideEventListener = null;
    let isUninterruptedRevalidation = false;
    let isRevalidationRequired = false;
    let cancelledDeferredRoutes = [];
    let cancelledFetcherLoads = /* @__PURE__ */ new Set();
    let fetchControllers = /* @__PURE__ */ new Map();
    let incrementingLoadId = 0;
    let pendingNavigationLoadId = -1;
    let fetchReloadIds = /* @__PURE__ */ new Map();
    let fetchRedirectIds = /* @__PURE__ */ new Set();
    let fetchLoadMatches = /* @__PURE__ */ new Map();
    let activeFetchers = /* @__PURE__ */ new Map();
    let deletedFetchers = /* @__PURE__ */ new Set();
    let activeDeferreds = /* @__PURE__ */ new Map();
    let blockerFunctions = /* @__PURE__ */ new Map();
    let unblockBlockerHistoryUpdate = void 0;
    function initialize() {
      unlistenHistory = init2.history.listen((_ref) => {
        let {
          action: historyAction,
          location: location2,
          delta
        } = _ref;
        if (unblockBlockerHistoryUpdate) {
          unblockBlockerHistoryUpdate();
          unblockBlockerHistoryUpdate = void 0;
          return;
        }
        warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
        let blockerKey = shouldBlockNavigation({
          currentLocation: state.location,
          nextLocation: location2,
          historyAction
        });
        if (blockerKey && delta != null) {
          let nextHistoryUpdatePromise = new Promise((resolve) => {
            unblockBlockerHistoryUpdate = resolve;
          });
          init2.history.go(delta * -1);
          updateBlocker(blockerKey, {
            state: "blocked",
            location: location2,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: location2
              });
              nextHistoryUpdatePromise.then(() => init2.history.go(delta));
            },
            reset() {
              let blockers = new Map(state.blockers);
              blockers.set(blockerKey, IDLE_BLOCKER);
              updateState2({
                blockers
              });
            }
          });
          return;
        }
        return startNavigation(historyAction, location2);
      });
      if (isBrowser) {
        restoreAppliedTransitions(routerWindow, appliedViewTransitions);
        let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
        routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
        removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
      }
      if (!state.initialized) {
        startNavigation(Action.Pop, state.location, {
          initialHydration: true
        });
      }
      return router2;
    }
    function dispose() {
      if (unlistenHistory) {
        unlistenHistory();
      }
      if (removePageHideEventListener) {
        removePageHideEventListener();
      }
      subscribers.clear();
      pendingNavigationController && pendingNavigationController.abort();
      state.fetchers.forEach((_2, key) => deleteFetcher(key));
      state.blockers.forEach((_2, key) => deleteBlocker(key));
    }
    function subscribe(fn) {
      subscribers.add(fn);
      return () => subscribers.delete(fn);
    }
    function updateState2(newState, opts) {
      if (opts === void 0) {
        opts = {};
      }
      state = _extends$2({}, state, newState);
      let completedFetchers = [];
      let deletedFetchersKeys = [];
      if (future.v7_fetcherPersist) {
        state.fetchers.forEach((fetcher, key) => {
          if (fetcher.state === "idle") {
            if (deletedFetchers.has(key)) {
              deletedFetchersKeys.push(key);
            } else {
              completedFetchers.push(key);
            }
          }
        });
      }
      [...subscribers].forEach((subscriber) => subscriber(state, {
        deletedFetchers: deletedFetchersKeys,
        viewTransitionOpts: opts.viewTransitionOpts,
        flushSync: opts.flushSync === true
      }));
      if (future.v7_fetcherPersist) {
        completedFetchers.forEach((key) => state.fetchers.delete(key));
        deletedFetchersKeys.forEach((key) => deleteFetcher(key));
      }
    }
    function completeNavigation(location2, newState, _temp) {
      var _location$state, _location$state2;
      let {
        flushSync
      } = _temp === void 0 ? {} : _temp;
      let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location2.state) == null ? void 0 : _location$state._isRedirect) !== true;
      let actionData;
      if (newState.actionData) {
        if (Object.keys(newState.actionData).length > 0) {
          actionData = newState.actionData;
        } else {
          actionData = null;
        }
      } else if (isActionReload) {
        actionData = state.actionData;
      } else {
        actionData = null;
      }
      let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
      let blockers = state.blockers;
      if (blockers.size > 0) {
        blockers = new Map(blockers);
        blockers.forEach((_2, k2) => blockers.set(k2, IDLE_BLOCKER));
      }
      let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location2.state) == null ? void 0 : _location$state2._isRedirect) !== true;
      if (inFlightDataRoutes) {
        dataRoutes = inFlightDataRoutes;
        inFlightDataRoutes = void 0;
      }
      if (isUninterruptedRevalidation)
        ;
      else if (pendingAction === Action.Pop)
        ;
      else if (pendingAction === Action.Push) {
        init2.history.push(location2, location2.state);
      } else if (pendingAction === Action.Replace) {
        init2.history.replace(location2, location2.state);
      }
      let viewTransitionOpts;
      if (pendingAction === Action.Pop) {
        let priorPaths = appliedViewTransitions.get(state.location.pathname);
        if (priorPaths && priorPaths.has(location2.pathname)) {
          viewTransitionOpts = {
            currentLocation: state.location,
            nextLocation: location2
          };
        } else if (appliedViewTransitions.has(location2.pathname)) {
          viewTransitionOpts = {
            currentLocation: location2,
            nextLocation: state.location
          };
        }
      } else if (pendingViewTransitionEnabled) {
        let toPaths = appliedViewTransitions.get(state.location.pathname);
        if (toPaths) {
          toPaths.add(location2.pathname);
        } else {
          toPaths = /* @__PURE__ */ new Set([location2.pathname]);
          appliedViewTransitions.set(state.location.pathname, toPaths);
        }
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location2
        };
      }
      updateState2(_extends$2({}, newState, {
        actionData,
        loaderData,
        historyAction: pendingAction,
        location: location2,
        initialized: true,
        navigation: IDLE_NAVIGATION,
        revalidation: "idle",
        restoreScrollPosition: getSavedScrollPosition(location2, newState.matches || state.matches),
        preventScrollReset,
        blockers
      }), {
        viewTransitionOpts,
        flushSync: flushSync === true
      });
      pendingAction = Action.Pop;
      pendingPreventScrollReset = false;
      pendingViewTransitionEnabled = false;
      isUninterruptedRevalidation = false;
      isRevalidationRequired = false;
      cancelledDeferredRoutes = [];
    }
    async function navigate(to, opts) {
      if (typeof to === "number") {
        init2.history.go(to);
        return;
      }
      let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
      let {
        path,
        submission,
        error: error2
      } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
      let currentLocation = state.location;
      let nextLocation = createLocation(state.location, path, opts && opts.state);
      nextLocation = _extends$2({}, nextLocation, init2.history.encodeLocation(nextLocation));
      let userReplace = opts && opts.replace != null ? opts.replace : void 0;
      let historyAction = Action.Push;
      if (userReplace === true) {
        historyAction = Action.Replace;
      } else if (userReplace === false)
        ;
      else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
        historyAction = Action.Replace;
      }
      let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
      let flushSync = (opts && opts.flushSync) === true;
      let blockerKey = shouldBlockNavigation({
        currentLocation,
        nextLocation,
        historyAction
      });
      if (blockerKey) {
        updateBlocker(blockerKey, {
          state: "blocked",
          location: nextLocation,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: nextLocation
            });
            navigate(to, opts);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState2({
              blockers
            });
          }
        });
        return;
      }
      return await startNavigation(historyAction, nextLocation, {
        submission,
        // Send through the formData serialization error if we have one so we can
        // render at the right error boundary after we match routes
        pendingError: error2,
        preventScrollReset,
        replace: opts && opts.replace,
        enableViewTransition: opts && opts.viewTransition,
        flushSync
      });
    }
    function revalidate() {
      interruptActiveLoads();
      updateState2({
        revalidation: "loading"
      });
      if (state.navigation.state === "submitting") {
        return;
      }
      if (state.navigation.state === "idle") {
        startNavigation(state.historyAction, state.location, {
          startUninterruptedRevalidation: true
        });
        return;
      }
      startNavigation(pendingAction || state.historyAction, state.navigation.location, {
        overrideNavigation: state.navigation,
        // Proxy through any rending view transition
        enableViewTransition: pendingViewTransitionEnabled === true
      });
    }
    async function startNavigation(historyAction, location2, opts) {
      pendingNavigationController && pendingNavigationController.abort();
      pendingNavigationController = null;
      pendingAction = historyAction;
      isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
      saveScrollPosition(state.location, state.matches);
      pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
      pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let loadingNavigation = opts && opts.overrideNavigation;
      let matches = matchRoutes(routesToUse, location2, basename);
      let flushSync = (opts && opts.flushSync) === true;
      let fogOfWar = checkFogOfWar(matches, routesToUse, location2.pathname);
      if (fogOfWar.active && fogOfWar.matches) {
        matches = fogOfWar.matches;
      }
      if (!matches) {
        let {
          error: error2,
          notFoundMatches,
          route
        } = handleNavigational404(location2.pathname);
        completeNavigation(location2, {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error2
          }
        }, {
          flushSync
        });
        return;
      }
      if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location2) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
        completeNavigation(location2, {
          matches
        }, {
          flushSync
        });
        return;
      }
      pendingNavigationController = new AbortController();
      let request = createClientSideRequest(init2.history, location2, pendingNavigationController.signal, opts && opts.submission);
      let pendingActionResult;
      if (opts && opts.pendingError) {
        pendingActionResult = [findNearestBoundary(matches).route.id, {
          type: ResultType.error,
          error: opts.pendingError
        }];
      } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
        let actionResult = await handleAction(request, location2, opts.submission, matches, fogOfWar.active, {
          replace: opts.replace,
          flushSync
        });
        if (actionResult.shortCircuited) {
          return;
        }
        if (actionResult.pendingActionResult) {
          let [routeId, result] = actionResult.pendingActionResult;
          if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
            pendingNavigationController = null;
            completeNavigation(location2, {
              matches: actionResult.matches,
              loaderData: {},
              errors: {
                [routeId]: result.error
              }
            });
            return;
          }
        }
        matches = actionResult.matches || matches;
        pendingActionResult = actionResult.pendingActionResult;
        loadingNavigation = getLoadingNavigation(location2, opts.submission);
        flushSync = false;
        fogOfWar.active = false;
        request = createClientSideRequest(init2.history, request.url, request.signal);
      }
      let {
        shortCircuited,
        matches: updatedMatches,
        loaderData,
        errors: errors2
      } = await handleLoaders(request, location2, matches, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);
      if (shortCircuited) {
        return;
      }
      pendingNavigationController = null;
      completeNavigation(location2, _extends$2({
        matches: updatedMatches || matches
      }, getActionDataForCommit(pendingActionResult), {
        loaderData,
        errors: errors2
      }));
    }
    async function handleAction(request, location2, submission, matches, isFogOfWar, opts) {
      if (opts === void 0) {
        opts = {};
      }
      interruptActiveLoads();
      let navigation = getSubmittingNavigation(location2, submission);
      updateState2({
        navigation
      }, {
        flushSync: opts.flushSync === true
      });
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(matches, location2.pathname, request.signal);
        if (discoverResult.type === "aborted") {
          return {
            shortCircuited: true
          };
        } else if (discoverResult.type === "error") {
          let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
          return {
            matches: discoverResult.partialMatches,
            pendingActionResult: [boundaryId, {
              type: ResultType.error,
              error: discoverResult.error
            }]
          };
        } else if (!discoverResult.matches) {
          let {
            notFoundMatches,
            error: error2,
            route
          } = handleNavigational404(location2.pathname);
          return {
            matches: notFoundMatches,
            pendingActionResult: [route.id, {
              type: ResultType.error,
              error: error2
            }]
          };
        } else {
          matches = discoverResult.matches;
        }
      }
      let result;
      let actionMatch = getTargetMatch(matches, location2);
      if (!actionMatch.route.action && !actionMatch.route.lazy) {
        result = {
          type: ResultType.error,
          error: getInternalRouterError(405, {
            method: request.method,
            pathname: location2.pathname,
            routeId: actionMatch.route.id
          })
        };
      } else {
        let results = await callDataStrategy("action", state, request, [actionMatch], matches, null);
        result = results[actionMatch.route.id];
        if (request.signal.aborted) {
          return {
            shortCircuited: true
          };
        }
      }
      if (isRedirectResult(result)) {
        let replace2;
        if (opts && opts.replace != null) {
          replace2 = opts.replace;
        } else {
          let location3 = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request.url), basename);
          replace2 = location3 === state.location.pathname + state.location.search;
        }
        await startRedirectNavigation(request, result, true, {
          submission,
          replace: replace2
        });
        return {
          shortCircuited: true
        };
      }
      if (isDeferredResult(result)) {
        throw getInternalRouterError(400, {
          type: "defer-action"
        });
      }
      if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
        if ((opts && opts.replace) !== true) {
          pendingAction = Action.Push;
        }
        return {
          matches,
          pendingActionResult: [boundaryMatch.route.id, result]
        };
      }
      return {
        matches,
        pendingActionResult: [actionMatch.route.id, result]
      };
    }
    async function handleLoaders(request, location2, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {
      let loadingNavigation = overrideNavigation || getLoadingNavigation(location2, submission);
      let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
      let shouldUpdateNavigationState = !isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration);
      if (isFogOfWar) {
        if (shouldUpdateNavigationState) {
          let actionData = getUpdatedActionData(pendingActionResult);
          updateState2(_extends$2({
            navigation: loadingNavigation
          }, actionData !== void 0 ? {
            actionData
          } : {}), {
            flushSync
          });
        }
        let discoverResult = await discoverRoutes(matches, location2.pathname, request.signal);
        if (discoverResult.type === "aborted") {
          return {
            shortCircuited: true
          };
        } else if (discoverResult.type === "error") {
          let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
          return {
            matches: discoverResult.partialMatches,
            loaderData: {},
            errors: {
              [boundaryId]: discoverResult.error
            }
          };
        } else if (!discoverResult.matches) {
          let {
            error: error2,
            notFoundMatches,
            route
          } = handleNavigational404(location2.pathname);
          return {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error2
            }
          };
        } else {
          matches = discoverResult.matches;
        }
      }
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init2.history, state, matches, activeSubmission, location2, future.v7_partialHydration && initialHydration === true, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);
      cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId));
      pendingNavigationLoadId = ++incrementingLoadId;
      if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
        let updatedFetchers2 = markFetchRedirectsDone();
        completeNavigation(location2, _extends$2({
          matches,
          loaderData: {},
          // Commit pending error if we're short circuiting
          errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
            [pendingActionResult[0]]: pendingActionResult[1].error
          } : null
        }, getActionDataForCommit(pendingActionResult), updatedFetchers2 ? {
          fetchers: new Map(state.fetchers)
        } : {}), {
          flushSync
        });
        return {
          shortCircuited: true
        };
      }
      if (shouldUpdateNavigationState) {
        let updates = {};
        if (!isFogOfWar) {
          updates.navigation = loadingNavigation;
          let actionData = getUpdatedActionData(pendingActionResult);
          if (actionData !== void 0) {
            updates.actionData = actionData;
          }
        }
        if (revalidatingFetchers.length > 0) {
          updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
        }
        updateState2(updates, {
          flushSync
        });
      }
      revalidatingFetchers.forEach((rf2) => {
        abortFetcher(rf2.key);
        if (rf2.controller) {
          fetchControllers.set(rf2.key, rf2.controller);
        }
      });
      let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f2) => abortFetcher(f2.key));
      if (pendingNavigationController) {
        pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
      }
      let {
        loaderResults,
        fetcherResults
      } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, request);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
      if (pendingNavigationController) {
        pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
      }
      revalidatingFetchers.forEach((rf2) => fetchControllers.delete(rf2.key));
      let redirect = findRedirect(loaderResults);
      if (redirect) {
        await startRedirectNavigation(request, redirect.result, true, {
          replace: replace2
        });
        return {
          shortCircuited: true
        };
      }
      redirect = findRedirect(fetcherResults);
      if (redirect) {
        fetchRedirectIds.add(redirect.key);
        await startRedirectNavigation(request, redirect.result, true, {
          replace: replace2
        });
        return {
          shortCircuited: true
        };
      }
      let {
        loaderData,
        errors: errors2
      } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);
      activeDeferreds.forEach((deferredData, routeId) => {
        deferredData.subscribe((aborted) => {
          if (aborted || deferredData.done) {
            activeDeferreds.delete(routeId);
          }
        });
      });
      if (future.v7_partialHydration && initialHydration && state.errors) {
        errors2 = _extends$2({}, state.errors, errors2);
      }
      let updatedFetchers = markFetchRedirectsDone();
      let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
      let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
      return _extends$2({
        matches,
        loaderData,
        errors: errors2
      }, shouldUpdateFetchers ? {
        fetchers: new Map(state.fetchers)
      } : {});
    }
    function getUpdatedActionData(pendingActionResult) {
      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
        return {
          [pendingActionResult[0]]: pendingActionResult[1].data
        };
      } else if (state.actionData) {
        if (Object.keys(state.actionData).length === 0) {
          return null;
        } else {
          return state.actionData;
        }
      }
    }
    function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
      revalidatingFetchers.forEach((rf2) => {
        let fetcher = state.fetchers.get(rf2.key);
        let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
        state.fetchers.set(rf2.key, revalidatingFetcher);
      });
      return new Map(state.fetchers);
    }
    function fetch2(key, routeId, href, opts) {
      if (isServer) {
        throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
      }
      abortFetcher(key);
      let flushSync = (opts && opts.flushSync) === true;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
      let matches = matchRoutes(routesToUse, normalizedPath, basename);
      let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
      if (fogOfWar.active && fogOfWar.matches) {
        matches = fogOfWar.matches;
      }
      if (!matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: normalizedPath
        }), {
          flushSync
        });
        return;
      }
      let {
        path,
        submission,
        error: error2
      } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
      if (error2) {
        setFetcherError(key, routeId, error2, {
          flushSync
        });
        return;
      }
      let match = getTargetMatch(matches, path);
      let preventScrollReset = (opts && opts.preventScrollReset) === true;
      if (submission && isMutationMethod(submission.formMethod)) {
        handleFetcherAction(key, routeId, path, match, matches, fogOfWar.active, flushSync, preventScrollReset, submission);
        return;
      }
      fetchLoadMatches.set(key, {
        routeId,
        path
      });
      handleFetcherLoader(key, routeId, path, match, matches, fogOfWar.active, flushSync, preventScrollReset, submission);
    }
    async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {
      interruptActiveLoads();
      fetchLoadMatches.delete(key);
      function detectAndHandle405Error(m2) {
        if (!m2.route.action && !m2.route.lazy) {
          let error2 = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path,
            routeId
          });
          setFetcherError(key, routeId, error2, {
            flushSync
          });
          return true;
        }
        return false;
      }
      if (!isFogOfWar && detectAndHandle405Error(match)) {
        return;
      }
      let existingFetcher = state.fetchers.get(key);
      updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
        flushSync
      });
      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(init2.history, path, abortController.signal, submission);
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(requestMatches, path, fetchRequest.signal);
        if (discoverResult.type === "aborted") {
          return;
        } else if (discoverResult.type === "error") {
          setFetcherError(key, routeId, discoverResult.error, {
            flushSync
          });
          return;
        } else if (!discoverResult.matches) {
          setFetcherError(key, routeId, getInternalRouterError(404, {
            pathname: path
          }), {
            flushSync
          });
          return;
        } else {
          requestMatches = discoverResult.matches;
          match = getTargetMatch(requestMatches, path);
          if (detectAndHandle405Error(match)) {
            return;
          }
        }
      }
      fetchControllers.set(key, abortController);
      let originatingLoadId = incrementingLoadId;
      let actionResults = await callDataStrategy("action", state, fetchRequest, [match], requestMatches, key);
      let actionResult = actionResults[match.route.id];
      if (fetchRequest.signal.aborted) {
        if (fetchControllers.get(key) === abortController) {
          fetchControllers.delete(key);
        }
        return;
      }
      if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
        if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        }
      } else {
        if (isRedirectResult(actionResult)) {
          fetchControllers.delete(key);
          if (pendingNavigationLoadId > originatingLoadId) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          } else {
            fetchRedirectIds.add(key);
            updateFetcherState(key, getLoadingFetcher(submission));
            return startRedirectNavigation(fetchRequest, actionResult, false, {
              fetcherSubmission: submission,
              preventScrollReset
            });
          }
        }
        if (isErrorResult(actionResult)) {
          setFetcherError(key, routeId, actionResult.error);
          return;
        }
      }
      if (isDeferredResult(actionResult)) {
        throw getInternalRouterError(400, {
          type: "defer-action"
        });
      }
      let nextLocation = state.navigation.location || state.location;
      let revalidationRequest = createClientSideRequest(init2.history, nextLocation, abortController.signal);
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
      invariant(matches, "Didn't find any matches after fetcher action");
      let loadId = ++incrementingLoadId;
      fetchReloadIds.set(key, loadId);
      let loadFetcher = getLoadingFetcher(submission, actionResult.data);
      state.fetchers.set(key, loadFetcher);
      let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init2.history, state, matches, submission, nextLocation, false, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);
      revalidatingFetchers.filter((rf2) => rf2.key !== key).forEach((rf2) => {
        let staleKey = rf2.key;
        let existingFetcher2 = state.fetchers.get(staleKey);
        let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
        state.fetchers.set(staleKey, revalidatingFetcher);
        abortFetcher(staleKey);
        if (rf2.controller) {
          fetchControllers.set(staleKey, rf2.controller);
        }
      });
      updateState2({
        fetchers: new Map(state.fetchers)
      });
      let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf2) => abortFetcher(rf2.key));
      abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
      let {
        loaderResults,
        fetcherResults
      } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
      if (abortController.signal.aborted) {
        return;
      }
      abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
      fetchReloadIds.delete(key);
      fetchControllers.delete(key);
      revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
      let redirect = findRedirect(loaderResults);
      if (redirect) {
        return startRedirectNavigation(revalidationRequest, redirect.result, false, {
          preventScrollReset
        });
      }
      redirect = findRedirect(fetcherResults);
      if (redirect) {
        fetchRedirectIds.add(redirect.key);
        return startRedirectNavigation(revalidationRequest, redirect.result, false, {
          preventScrollReset
        });
      }
      let {
        loaderData,
        errors: errors2
      } = processLoaderData(state, matches, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
      if (state.fetchers.has(key)) {
        let doneFetcher = getDoneFetcher(actionResult.data);
        state.fetchers.set(key, doneFetcher);
      }
      abortStaleFetchLoads(loadId);
      if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
        invariant(pendingAction, "Expected pending action");
        pendingNavigationController && pendingNavigationController.abort();
        completeNavigation(state.navigation.location, {
          matches,
          loaderData,
          errors: errors2,
          fetchers: new Map(state.fetchers)
        });
      } else {
        updateState2({
          errors: errors2,
          loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors2),
          fetchers: new Map(state.fetchers)
        });
        isRevalidationRequired = false;
      }
    }
    async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, preventScrollReset, submission) {
      let existingFetcher = state.fetchers.get(key);
      updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
        flushSync
      });
      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(init2.history, path, abortController.signal);
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(matches, path, fetchRequest.signal);
        if (discoverResult.type === "aborted") {
          return;
        } else if (discoverResult.type === "error") {
          setFetcherError(key, routeId, discoverResult.error, {
            flushSync
          });
          return;
        } else if (!discoverResult.matches) {
          setFetcherError(key, routeId, getInternalRouterError(404, {
            pathname: path
          }), {
            flushSync
          });
          return;
        } else {
          matches = discoverResult.matches;
          match = getTargetMatch(matches, path);
        }
      }
      fetchControllers.set(key, abortController);
      let originatingLoadId = incrementingLoadId;
      let results = await callDataStrategy("loader", state, fetchRequest, [match], matches, key);
      let result = results[match.route.id];
      if (isDeferredResult(result)) {
        result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
      }
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      if (fetchRequest.signal.aborted) {
        return;
      }
      if (deletedFetchers.has(key)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
      if (isRedirectResult(result)) {
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          await startRedirectNavigation(fetchRequest, result, false, {
            preventScrollReset
          });
          return;
        }
      }
      if (isErrorResult(result)) {
        setFetcherError(key, routeId, result.error);
        return;
      }
      invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
      updateFetcherState(key, getDoneFetcher(result.data));
    }
    async function startRedirectNavigation(request, redirect, isNavigation, _temp2) {
      let {
        submission,
        fetcherSubmission,
        preventScrollReset,
        replace: replace2
      } = _temp2 === void 0 ? {} : _temp2;
      if (redirect.response.headers.has("X-Remix-Revalidate")) {
        isRevalidationRequired = true;
      }
      let location2 = redirect.response.headers.get("Location");
      invariant(location2, "Expected a Location header on the redirect Response");
      location2 = normalizeRedirectLocation(location2, new URL(request.url), basename);
      let redirectLocation = createLocation(state.location, location2, {
        _isRedirect: true
      });
      if (isBrowser) {
        let isDocumentReload = false;
        if (redirect.response.headers.has("X-Remix-Reload-Document")) {
          isDocumentReload = true;
        } else if (ABSOLUTE_URL_REGEX.test(location2)) {
          const url2 = init2.history.createURL(location2);
          isDocumentReload = // Hard reload if it's an absolute URL to a new origin
          url2.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
          stripBasename(url2.pathname, basename) == null;
        }
        if (isDocumentReload) {
          if (replace2) {
            routerWindow.location.replace(location2);
          } else {
            routerWindow.location.assign(location2);
          }
          return;
        }
      }
      pendingNavigationController = null;
      let redirectHistoryAction = replace2 === true || redirect.response.headers.has("X-Remix-Replace") ? Action.Replace : Action.Push;
      let {
        formMethod,
        formAction,
        formEncType
      } = state.navigation;
      if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
        submission = getSubmissionFromNavigation(state.navigation);
      }
      let activeSubmission = submission || fetcherSubmission;
      if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
        await startNavigation(redirectHistoryAction, redirectLocation, {
          submission: _extends$2({}, activeSubmission, {
            formAction: location2
          }),
          // Preserve these flags across redirects
          preventScrollReset: preventScrollReset || pendingPreventScrollReset,
          enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
        });
      } else {
        let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
        await startNavigation(redirectHistoryAction, redirectLocation, {
          overrideNavigation,
          // Send fetcher submissions through for shouldRevalidate
          fetcherSubmission,
          // Preserve these flags across redirects
          preventScrollReset: preventScrollReset || pendingPreventScrollReset,
          enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
        });
      }
    }
    async function callDataStrategy(type2, state2, request, matchesToLoad, matches, fetcherKey) {
      let results;
      let dataResults = {};
      try {
        results = await callDataStrategyImpl(dataStrategyImpl, type2, state2, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2);
      } catch (e2) {
        matchesToLoad.forEach((m2) => {
          dataResults[m2.route.id] = {
            type: ResultType.error,
            error: e2
          };
        });
        return dataResults;
      }
      for (let [routeId, result] of Object.entries(results)) {
        if (isRedirectDataStrategyResultResult(result)) {
          let response = result.result;
          dataResults[routeId] = {
            type: ResultType.redirect,
            response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, future.v7_relativeSplatPath)
          };
        } else {
          dataResults[routeId] = await convertDataStrategyResultToDataResult(result);
        }
      }
      return dataResults;
    }
    async function callLoadersAndMaybeResolveData(state2, matches, matchesToLoad, fetchersToLoad, request) {
      let currentMatches = state2.matches;
      let loaderResultsPromise = callDataStrategy("loader", state2, request, matchesToLoad, matches, null);
      let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async (f2) => {
        if (f2.matches && f2.match && f2.controller) {
          let results = await callDataStrategy("loader", state2, createClientSideRequest(init2.history, f2.path, f2.controller.signal), [f2.match], f2.matches, f2.key);
          let result = results[f2.match.route.id];
          return {
            [f2.key]: result
          };
        } else {
          return Promise.resolve({
            [f2.key]: {
              type: ResultType.error,
              error: getInternalRouterError(404, {
                pathname: f2.path
              })
            }
          });
        }
      }));
      let loaderResults = await loaderResultsPromise;
      let fetcherResults = (await fetcherResultsPromise).reduce((acc, r2) => Object.assign(acc, r2), {});
      await Promise.all([resolveNavigationDeferredResults(matches, loaderResults, request.signal, currentMatches, state2.loaderData), resolveFetcherDeferredResults(matches, fetcherResults, fetchersToLoad)]);
      return {
        loaderResults,
        fetcherResults
      };
    }
    function interruptActiveLoads() {
      isRevalidationRequired = true;
      cancelledDeferredRoutes.push(...cancelActiveDeferreds());
      fetchLoadMatches.forEach((_2, key) => {
        if (fetchControllers.has(key)) {
          cancelledFetcherLoads.add(key);
        }
        abortFetcher(key);
      });
    }
    function updateFetcherState(key, fetcher, opts) {
      if (opts === void 0) {
        opts = {};
      }
      state.fetchers.set(key, fetcher);
      updateState2({
        fetchers: new Map(state.fetchers)
      }, {
        flushSync: (opts && opts.flushSync) === true
      });
    }
    function setFetcherError(key, routeId, error2, opts) {
      if (opts === void 0) {
        opts = {};
      }
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      deleteFetcher(key);
      updateState2({
        errors: {
          [boundaryMatch.route.id]: error2
        },
        fetchers: new Map(state.fetchers)
      }, {
        flushSync: (opts && opts.flushSync) === true
      });
    }
    function getFetcher(key) {
      if (future.v7_fetcherPersist) {
        activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
        if (deletedFetchers.has(key)) {
          deletedFetchers.delete(key);
        }
      }
      return state.fetchers.get(key) || IDLE_FETCHER;
    }
    function deleteFetcher(key) {
      let fetcher = state.fetchers.get(key);
      if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
        abortFetcher(key);
      }
      fetchLoadMatches.delete(key);
      fetchReloadIds.delete(key);
      fetchRedirectIds.delete(key);
      deletedFetchers.delete(key);
      cancelledFetcherLoads.delete(key);
      state.fetchers.delete(key);
    }
    function deleteFetcherAndUpdateState(key) {
      if (future.v7_fetcherPersist) {
        let count = (activeFetchers.get(key) || 0) - 1;
        if (count <= 0) {
          activeFetchers.delete(key);
          deletedFetchers.add(key);
        } else {
          activeFetchers.set(key, count);
        }
      } else {
        deleteFetcher(key);
      }
      updateState2({
        fetchers: new Map(state.fetchers)
      });
    }
    function abortFetcher(key) {
      let controller = fetchControllers.get(key);
      if (controller) {
        controller.abort();
        fetchControllers.delete(key);
      }
    }
    function markFetchersDone(keys) {
      for (let key of keys) {
        let fetcher = getFetcher(key);
        let doneFetcher = getDoneFetcher(fetcher.data);
        state.fetchers.set(key, doneFetcher);
      }
    }
    function markFetchRedirectsDone() {
      let doneKeys = [];
      let updatedFetchers = false;
      for (let key of fetchRedirectIds) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          fetchRedirectIds.delete(key);
          doneKeys.push(key);
          updatedFetchers = true;
        }
      }
      markFetchersDone(doneKeys);
      return updatedFetchers;
    }
    function abortStaleFetchLoads(landedId) {
      let yeetedKeys = [];
      for (let [key, id2] of fetchReloadIds) {
        if (id2 < landedId) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, "Expected fetcher: " + key);
          if (fetcher.state === "loading") {
            abortFetcher(key);
            fetchReloadIds.delete(key);
            yeetedKeys.push(key);
          }
        }
      }
      markFetchersDone(yeetedKeys);
      return yeetedKeys.length > 0;
    }
    function getBlocker(key, fn) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      if (blockerFunctions.get(key) !== fn) {
        blockerFunctions.set(key, fn);
      }
      return blocker;
    }
    function deleteBlocker(key) {
      state.blockers.delete(key);
      blockerFunctions.delete(key);
    }
    function updateBlocker(key, newBlocker) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
      let blockers = new Map(state.blockers);
      blockers.set(key, newBlocker);
      updateState2({
        blockers
      });
    }
    function shouldBlockNavigation(_ref2) {
      let {
        currentLocation,
        nextLocation,
        historyAction
      } = _ref2;
      if (blockerFunctions.size === 0) {
        return;
      }
      if (blockerFunctions.size > 1) {
        warning(false, "A router only supports one blocker at a time");
      }
      let entries = Array.from(blockerFunctions.entries());
      let [blockerKey, blockerFunction] = entries[entries.length - 1];
      let blocker = state.blockers.get(blockerKey);
      if (blocker && blocker.state === "proceeding") {
        return;
      }
      if (blockerFunction({
        currentLocation,
        nextLocation,
        historyAction
      })) {
        return blockerKey;
      }
    }
    function handleNavigational404(pathname) {
      let error2 = getInternalRouterError(404, {
        pathname
      });
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let {
        matches,
        route
      } = getShortCircuitMatches(routesToUse);
      cancelActiveDeferreds();
      return {
        notFoundMatches: matches,
        route,
        error: error2
      };
    }
    function cancelActiveDeferreds(predicate) {
      let cancelledRouteIds = [];
      activeDeferreds.forEach((dfd, routeId) => {
        if (!predicate || predicate(routeId)) {
          dfd.cancel();
          cancelledRouteIds.push(routeId);
          activeDeferreds.delete(routeId);
        }
      });
      return cancelledRouteIds;
    }
    function enableScrollRestoration(positions, getPosition, getKey) {
      savedScrollPositions = positions;
      getScrollPosition = getPosition;
      getScrollRestorationKey = getKey || null;
      if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
        initialScrollRestored = true;
        let y2 = getSavedScrollPosition(state.location, state.matches);
        if (y2 != null) {
          updateState2({
            restoreScrollPosition: y2
          });
        }
      }
      return () => {
        savedScrollPositions = null;
        getScrollPosition = null;
        getScrollRestorationKey = null;
      };
    }
    function getScrollKey(location2, matches) {
      if (getScrollRestorationKey) {
        let key = getScrollRestorationKey(location2, matches.map((m2) => convertRouteMatchToUiMatch(m2, state.loaderData)));
        return key || location2.key;
      }
      return location2.key;
    }
    function saveScrollPosition(location2, matches) {
      if (savedScrollPositions && getScrollPosition) {
        let key = getScrollKey(location2, matches);
        savedScrollPositions[key] = getScrollPosition();
      }
    }
    function getSavedScrollPosition(location2, matches) {
      if (savedScrollPositions) {
        let key = getScrollKey(location2, matches);
        let y2 = savedScrollPositions[key];
        if (typeof y2 === "number") {
          return y2;
        }
      }
      return null;
    }
    function checkFogOfWar(matches, routesToUse, pathname) {
      if (patchRoutesOnNavigationImpl) {
        if (!matches) {
          let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
          return {
            active: true,
            matches: fogMatches || []
          };
        } else {
          if (Object.keys(matches[0].params).length > 0) {
            let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
            return {
              active: true,
              matches: partialMatches
            };
          }
        }
      }
      return {
        active: false,
        matches: null
      };
    }
    async function discoverRoutes(matches, pathname, signal) {
      if (!patchRoutesOnNavigationImpl) {
        return {
          type: "success",
          matches
        };
      }
      let partialMatches = matches;
      while (true) {
        let isNonHMR = inFlightDataRoutes == null;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let localManifest = manifest;
        try {
          await patchRoutesOnNavigationImpl({
            path: pathname,
            matches: partialMatches,
            patch: (routeId, children) => {
              if (signal.aborted)
                return;
              patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);
            }
          });
        } catch (e2) {
          return {
            type: "error",
            error: e2,
            partialMatches
          };
        } finally {
          if (isNonHMR && !signal.aborted) {
            dataRoutes = [...dataRoutes];
          }
        }
        if (signal.aborted) {
          return {
            type: "aborted"
          };
        }
        let newMatches = matchRoutes(routesToUse, pathname, basename);
        if (newMatches) {
          return {
            type: "success",
            matches: newMatches
          };
        }
        let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
        if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m2, i2) => m2.route.id === newPartialMatches[i2].route.id)) {
          return {
            type: "success",
            matches: null
          };
        }
        partialMatches = newPartialMatches;
      }
    }
    function _internalSetRoutes(newRoutes) {
      manifest = {};
      inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
    }
    function patchRoutes(routeId, children) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);
      if (isNonHMR) {
        dataRoutes = [...dataRoutes];
        updateState2({});
      }
    }
    router2 = {
      get basename() {
        return basename;
      },
      get future() {
        return future;
      },
      get state() {
        return state;
      },
      get routes() {
        return dataRoutes;
      },
      get window() {
        return routerWindow;
      },
      initialize,
      subscribe,
      enableScrollRestoration,
      navigate,
      fetch: fetch2,
      revalidate,
      // Passthrough to history-aware createHref used by useHref so we get proper
      // hash-aware URLs in DOM paths
      createHref: (to) => init2.history.createHref(to),
      encodeLocation: (to) => init2.history.encodeLocation(to),
      getFetcher,
      deleteFetcher: deleteFetcherAndUpdateState,
      dispose,
      getBlocker,
      deleteBlocker,
      patchRoutes,
      _internalFetchControllers: fetchControllers,
      _internalActiveDeferreds: activeDeferreds,
      // TODO: Remove setRoutes, it's temporary to avoid dealing with
      // updating the tree while validating the update algorithm.
      _internalSetRoutes
    };
    return router2;
  }
  function isSubmissionNavigation(opts) {
    return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
  }
  function normalizeTo(location2, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
    let contextualMatches;
    let activeRouteMatch;
    if (fromRouteId) {
      contextualMatches = [];
      for (let match of matches) {
        contextualMatches.push(match);
        if (match.route.id === fromRouteId) {
          activeRouteMatch = match;
          break;
        }
      }
    } else {
      contextualMatches = matches;
      activeRouteMatch = matches[matches.length - 1];
    }
    let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location2.pathname, basename) || location2.pathname, relative === "path");
    if (to == null) {
      path.search = location2.search;
      path.hash = location2.hash;
    }
    if ((to == null || to === "" || to === ".") && activeRouteMatch) {
      let nakedIndex = hasNakedIndexQuery(path.search);
      if (activeRouteMatch.route.index && !nakedIndex) {
        path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
      } else if (!activeRouteMatch.route.index && nakedIndex) {
        let params = new URLSearchParams(path.search);
        let indexValues = params.getAll("index");
        params.delete("index");
        indexValues.filter((v2) => v2).forEach((v2) => params.append("index", v2));
        let qs = params.toString();
        path.search = qs ? "?" + qs : "";
      }
    }
    if (prependBasename && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    return createPath(path);
  }
  function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
    if (!opts || !isSubmissionNavigation(opts)) {
      return {
        path
      };
    }
    if (opts.formMethod && !isValidMethod(opts.formMethod)) {
      return {
        path,
        error: getInternalRouterError(405, {
          method: opts.formMethod
        })
      };
    }
    let getInvalidBodyError = () => ({
      path,
      error: getInternalRouterError(400, {
        type: "invalid-body"
      })
    });
    let rawFormMethod = opts.formMethod || "get";
    let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
    let formAction = stripHashFromPath(path);
    if (opts.body !== void 0) {
      if (opts.formEncType === "text/plain") {
        if (!isMutationMethod(formMethod)) {
          return getInvalidBodyError();
        }
        let text2 = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
          // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
          Array.from(opts.body.entries()).reduce((acc, _ref3) => {
            let [name2, value2] = _ref3;
            return "" + acc + name2 + "=" + value2 + "\n";
          }, "")
        ) : String(opts.body);
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json: void 0,
            text: text2
          }
        };
      } else if (opts.formEncType === "application/json") {
        if (!isMutationMethod(formMethod)) {
          return getInvalidBodyError();
        }
        try {
          let json2 = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
          return {
            path,
            submission: {
              formMethod,
              formAction,
              formEncType: opts.formEncType,
              formData: void 0,
              json: json2,
              text: void 0
            }
          };
        } catch (e2) {
          return getInvalidBodyError();
        }
      }
    }
    invariant(typeof FormData === "function", "FormData is not available in this environment");
    let searchParams;
    let formData;
    if (opts.formData) {
      searchParams = convertFormDataToSearchParams(opts.formData);
      formData = opts.formData;
    } else if (opts.body instanceof FormData) {
      searchParams = convertFormDataToSearchParams(opts.body);
      formData = opts.body;
    } else if (opts.body instanceof URLSearchParams) {
      searchParams = opts.body;
      formData = convertSearchParamsToFormData(searchParams);
    } else if (opts.body == null) {
      searchParams = new URLSearchParams();
      formData = new FormData();
    } else {
      try {
        searchParams = new URLSearchParams(opts.body);
        formData = convertSearchParamsToFormData(searchParams);
      } catch (e2) {
        return getInvalidBodyError();
      }
    }
    let submission = {
      formMethod,
      formAction,
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData,
      json: void 0,
      text: void 0
    };
    if (isMutationMethod(submission.formMethod)) {
      return {
        path,
        submission
      };
    }
    let parsedPath = parsePath(path);
    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
      searchParams.append("index", "");
    }
    parsedPath.search = "?" + searchParams;
    return {
      path: createPath(parsedPath),
      submission
    };
  }
  function getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary) {
    if (includeBoundary === void 0) {
      includeBoundary = false;
    }
    let index2 = matches.findIndex((m2) => m2.route.id === boundaryId);
    if (index2 >= 0) {
      return matches.slice(0, includeBoundary ? index2 + 1 : index2);
    }
    return matches;
  }
  function getMatchesToLoad(history2, state, matches, submission, location2, initialHydration, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
    let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
    let currentUrl = history2.createURL(state.location);
    let nextUrl = history2.createURL(location2);
    let boundaryMatches = matches;
    if (initialHydration && state.errors) {
      boundaryMatches = getLoaderMatchesUntilBoundary(matches, Object.keys(state.errors)[0], true);
    } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
      boundaryMatches = getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]);
    }
    let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
    let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;
    let navigationMatches = boundaryMatches.filter((match, index2) => {
      let {
        route
      } = match;
      if (route.lazy) {
        return true;
      }
      if (route.loader == null) {
        return false;
      }
      if (initialHydration) {
        return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
      }
      if (isNewLoader(state.loaderData, state.matches[index2], match) || cancelledDeferredRoutes.some((id2) => id2 === match.route.id)) {
        return true;
      }
      let currentRouteMatch = state.matches[index2];
      let nextRouteMatch = match;
      return shouldRevalidateLoader(match, _extends$2({
        currentUrl,
        currentParams: currentRouteMatch.params,
        nextUrl,
        nextParams: nextRouteMatch.params
      }, submission, {
        actionResult,
        actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : (
          // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
          isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
          currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
        )
      }));
    });
    let revalidatingFetchers = [];
    fetchLoadMatches.forEach((f2, key) => {
      if (initialHydration || !matches.some((m2) => m2.route.id === f2.routeId) || deletedFetchers.has(key)) {
        return;
      }
      let fetcherMatches = matchRoutes(routesToUse, f2.path, basename);
      if (!fetcherMatches) {
        revalidatingFetchers.push({
          key,
          routeId: f2.routeId,
          path: f2.path,
          matches: null,
          match: null,
          controller: null
        });
        return;
      }
      let fetcher = state.fetchers.get(key);
      let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
      let shouldRevalidate = false;
      if (fetchRedirectIds.has(key)) {
        shouldRevalidate = false;
      } else if (cancelledFetcherLoads.has(key)) {
        cancelledFetcherLoads.delete(key);
        shouldRevalidate = true;
      } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
        shouldRevalidate = isRevalidationRequired;
      } else {
        shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends$2({
          currentUrl,
          currentParams: state.matches[state.matches.length - 1].params,
          nextUrl,
          nextParams: matches[matches.length - 1].params
        }, submission, {
          actionResult,
          actionStatus,
          defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
        }));
      }
      if (shouldRevalidate) {
        revalidatingFetchers.push({
          key,
          routeId: f2.routeId,
          path: f2.path,
          matches: fetcherMatches,
          match: fetcherMatch,
          controller: new AbortController()
        });
      }
    });
    return [navigationMatches, revalidatingFetchers];
  }
  function shouldLoadRouteOnHydration(route, loaderData, errors2) {
    if (route.lazy) {
      return true;
    }
    if (!route.loader) {
      return false;
    }
    let hasData = loaderData != null && loaderData[route.id] !== void 0;
    let hasError = errors2 != null && errors2[route.id] !== void 0;
    if (!hasData && hasError) {
      return false;
    }
    if (typeof route.loader === "function" && route.loader.hydrate === true) {
      return true;
    }
    return !hasData && !hasError;
  }
  function isNewLoader(currentLoaderData, currentMatch, match) {
    let isNew = (
      // [a] -> [a, b]
      !currentMatch || // [a, b] -> [a, c]
      match.route.id !== currentMatch.route.id
    );
    let isMissingData = currentLoaderData[match.route.id] === void 0;
    return isNew || isMissingData;
  }
  function isNewRouteInstance(currentMatch, match) {
    let currentPath = currentMatch.route.path;
    return (
      // param change for this match, /users/123 -> /users/456
      currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
    );
  }
  function shouldRevalidateLoader(loaderMatch, arg) {
    if (loaderMatch.route.shouldRevalidate) {
      let routeChoice = loaderMatch.route.shouldRevalidate(arg);
      if (typeof routeChoice === "boolean") {
        return routeChoice;
      }
    }
    return arg.defaultShouldRevalidate;
  }
  function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
    var _childrenToPatch;
    let childrenToPatch;
    if (routeId) {
      let route = manifest[routeId];
      invariant(route, "No route found to patch children into: routeId = " + routeId);
      if (!route.children) {
        route.children = [];
      }
      childrenToPatch = route.children;
    } else {
      childrenToPatch = routesToUse;
    }
    let uniqueChildren = children.filter((newRoute) => !childrenToPatch.some((existingRoute) => isSameRoute(newRoute, existingRoute)));
    let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [routeId || "_", "patch", String(((_childrenToPatch = childrenToPatch) == null ? void 0 : _childrenToPatch.length) || "0")], manifest);
    childrenToPatch.push(...newRoutes);
  }
  function isSameRoute(newRoute, existingRoute) {
    if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
      return true;
    }
    if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
      return false;
    }
    if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
      return true;
    }
    return newRoute.children.every((aChild, i2) => {
      var _existingRoute$childr;
      return (_existingRoute$childr = existingRoute.children) == null ? void 0 : _existingRoute$childr.some((bChild) => isSameRoute(aChild, bChild));
    });
  }
  async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
    if (!route.lazy) {
      return;
    }
    let lazyRoute = await route.lazy();
    if (!route.lazy) {
      return;
    }
    let routeToUpdate = manifest[route.id];
    invariant(routeToUpdate, "No route found in manifest");
    let routeUpdates = {};
    for (let lazyRouteProperty in lazyRoute) {
      let staticRouteValue = routeToUpdate[lazyRouteProperty];
      let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
      // on the route updates
      lazyRouteProperty !== "hasErrorBoundary";
      warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
      if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
        routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
      }
    }
    Object.assign(routeToUpdate, routeUpdates);
    Object.assign(routeToUpdate, _extends$2({}, mapRouteProperties2(routeToUpdate), {
      lazy: void 0
    }));
  }
  async function defaultDataStrategy(_ref4) {
    let {
      matches
    } = _ref4;
    let matchesToLoad = matches.filter((m2) => m2.shouldLoad);
    let results = await Promise.all(matchesToLoad.map((m2) => m2.resolve()));
    return results.reduce((acc, result, i2) => Object.assign(acc, {
      [matchesToLoad[i2].route.id]: result
    }), {});
  }
  async function callDataStrategyImpl(dataStrategyImpl, type2, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2, requestContext) {
    let loadRouteDefinitionsPromises = matches.map((m2) => m2.route.lazy ? loadLazyRouteModule(m2.route, mapRouteProperties2, manifest) : void 0);
    let dsMatches = matches.map((match, i2) => {
      let loadRoutePromise = loadRouteDefinitionsPromises[i2];
      let shouldLoad = matchesToLoad.some((m2) => m2.route.id === match.route.id);
      let resolve = async (handlerOverride) => {
        if (handlerOverride && request.method === "GET" && (match.route.lazy || match.route.loader)) {
          shouldLoad = true;
        }
        return shouldLoad ? callLoaderOrAction(type2, request, match, loadRoutePromise, handlerOverride, requestContext) : Promise.resolve({
          type: ResultType.data,
          result: void 0
        });
      };
      return _extends$2({}, match, {
        shouldLoad,
        resolve
      });
    });
    let results = await dataStrategyImpl({
      matches: dsMatches,
      request,
      params: matches[0].params,
      fetcherKey,
      context: requestContext
    });
    try {
      await Promise.all(loadRouteDefinitionsPromises);
    } catch (e2) {
    }
    return results;
  }
  async function callLoaderOrAction(type2, request, match, loadRoutePromise, handlerOverride, staticContext) {
    let result;
    let onReject;
    let runHandler = (handler) => {
      let reject;
      let abortPromise = new Promise((_2, r2) => reject = r2);
      onReject = () => reject();
      request.signal.addEventListener("abort", onReject);
      let actualHandler = (ctx) => {
        if (typeof handler !== "function") {
          return Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + type2 + '" [routeId: ' + match.route.id + "]")));
        }
        return handler({
          request,
          params: match.params,
          context: staticContext
        }, ...ctx !== void 0 ? [ctx] : []);
      };
      let handlerPromise = (async () => {
        try {
          let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
          return {
            type: "data",
            result: val
          };
        } catch (e2) {
          return {
            type: "error",
            result: e2
          };
        }
      })();
      return Promise.race([handlerPromise, abortPromise]);
    };
    try {
      let handler = match.route[type2];
      if (loadRoutePromise) {
        if (handler) {
          let handlerError;
          let [value2] = await Promise.all([
            // If the handler throws, don't let it immediately bubble out,
            // since we need to let the lazy() execution finish so we know if this
            // route has a boundary that can handle the error
            runHandler(handler).catch((e2) => {
              handlerError = e2;
            }),
            loadRoutePromise
          ]);
          if (handlerError !== void 0) {
            throw handlerError;
          }
          result = value2;
        } else {
          await loadRoutePromise;
          handler = match.route[type2];
          if (handler) {
            result = await runHandler(handler);
          } else if (type2 === "action") {
            let url2 = new URL(request.url);
            let pathname = url2.pathname + url2.search;
            throw getInternalRouterError(405, {
              method: request.method,
              pathname,
              routeId: match.route.id
            });
          } else {
            return {
              type: ResultType.data,
              result: void 0
            };
          }
        }
      } else if (!handler) {
        let url2 = new URL(request.url);
        let pathname = url2.pathname + url2.search;
        throw getInternalRouterError(404, {
          pathname
        });
      } else {
        result = await runHandler(handler);
      }
      invariant(result.result !== void 0, "You defined " + (type2 === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type2 + "` ") + "function. Please return a value or `null`.");
    } catch (e2) {
      return {
        type: ResultType.error,
        result: e2
      };
    } finally {
      if (onReject) {
        request.signal.removeEventListener("abort", onReject);
      }
    }
    return result;
  }
  async function convertDataStrategyResultToDataResult(dataStrategyResult) {
    let {
      result,
      type: type2
    } = dataStrategyResult;
    if (isResponse$1(result)) {
      let data;
      try {
        let contentType = result.headers.get("Content-Type");
        if (contentType && /\bapplication\/json\b/.test(contentType)) {
          if (result.body == null) {
            data = null;
          } else {
            data = await result.json();
          }
        } else {
          data = await result.text();
        }
      } catch (e2) {
        return {
          type: ResultType.error,
          error: e2
        };
      }
      if (type2 === ResultType.error) {
        return {
          type: ResultType.error,
          error: new ErrorResponseImpl(result.status, result.statusText, data),
          statusCode: result.status,
          headers: result.headers
        };
      }
      return {
        type: ResultType.data,
        data,
        statusCode: result.status,
        headers: result.headers
      };
    }
    if (type2 === ResultType.error) {
      if (isDataWithResponseInit(result)) {
        var _result$init2;
        if (result.data instanceof Error) {
          var _result$init;
          return {
            type: ResultType.error,
            error: result.data,
            statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status
          };
        }
        result = new ErrorResponseImpl(((_result$init2 = result.init) == null ? void 0 : _result$init2.status) || 500, void 0, result.data);
      }
      return {
        type: ResultType.error,
        error: result,
        statusCode: isRouteErrorResponse(result) ? result.status : void 0
      };
    }
    if (isDeferredData(result)) {
      var _result$init3, _result$init4;
      return {
        type: ResultType.deferred,
        deferredData: result,
        statusCode: (_result$init3 = result.init) == null ? void 0 : _result$init3.status,
        headers: ((_result$init4 = result.init) == null ? void 0 : _result$init4.headers) && new Headers(result.init.headers)
      };
    }
    if (isDataWithResponseInit(result)) {
      var _result$init5, _result$init6;
      return {
        type: ResultType.data,
        data: result.data,
        statusCode: (_result$init5 = result.init) == null ? void 0 : _result$init5.status,
        headers: (_result$init6 = result.init) != null && _result$init6.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return {
      type: ResultType.data,
      data: result
    };
  }
  function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {
    let location2 = response.headers.get("Location");
    invariant(location2, "Redirects returned/thrown from loaders/actions must have a Location header");
    if (!ABSOLUTE_URL_REGEX.test(location2)) {
      let trimmedMatches = matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1);
      location2 = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location2, v7_relativeSplatPath);
      response.headers.set("Location", location2);
    }
    return response;
  }
  function normalizeRedirectLocation(location2, currentUrl, basename) {
    if (ABSOLUTE_URL_REGEX.test(location2)) {
      let normalizedLocation = location2;
      let url2 = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
      let isSameBasename = stripBasename(url2.pathname, basename) != null;
      if (url2.origin === currentUrl.origin && isSameBasename) {
        return url2.pathname + url2.search + url2.hash;
      }
    }
    return location2;
  }
  function createClientSideRequest(history2, location2, signal, submission) {
    let url2 = history2.createURL(stripHashFromPath(location2)).toString();
    let init2 = {
      signal
    };
    if (submission && isMutationMethod(submission.formMethod)) {
      let {
        formMethod,
        formEncType
      } = submission;
      init2.method = formMethod.toUpperCase();
      if (formEncType === "application/json") {
        init2.headers = new Headers({
          "Content-Type": formEncType
        });
        init2.body = JSON.stringify(submission.json);
      } else if (formEncType === "text/plain") {
        init2.body = submission.text;
      } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
        init2.body = convertFormDataToSearchParams(submission.formData);
      } else {
        init2.body = submission.formData;
      }
    }
    return new Request(url2, init2);
  }
  function convertFormDataToSearchParams(formData) {
    let searchParams = new URLSearchParams();
    for (let [key, value2] of formData.entries()) {
      searchParams.append(key, typeof value2 === "string" ? value2 : value2.name);
    }
    return searchParams;
  }
  function convertSearchParamsToFormData(searchParams) {
    let formData = new FormData();
    for (let [key, value2] of searchParams.entries()) {
      formData.append(key, value2);
    }
    return formData;
  }
  function processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
    let loaderData = {};
    let errors2 = null;
    let statusCode;
    let foundError = false;
    let loaderHeaders = {};
    let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
    matches.forEach((match) => {
      if (!(match.route.id in results)) {
        return;
      }
      let id2 = match.route.id;
      let result = results[id2];
      invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
      if (isErrorResult(result)) {
        let error2 = result.error;
        if (pendingError !== void 0) {
          error2 = pendingError;
          pendingError = void 0;
        }
        errors2 = errors2 || {};
        if (skipLoaderErrorBubbling) {
          errors2[id2] = error2;
        } else {
          let boundaryMatch = findNearestBoundary(matches, id2);
          if (errors2[boundaryMatch.route.id] == null) {
            errors2[boundaryMatch.route.id] = error2;
          }
        }
        loaderData[id2] = void 0;
        if (!foundError) {
          foundError = true;
          statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
        }
        if (result.headers) {
          loaderHeaders[id2] = result.headers;
        }
      } else {
        if (isDeferredResult(result)) {
          activeDeferreds.set(id2, result.deferredData);
          loaderData[id2] = result.deferredData.data;
          if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
            statusCode = result.statusCode;
          }
          if (result.headers) {
            loaderHeaders[id2] = result.headers;
          }
        } else {
          loaderData[id2] = result.data;
          if (result.statusCode && result.statusCode !== 200 && !foundError) {
            statusCode = result.statusCode;
          }
          if (result.headers) {
            loaderHeaders[id2] = result.headers;
          }
        }
      }
    });
    if (pendingError !== void 0 && pendingActionResult) {
      errors2 = {
        [pendingActionResult[0]]: pendingError
      };
      loaderData[pendingActionResult[0]] = void 0;
    }
    return {
      loaderData,
      errors: errors2,
      statusCode: statusCode || 200,
      loaderHeaders
    };
  }
  function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
    let {
      loaderData,
      errors: errors2
    } = processRouteLoaderData(
      matches,
      results,
      pendingActionResult,
      activeDeferreds,
      false
      // This method is only called client side so we always want to bubble
    );
    revalidatingFetchers.forEach((rf2) => {
      let {
        key,
        match,
        controller
      } = rf2;
      let result = fetcherResults[key];
      invariant(result, "Did not find corresponding fetcher result");
      if (controller && controller.signal.aborted) {
        return;
      } else if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
        if (!(errors2 && errors2[boundaryMatch.route.id])) {
          errors2 = _extends$2({}, errors2, {
            [boundaryMatch.route.id]: result.error
          });
        }
        state.fetchers.delete(key);
      } else if (isRedirectResult(result)) {
        invariant(false, "Unhandled fetcher revalidation redirect");
      } else if (isDeferredResult(result)) {
        invariant(false, "Unhandled fetcher deferred data");
      } else {
        let doneFetcher = getDoneFetcher(result.data);
        state.fetchers.set(key, doneFetcher);
      }
    });
    return {
      loaderData,
      errors: errors2
    };
  }
  function mergeLoaderData(loaderData, newLoaderData, matches, errors2) {
    let mergedLoaderData = _extends$2({}, newLoaderData);
    for (let match of matches) {
      let id2 = match.route.id;
      if (newLoaderData.hasOwnProperty(id2)) {
        if (newLoaderData[id2] !== void 0) {
          mergedLoaderData[id2] = newLoaderData[id2];
        }
      } else if (loaderData[id2] !== void 0 && match.route.loader) {
        mergedLoaderData[id2] = loaderData[id2];
      }
      if (errors2 && errors2.hasOwnProperty(id2)) {
        break;
      }
    }
    return mergedLoaderData;
  }
  function getActionDataForCommit(pendingActionResult) {
    if (!pendingActionResult) {
      return {};
    }
    return isErrorResult(pendingActionResult[1]) ? {
      // Clear out prior actionData on errors
      actionData: {}
    } : {
      actionData: {
        [pendingActionResult[0]]: pendingActionResult[1].data
      }
    };
  }
  function findNearestBoundary(matches, routeId) {
    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches];
    return eligibleMatches.reverse().find((m2) => m2.route.hasErrorBoundary === true) || matches[0];
  }
  function getShortCircuitMatches(routes) {
    let route = routes.length === 1 ? routes[0] : routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
      id: "__shim-error-route__"
    };
    return {
      matches: [{
        params: {},
        pathname: "",
        pathnameBase: "",
        route
      }],
      route
    };
  }
  function getInternalRouterError(status, _temp5) {
    let {
      pathname,
      routeId,
      method,
      type: type2,
      message
    } = _temp5 === void 0 ? {} : _temp5;
    let statusText = "Unknown Server Error";
    let errorMessage = "Unknown @remix-run/router error";
    if (status === 400) {
      statusText = "Bad Request";
      if (method && pathname && routeId) {
        errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
      } else if (type2 === "defer-action") {
        errorMessage = "defer() is not supported in actions";
      } else if (type2 === "invalid-body") {
        errorMessage = "Unable to encode submission body";
      }
    } else if (status === 403) {
      statusText = "Forbidden";
      errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
    } else if (status === 404) {
      statusText = "Not Found";
      errorMessage = 'No route matches URL "' + pathname + '"';
    } else if (status === 405) {
      statusText = "Method Not Allowed";
      if (method && pathname && routeId) {
        errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
      } else if (method) {
        errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
      }
    }
    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
  }
  function findRedirect(results) {
    let entries = Object.entries(results);
    for (let i2 = entries.length - 1; i2 >= 0; i2--) {
      let [key, result] = entries[i2];
      if (isRedirectResult(result)) {
        return {
          key,
          result
        };
      }
    }
  }
  function stripHashFromPath(path) {
    let parsedPath = typeof path === "string" ? parsePath(path) : path;
    return createPath(_extends$2({}, parsedPath, {
      hash: ""
    }));
  }
  function isHashChangeOnly(a2, b2) {
    if (a2.pathname !== b2.pathname || a2.search !== b2.search) {
      return false;
    }
    if (a2.hash === "") {
      return b2.hash !== "";
    } else if (a2.hash === b2.hash) {
      return true;
    } else if (b2.hash !== "") {
      return true;
    }
    return false;
  }
  function isRedirectDataStrategyResultResult(result) {
    return isResponse$1(result.result) && redirectStatusCodes.has(result.result.status);
  }
  function isDeferredResult(result) {
    return result.type === ResultType.deferred;
  }
  function isErrorResult(result) {
    return result.type === ResultType.error;
  }
  function isRedirectResult(result) {
    return (result && result.type) === ResultType.redirect;
  }
  function isDataWithResponseInit(value2) {
    return typeof value2 === "object" && value2 != null && "type" in value2 && "data" in value2 && "init" in value2 && value2.type === "DataWithResponseInit";
  }
  function isDeferredData(value2) {
    let deferred = value2;
    return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
  }
  function isResponse$1(value2) {
    return value2 != null && typeof value2.status === "number" && typeof value2.statusText === "string" && typeof value2.headers === "object" && typeof value2.body !== "undefined";
  }
  function isValidMethod(method) {
    return validRequestMethods.has(method.toLowerCase());
  }
  function isMutationMethod(method) {
    return validMutationMethods.has(method.toLowerCase());
  }
  async function resolveNavigationDeferredResults(matches, results, signal, currentMatches, currentLoaderData) {
    let entries = Object.entries(results);
    for (let index2 = 0; index2 < entries.length; index2++) {
      let [routeId, result] = entries[index2];
      let match = matches.find((m2) => (m2 == null ? void 0 : m2.route.id) === routeId);
      if (!match) {
        continue;
      }
      let currentMatch = currentMatches.find((m2) => m2.route.id === match.route.id);
      let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
      if (isDeferredResult(result) && isRevalidatingLoader) {
        await resolveDeferredData(result, signal, false).then((result2) => {
          if (result2) {
            results[routeId] = result2;
          }
        });
      }
    }
  }
  async function resolveFetcherDeferredResults(matches, results, revalidatingFetchers) {
    for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
      let {
        key,
        routeId,
        controller
      } = revalidatingFetchers[index2];
      let result = results[key];
      let match = matches.find((m2) => (m2 == null ? void 0 : m2.route.id) === routeId);
      if (!match) {
        continue;
      }
      if (isDeferredResult(result)) {
        invariant(controller, "Expected an AbortController for revalidating fetcher deferred result");
        await resolveDeferredData(result, controller.signal, true).then((result2) => {
          if (result2) {
            results[key] = result2;
          }
        });
      }
    }
  }
  async function resolveDeferredData(result, signal, unwrap) {
    if (unwrap === void 0) {
      unwrap = false;
    }
    let aborted = await result.deferredData.resolveData(signal);
    if (aborted) {
      return;
    }
    if (unwrap) {
      try {
        return {
          type: ResultType.data,
          data: result.deferredData.unwrappedData
        };
      } catch (e2) {
        return {
          type: ResultType.error,
          error: e2
        };
      }
    }
    return {
      type: ResultType.data,
      data: result.deferredData.data
    };
  }
  function hasNakedIndexQuery(search) {
    return new URLSearchParams(search).getAll("index").some((v2) => v2 === "");
  }
  function getTargetMatch(matches, location2) {
    let search = typeof location2 === "string" ? parsePath(location2).search : location2.search;
    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
      return matches[matches.length - 1];
    }
    let pathMatches = getPathContributingMatches(matches);
    return pathMatches[pathMatches.length - 1];
  }
  function getSubmissionFromNavigation(navigation) {
    let {
      formMethod,
      formAction,
      formEncType,
      text: text2,
      formData,
      json: json2
    } = navigation;
    if (!formMethod || !formAction || !formEncType) {
      return;
    }
    if (text2 != null) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json: void 0,
        text: text2
      };
    } else if (formData != null) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData,
        json: void 0,
        text: void 0
      };
    } else if (json2 !== void 0) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json: json2,
        text: void 0
      };
    }
  }
  function getLoadingNavigation(location2, submission) {
    if (submission) {
      let navigation = {
        state: "loading",
        location: location2,
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text
      };
      return navigation;
    } else {
      let navigation = {
        state: "loading",
        location: location2,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
      };
      return navigation;
    }
  }
  function getSubmittingNavigation(location2, submission) {
    let navigation = {
      state: "submitting",
      location: location2,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  }
  function getLoadingFetcher(submission, data) {
    if (submission) {
      let fetcher = {
        state: "loading",
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text,
        data
      };
      return fetcher;
    } else {
      let fetcher = {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data
      };
      return fetcher;
    }
  }
  function getSubmittingFetcher(submission, existingFetcher) {
    let fetcher = {
      state: "submitting",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data: existingFetcher ? existingFetcher.data : void 0
    };
    return fetcher;
  }
  function getDoneFetcher(data) {
    let fetcher = {
      state: "idle",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data
    };
    return fetcher;
  }
  function restoreAppliedTransitions(_window, transitions) {
    try {
      let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
      if (sessionPositions) {
        let json2 = JSON.parse(sessionPositions);
        for (let [k2, v2] of Object.entries(json2 || {})) {
          if (v2 && Array.isArray(v2)) {
            transitions.set(k2, new Set(v2 || []));
          }
        }
      }
    } catch (e2) {
    }
  }
  function persistAppliedTransitions(_window, transitions) {
    if (transitions.size > 0) {
      let json2 = {};
      for (let [k2, v2] of transitions) {
        json2[k2] = [...v2];
      }
      try {
        _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json2));
      } catch (error2) {
        warning(false, "Failed to save applied view transitions in sessionStorage (" + error2 + ").");
      }
    }
  }
  /**
   * React Router v6.27.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
  const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
  const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
  const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
  const RouteContext = /* @__PURE__ */ reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: false
  });
  const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
  function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null;
  }
  function useLocation() {
    !useInRouterContext() ? invariant(false) : void 0;
    return reactExports.useContext(LocationContext).location;
  }
  const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
  function useOutlet(context) {
    let outlet = reactExports.useContext(RouteContext).outlet;
    if (outlet) {
      return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
        value: context
      }, outlet);
    }
    return outlet;
  }
  function useRoutesImpl(routes, locationArg, dataRouterState, future) {
    !useInRouterContext() ? invariant(false) : void 0;
    let {
      navigator: navigator2
    } = reactExports.useContext(NavigationContext);
    let {
      matches: parentMatches
    } = reactExports.useContext(RouteContext);
    let routeMatch = parentMatches[parentMatches.length - 1];
    let parentParams = routeMatch ? routeMatch.params : {};
    routeMatch ? routeMatch.pathname : "/";
    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
    routeMatch && routeMatch.route;
    let locationFromContext = useLocation();
    let location2;
    if (locationArg) {
      var _parsedLocationArg$pa;
      let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
      location2 = parsedLocationArg;
    } else {
      location2 = locationFromContext;
    }
    let pathname = location2.pathname || "/";
    let remainingPathname = pathname;
    if (parentPathnameBase !== "/") {
      let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
      let segments = pathname.replace(/^\//, "").split("/");
      remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
    }
    let matches = matchRoutes(routes, {
      pathname: remainingPathname
    });
    let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
      params: Object.assign({}, parentParams, match.params),
      pathname: joinPaths([
        parentPathnameBase,
        // Re-encode pathnames that were decoded inside matchRoutes
        navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
      ]),
      pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
        parentPathnameBase,
        // Re-encode pathnames that were decoded inside matchRoutes
        navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
      ])
    })), parentMatches, dataRouterState, future);
    if (locationArg && renderedMatches) {
      return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        value: {
          location: _extends$1({
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default"
          }, location2),
          navigationType: Action.Pop
        }
      }, renderedMatches);
    }
    return renderedMatches;
  }
  function DefaultErrorComponent() {
    let error2 = useRouteError();
    let message = isRouteErrorResponse(error2) ? error2.status + " " + error2.statusText : error2 instanceof Error ? error2.message : JSON.stringify(error2);
    let stack = error2 instanceof Error ? error2.stack : null;
    let lightgrey = "rgba(200,200,200, 0.5)";
    let preStyles = {
      padding: "0.5rem",
      backgroundColor: lightgrey
    };
    let devInfo = null;
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
      style: {
        fontStyle: "italic"
      }
    }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
      style: preStyles
    }, stack) : null, devInfo);
  }
  const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
  class RenderErrorBoundary extends reactExports.Component {
    constructor(props) {
      super(props);
      this.state = {
        location: props.location,
        revalidation: props.revalidation,
        error: props.error
      };
    }
    static getDerivedStateFromError(error2) {
      return {
        error: error2
      };
    }
    static getDerivedStateFromProps(props, state) {
      if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
        return {
          error: props.error,
          location: props.location,
          revalidation: props.revalidation
        };
      }
      return {
        error: props.error !== void 0 ? props.error : state.error,
        location: state.location,
        revalidation: props.revalidation || state.revalidation
      };
    }
    componentDidCatch(error2, errorInfo) {
      console.error("React Router caught the following error during render", error2, errorInfo);
    }
    render() {
      return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
        value: this.props.routeContext
      }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
        value: this.state.error,
        children: this.props.component
      })) : this.props.children;
    }
  }
  function RenderedRoute(_ref) {
    let {
      routeContext,
      match,
      children
    } = _ref;
    let dataRouterContext = reactExports.useContext(DataRouterContext);
    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
      dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
    }
    return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: routeContext
    }, children);
  }
  function _renderMatches(matches, parentMatches, dataRouterState, future) {
    var _dataRouterState;
    if (parentMatches === void 0) {
      parentMatches = [];
    }
    if (dataRouterState === void 0) {
      dataRouterState = null;
    }
    if (future === void 0) {
      future = null;
    }
    if (matches == null) {
      var _future;
      if (!dataRouterState) {
        return null;
      }
      if (dataRouterState.errors) {
        matches = dataRouterState.matches;
      } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
        matches = dataRouterState.matches;
      } else {
        return null;
      }
    }
    let renderedMatches = matches;
    let errors2 = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
    if (errors2 != null) {
      let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors2 == null ? void 0 : errors2[m2.route.id]) !== void 0);
      !(errorIndex >= 0) ? invariant(false) : void 0;
      renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
    }
    let renderFallback = false;
    let fallbackIndex = -1;
    if (dataRouterState && future && future.v7_partialHydration) {
      for (let i2 = 0; i2 < renderedMatches.length; i2++) {
        let match = renderedMatches[i2];
        if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
          fallbackIndex = i2;
        }
        if (match.route.id) {
          let {
            loaderData,
            errors: errors3
          } = dataRouterState;
          let needsToRunLoader = match.route.loader && loaderData[match.route.id] === void 0 && (!errors3 || errors3[match.route.id] === void 0);
          if (match.route.lazy || needsToRunLoader) {
            renderFallback = true;
            if (fallbackIndex >= 0) {
              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
            } else {
              renderedMatches = [renderedMatches[0]];
            }
            break;
          }
        }
      }
    }
    return renderedMatches.reduceRight((outlet, match, index2) => {
      let error2;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error2 = errors2 && match.route.id ? errors2[match.route.id] : void 0;
        errorElement = match.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index2 === 0) {
            warningOnce("route-fallback", false);
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index2) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
      let getChildren = () => {
        let children;
        if (error2) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match.route.Component) {
          children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
        } else if (match.route.element) {
          children = match.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
          match,
          routeContext: {
            outlet,
            matches: matches2,
            isDataRoute: dataRouterState != null
          },
          children
        });
      };
      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
        location: dataRouterState.location,
        revalidation: dataRouterState.revalidation,
        component: errorElement,
        error: error2,
        children: getChildren(),
        routeContext: {
          outlet: null,
          matches: matches2,
          isDataRoute: true
        }
      }) : getChildren();
    }, null);
  }
  var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
    DataRouterStateHook2["UseBlocker"] = "useBlocker";
    DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
    DataRouterStateHook2["UseActionData"] = "useActionData";
    DataRouterStateHook2["UseRouteError"] = "useRouteError";
    DataRouterStateHook2["UseNavigation"] = "useNavigation";
    DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
    DataRouterStateHook2["UseMatches"] = "useMatches";
    DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
    DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
    DataRouterStateHook2["UseRouteId"] = "useRouteId";
    return DataRouterStateHook2;
  }(DataRouterStateHook$1 || {});
  function useDataRouterState(hookName) {
    let state = reactExports.useContext(DataRouterStateContext);
    !state ? invariant(false) : void 0;
    return state;
  }
  function useRouteContext(hookName) {
    let route = reactExports.useContext(RouteContext);
    !route ? invariant(false) : void 0;
    return route;
  }
  function useCurrentRouteId(hookName) {
    let route = useRouteContext();
    let thisRoute = route.matches[route.matches.length - 1];
    !thisRoute.route.id ? invariant(false) : void 0;
    return thisRoute.route.id;
  }
  function useLoaderData() {
    let state = useDataRouterState(DataRouterStateHook$1.UseLoaderData);
    let routeId = useCurrentRouteId(DataRouterStateHook$1.UseLoaderData);
    if (state.errors && state.errors[routeId] != null) {
      console.error("You cannot `useLoaderData` in an errorElement (routeId: " + routeId + ")");
      return void 0;
    }
    return state.loaderData[routeId];
  }
  function useRouteError() {
    var _state$errors;
    let error2 = reactExports.useContext(RouteErrorContext);
    let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
    let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
    if (error2 !== void 0) {
      return error2;
    }
    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
  }
  const alreadyWarned$1 = {};
  function warningOnce(key, cond, message) {
    if (!cond && !alreadyWarned$1[key]) {
      alreadyWarned$1[key] = true;
    }
  }
  function Outlet(props) {
    return useOutlet(props.context);
  }
  function Router(_ref5) {
    let {
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = Action.Pop,
      navigator: navigator2,
      static: staticProp = false,
      future
    } = _ref5;
    !!useInRouterContext() ? invariant(false) : void 0;
    let basename = basenameProp.replace(/^\/*/, "/");
    let navigationContext = reactExports.useMemo(() => ({
      basename,
      navigator: navigator2,
      static: staticProp,
      future: _extends$1({
        v7_relativeSplatPath: false
      }, future)
    }), [basename, future, navigator2, staticProp]);
    if (typeof locationProp === "string") {
      locationProp = parsePath(locationProp);
    }
    let {
      pathname = "/",
      search = "",
      hash = "",
      state = null,
      key = "default"
    } = locationProp;
    let locationContext = reactExports.useMemo(() => {
      let trailingPathname = stripBasename(pathname, basename);
      if (trailingPathname == null) {
        return null;
      }
      return {
        location: {
          pathname: trailingPathname,
          search,
          hash,
          state,
          key
        },
        navigationType
      };
    }, [basename, pathname, search, hash, state, key, navigationType]);
    if (locationContext == null) {
      return null;
    }
    return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
      value: navigationContext
    }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      children,
      value: locationContext
    }));
  }
  new Promise(() => {
  });
  function mapRouteProperties(route) {
    let updates = {
      // Note: this check also occurs in createRoutesFromChildren so update
      // there if you change this -- please and thank you!
      hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
    };
    if (route.Component) {
      Object.assign(updates, {
        element: /* @__PURE__ */ reactExports.createElement(route.Component),
        Component: void 0
      });
    }
    if (route.HydrateFallback) {
      Object.assign(updates, {
        hydrateFallbackElement: /* @__PURE__ */ reactExports.createElement(route.HydrateFallback),
        HydrateFallback: void 0
      });
    }
    if (route.ErrorBoundary) {
      Object.assign(updates, {
        errorElement: /* @__PURE__ */ reactExports.createElement(route.ErrorBoundary),
        ErrorBoundary: void 0
      });
    }
    return updates;
  }
  /**
   * React Router DOM v6.27.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  const REACT_ROUTER_VERSION = "6";
  try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION;
  } catch (e2) {
  }
  function createBrowserRouter(routes, opts) {
    return createRouter({
      basename: opts == null ? void 0 : opts.basename,
      future: _extends({}, opts == null ? void 0 : opts.future, {
        v7_prependBasename: true
      }),
      history: createBrowserHistory({
        window: opts == null ? void 0 : opts.window
      }),
      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
      routes,
      mapRouteProperties,
      dataStrategy: opts == null ? void 0 : opts.dataStrategy,
      patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,
      window: opts == null ? void 0 : opts.window
    }).initialize();
  }
  function parseHydrationData() {
    var _window;
    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
    if (state && state.errors) {
      state = _extends({}, state, {
        errors: deserializeErrors(state.errors)
      });
    }
    return state;
  }
  function deserializeErrors(errors2) {
    if (!errors2)
      return null;
    let entries = Object.entries(errors2);
    let serialized = {};
    for (let [key, val] of entries) {
      if (val && val.__type === "RouteErrorResponse") {
        serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
      } else if (val && val.__type === "Error") {
        if (val.__subType) {
          let ErrorConstructor = window[val.__subType];
          if (typeof ErrorConstructor === "function") {
            try {
              let error2 = new ErrorConstructor(val.message);
              error2.stack = "";
              serialized[key] = error2;
            } catch (e2) {
            }
          }
        }
        if (serialized[key] == null) {
          let error2 = new Error(val.message);
          error2.stack = "";
          serialized[key] = error2;
        }
      } else {
        serialized[key] = val;
      }
    }
    return serialized;
  }
  const ViewTransitionContext = /* @__PURE__ */ reactExports.createContext({
    isTransitioning: false
  });
  const FetchersContext = /* @__PURE__ */ reactExports.createContext(/* @__PURE__ */ new Map());
  const START_TRANSITION = "startTransition";
  const startTransitionImpl = React$2[START_TRANSITION];
  const FLUSH_SYNC = "flushSync";
  const flushSyncImpl = ReactDOM[FLUSH_SYNC];
  function startTransitionSafe(cb2) {
    if (startTransitionImpl) {
      startTransitionImpl(cb2);
    } else {
      cb2();
    }
  }
  function flushSyncSafe(cb2) {
    if (flushSyncImpl) {
      flushSyncImpl(cb2);
    } else {
      cb2();
    }
  }
  class Deferred {
    constructor() {
      this.status = "pending";
      this.promise = new Promise((resolve, reject) => {
        this.resolve = (value2) => {
          if (this.status === "pending") {
            this.status = "resolved";
            resolve(value2);
          }
        };
        this.reject = (reason) => {
          if (this.status === "pending") {
            this.status = "rejected";
            reject(reason);
          }
        };
      });
    }
  }
  function RouterProvider(_ref) {
    let {
      fallbackElement,
      router: router2,
      future
    } = _ref;
    let [state, setStateImpl] = reactExports.useState(router2.state);
    let [pendingState, setPendingState] = reactExports.useState();
    let [vtContext, setVtContext] = reactExports.useState({
      isTransitioning: false
    });
    let [renderDfd, setRenderDfd] = reactExports.useState();
    let [transition, setTransition] = reactExports.useState();
    let [interruption, setInterruption] = reactExports.useState();
    let fetcherData = reactExports.useRef(/* @__PURE__ */ new Map());
    let {
      v7_startTransition
    } = future || {};
    let optInStartTransition = reactExports.useCallback((cb2) => {
      if (v7_startTransition) {
        startTransitionSafe(cb2);
      } else {
        cb2();
      }
    }, [v7_startTransition]);
    let setState2 = reactExports.useCallback((newState, _ref2) => {
      let {
        deletedFetchers,
        flushSync,
        viewTransitionOpts
      } = _ref2;
      deletedFetchers.forEach((key) => fetcherData.current.delete(key));
      newState.fetchers.forEach((fetcher, key) => {
        if (fetcher.data !== void 0) {
          fetcherData.current.set(key, fetcher.data);
        }
      });
      let isViewTransitionUnavailable = router2.window == null || router2.window.document == null || typeof router2.window.document.startViewTransition !== "function";
      if (!viewTransitionOpts || isViewTransitionUnavailable) {
        if (flushSync) {
          flushSyncSafe(() => setStateImpl(newState));
        } else {
          optInStartTransition(() => setStateImpl(newState));
        }
        return;
      }
      if (flushSync) {
        flushSyncSafe(() => {
          if (transition) {
            renderDfd && renderDfd.resolve();
            transition.skipTransition();
          }
          setVtContext({
            isTransitioning: true,
            flushSync: true,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        });
        let t2 = router2.window.document.startViewTransition(() => {
          flushSyncSafe(() => setStateImpl(newState));
        });
        t2.finished.finally(() => {
          flushSyncSafe(() => {
            setRenderDfd(void 0);
            setTransition(void 0);
            setPendingState(void 0);
            setVtContext({
              isTransitioning: false
            });
          });
        });
        flushSyncSafe(() => setTransition(t2));
        return;
      }
      if (transition) {
        renderDfd && renderDfd.resolve();
        transition.skipTransition();
        setInterruption({
          state: newState,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      } else {
        setPendingState(newState);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      }
    }, [router2.window, transition, renderDfd, fetcherData, optInStartTransition]);
    reactExports.useLayoutEffect(() => router2.subscribe(setState2), [router2, setState2]);
    reactExports.useEffect(() => {
      if (vtContext.isTransitioning && !vtContext.flushSync) {
        setRenderDfd(new Deferred());
      }
    }, [vtContext]);
    reactExports.useEffect(() => {
      if (renderDfd && pendingState && router2.window) {
        let newState = pendingState;
        let renderPromise = renderDfd.promise;
        let transition2 = router2.window.document.startViewTransition(async () => {
          optInStartTransition(() => setStateImpl(newState));
          await renderPromise;
        });
        transition2.finished.finally(() => {
          setRenderDfd(void 0);
          setTransition(void 0);
          setPendingState(void 0);
          setVtContext({
            isTransitioning: false
          });
        });
        setTransition(transition2);
      }
    }, [optInStartTransition, pendingState, renderDfd, router2.window]);
    reactExports.useEffect(() => {
      if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
        renderDfd.resolve();
      }
    }, [renderDfd, transition, state.location, pendingState]);
    reactExports.useEffect(() => {
      if (!vtContext.isTransitioning && interruption) {
        setPendingState(interruption.state);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: interruption.currentLocation,
          nextLocation: interruption.nextLocation
        });
        setInterruption(void 0);
      }
    }, [vtContext.isTransitioning, interruption]);
    reactExports.useEffect(() => {
    }, []);
    let navigator2 = reactExports.useMemo(() => {
      return {
        createHref: router2.createHref,
        encodeLocation: router2.encodeLocation,
        go: (n2) => router2.navigate(n2),
        push: (to, state2, opts) => router2.navigate(to, {
          state: state2,
          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
        }),
        replace: (to, state2, opts) => router2.navigate(to, {
          replace: true,
          state: state2,
          preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
        })
      };
    }, [router2]);
    let basename = router2.basename || "/";
    let dataRouterContext = reactExports.useMemo(() => ({
      router: router2,
      navigator: navigator2,
      static: false,
      basename
    }), [router2, navigator2, basename]);
    let routerFuture = reactExports.useMemo(() => ({
      v7_relativeSplatPath: router2.future.v7_relativeSplatPath
    }), [router2.future.v7_relativeSplatPath]);
    return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
      value: dataRouterContext
    }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
      value: state
    }, /* @__PURE__ */ reactExports.createElement(FetchersContext.Provider, {
      value: fetcherData.current
    }, /* @__PURE__ */ reactExports.createElement(ViewTransitionContext.Provider, {
      value: vtContext
    }, /* @__PURE__ */ reactExports.createElement(Router, {
      basename,
      location: state.location,
      navigationType: state.historyAction,
      navigator: navigator2,
      future: routerFuture
    }, state.initialized || router2.future.v7_partialHydration ? /* @__PURE__ */ reactExports.createElement(MemoizedDataRoutes, {
      routes: router2.routes,
      future: router2.future,
      state
    }) : fallbackElement))))), null);
  }
  const MemoizedDataRoutes = /* @__PURE__ */ reactExports.memo(DataRoutes);
  function DataRoutes(_ref3) {
    let {
      routes,
      future,
      state
    } = _ref3;
    return useRoutesImpl(routes, void 0, state, future);
  }
  var DataRouterHook;
  (function(DataRouterHook2) {
    DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
    DataRouterHook2["UseSubmit"] = "useSubmit";
    DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
    DataRouterHook2["UseFetcher"] = "useFetcher";
    DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
  })(DataRouterHook || (DataRouterHook = {}));
  var DataRouterStateHook;
  (function(DataRouterStateHook2) {
    DataRouterStateHook2["UseFetcher"] = "useFetcher";
    DataRouterStateHook2["UseFetchers"] = "useFetchers";
    DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
  })(DataRouterStateHook || (DataRouterStateHook = {}));
  const App = "";
  const index$1 = "";
  const components = "";
  const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
  Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  const ERROR_PACKET = { type: "error", data: "parser error" };
  const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
  const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
  const isView$1 = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
  };
  const encodePacket = ({ type: type2, data }, supportsBinary, callback) => {
    if (withNativeBlob$1 && data instanceof Blob) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(data, callback);
      }
    } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(new Blob([data]), callback);
      }
    }
    return callback(PACKET_TYPES[type2] + (data || ""));
  };
  const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function() {
      const content = fileReader.result.split(",")[1];
      callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
  };
  function toArray$2(data) {
    if (data instanceof Uint8Array) {
      return data;
    } else if (data instanceof ArrayBuffer) {
      return new Uint8Array(data);
    } else {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
  }
  let TEXT_ENCODER;
  function encodePacketToBinary(packet, callback) {
    if (withNativeBlob$1 && packet.data instanceof Blob) {
      return packet.data.arrayBuffer().then(toArray$2).then(callback);
    } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
      return callback(toArray$2(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
      if (!TEXT_ENCODER) {
        TEXT_ENCODER = new TextEncoder();
      }
      callback(TEXT_ENCODER.encode(encoded));
    });
  }
  const chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (let i2 = 0; i2 < chars$1.length; i2++) {
    lookup$1[chars$1.charCodeAt(i2)] = i2;
  }
  const decode$3 = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i2 = 0; i2 < len; i2 += 4) {
      encoded1 = lookup$1[base64.charCodeAt(i2)];
      encoded2 = lookup$1[base64.charCodeAt(i2 + 1)];
      encoded3 = lookup$1[base64.charCodeAt(i2 + 2)];
      encoded4 = lookup$1[base64.charCodeAt(i2 + 3)];
      bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
  };
  const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
  const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }
    const type2 = encodedPacket.charAt(0);
    if (type2 === "b") {
      return {
        type: "message",
        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
      };
    }
    const packetType = PACKET_TYPES_REVERSE[type2];
    if (!packetType) {
      return ERROR_PACKET;
    }
    return encodedPacket.length > 1 ? {
      type: PACKET_TYPES_REVERSE[type2],
      data: encodedPacket.substring(1)
    } : {
      type: PACKET_TYPES_REVERSE[type2]
    };
  };
  const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer$1) {
      const decoded = decode$3(data);
      return mapBinary(decoded, binaryType);
    } else {
      return { base64: true, data };
    }
  };
  const mapBinary = (data, binaryType) => {
    switch (binaryType) {
      case "blob":
        if (data instanceof Blob) {
          return data;
        } else {
          return new Blob([data]);
        }
      case "arraybuffer":
      default:
        if (data instanceof ArrayBuffer) {
          return data;
        } else {
          return data.buffer;
        }
    }
  };
  const SEPARATOR = String.fromCharCode(30);
  const encodePayload = (packets, callback) => {
    const length2 = packets.length;
    const encodedPackets = new Array(length2);
    let count = 0;
    packets.forEach((packet, i2) => {
      encodePacket(packet, false, (encodedPacket) => {
        encodedPackets[i2] = encodedPacket;
        if (++count === length2) {
          callback(encodedPackets.join(SEPARATOR));
        }
      });
    });
  };
  const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  };
  function createPacketEncoderStream() {
    return new TransformStream({
      transform(packet, controller) {
        encodePacketToBinary(packet, (encodedPacket) => {
          const payloadLength = encodedPacket.length;
          let header2;
          if (payloadLength < 126) {
            header2 = new Uint8Array(1);
            new DataView(header2.buffer).setUint8(0, payloadLength);
          } else if (payloadLength < 65536) {
            header2 = new Uint8Array(3);
            const view = new DataView(header2.buffer);
            view.setUint8(0, 126);
            view.setUint16(1, payloadLength);
          } else {
            header2 = new Uint8Array(9);
            const view = new DataView(header2.buffer);
            view.setUint8(0, 127);
            view.setBigUint64(1, BigInt(payloadLength));
          }
          if (packet.data && typeof packet.data !== "string") {
            header2[0] |= 128;
          }
          controller.enqueue(header2);
          controller.enqueue(encodedPacket);
        });
      }
    });
  }
  let TEXT_DECODER;
  function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
  }
  function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
      return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j2 = 0;
    for (let i2 = 0; i2 < size; i2++) {
      buffer[i2] = chunks[0][j2++];
      if (j2 === chunks[0].length) {
        chunks.shift();
        j2 = 0;
      }
    }
    if (chunks.length && j2 < chunks[0].length) {
      chunks[0] = chunks[0].slice(j2);
    }
    return buffer;
  }
  function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
      TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0;
    let expectedLength = -1;
    let isBinary2 = false;
    return new TransformStream({
      transform(chunk, controller) {
        chunks.push(chunk);
        while (true) {
          if (state === 0) {
            if (totalLength(chunks) < 1) {
              break;
            }
            const header2 = concatChunks(chunks, 1);
            isBinary2 = (header2[0] & 128) === 128;
            expectedLength = header2[0] & 127;
            if (expectedLength < 126) {
              state = 3;
            } else if (expectedLength === 126) {
              state = 1;
            } else {
              state = 2;
            }
          } else if (state === 1) {
            if (totalLength(chunks) < 2) {
              break;
            }
            const headerArray = concatChunks(chunks, 2);
            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
            state = 3;
          } else if (state === 2) {
            if (totalLength(chunks) < 8) {
              break;
            }
            const headerArray = concatChunks(chunks, 8);
            const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
            const n2 = view.getUint32(0);
            if (n2 > Math.pow(2, 53 - 32) - 1) {
              controller.enqueue(ERROR_PACKET);
              break;
            }
            expectedLength = n2 * Math.pow(2, 32) + view.getUint32(4);
            state = 3;
          } else {
            if (totalLength(chunks) < expectedLength) {
              break;
            }
            const data = concatChunks(chunks, expectedLength);
            controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
            state = 0;
          }
          if (expectedLength === 0 || expectedLength > maxPayload) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
        }
      }
    });
  }
  const protocol$1 = 4;
  function Emitter(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }
  Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
    return this;
  };
  Emitter.prototype.once = function(event, fn) {
    function on2() {
      this.off(event, on2);
      fn.apply(this, arguments);
    }
    on2.fn = fn;
    this.on(event, on2);
    return this;
  };
  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks["$" + event];
    if (!callbacks)
      return this;
    if (1 == arguments.length) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb2;
    for (var i2 = 0; i2 < callbacks.length; i2++) {
      cb2 = callbacks[i2];
      if (cb2 === fn || cb2.fn === fn) {
        callbacks.splice(i2, 1);
        break;
      }
    }
    if (callbacks.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
        callbacks[i2].apply(this, args);
      }
    }
    return this;
  };
  Emitter.prototype.emitReserved = Emitter.prototype.emit;
  Emitter.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
  const globalThisShim = (() => {
    if (typeof self !== "undefined") {
      return self;
    } else if (typeof window !== "undefined") {
      return window;
    } else {
      return Function("return this")();
    }
  })();
  function pick(obj, ...attr) {
    return attr.reduce((acc, k2) => {
      if (obj.hasOwnProperty(k2)) {
        acc[k2] = obj[k2];
      }
      return acc;
    }, {});
  }
  const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
  const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
  function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
      obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
      obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
    } else {
      obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
      obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
    }
  }
  const BASE64_OVERHEAD = 1.33;
  function byteLength(obj) {
    if (typeof obj === "string") {
      return utf8Length(obj);
    }
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
  }
  function utf8Length(str2) {
    let c2 = 0, length2 = 0;
    for (let i2 = 0, l2 = str2.length; i2 < l2; i2++) {
      c2 = str2.charCodeAt(i2);
      if (c2 < 128) {
        length2 += 1;
      } else if (c2 < 2048) {
        length2 += 2;
      } else if (c2 < 55296 || c2 >= 57344) {
        length2 += 3;
      } else {
        i2++;
        length2 += 4;
      }
    }
    return length2;
  }
  function encode$5(obj) {
    let str2 = "";
    for (let i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        if (str2.length)
          str2 += "&";
        str2 += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
      }
    }
    return str2;
  }
  function decode$2(qs) {
    let qry = {};
    let pairs2 = qs.split("&");
    for (let i2 = 0, l2 = pairs2.length; i2 < l2; i2++) {
      let pair = pairs2[i2].split("=");
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  }
  class TransportError extends Error {
    constructor(reason, description, context) {
      super(reason);
      this.description = description;
      this.context = context;
      this.type = "TransportError";
    }
  }
  class Transport extends Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
      super();
      this.writable = false;
      installTimerFunctions(this, opts);
      this.opts = opts;
      this.query = opts.query;
      this.socket = opts.socket;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
      super.emitReserved("error", new TransportError(reason, description, context));
      return this;
    }
    /**
     * Opens the transport.
     */
    open() {
      this.readyState = "opening";
      this.doOpen();
      return this;
    }
    /**
     * Closes the transport.
     */
    close() {
      if (this.readyState === "opening" || this.readyState === "open") {
        this.doClose();
        this.onClose();
      }
      return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
      if (this.readyState === "open") {
        this.write(packets);
      }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
      this.readyState = "open";
      this.writable = true;
      super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
      const packet = decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
      super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
      this.readyState = "closed";
      super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) {
    }
    createUri(schema2, query = {}) {
      return schema2 + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
    }
    _hostname() {
      const hostname = this.opts.hostname;
      return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
      if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
        return ":" + this.opts.port;
      } else {
        return "";
      }
    }
    _query(query) {
      const encodedQuery = encode$5(query);
      return encodedQuery.length ? "?" + encodedQuery : "";
    }
  }
  const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map$2 = {};
  let seed = 0, i$3 = 0, prev;
  function encode$4(num) {
    let encoded = "";
    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
  }
  function yeast() {
    const now = encode$4(+/* @__PURE__ */ new Date());
    if (now !== prev)
      return seed = 0, prev = now;
    return now + "." + encode$4(seed++);
  }
  for (; i$3 < length; i$3++)
    map$2[alphabet[i$3]] = i$3;
  let value = false;
  try {
    value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
  } catch (err) {
  }
  const hasCORS = value;
  function XHR(opts) {
    const xdomain = opts.xdomain;
    try {
      if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e2) {
    }
    if (!xdomain) {
      try {
        return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (e2) {
      }
    }
  }
  function createCookieJar() {
  }
  function empty() {
  }
  const hasXHR2 = function() {
    const xhr = new XHR({
      xdomain: false
    });
    return null != xhr.responseType;
  }();
  class Polling extends Transport {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
      super(opts);
      this.polling = false;
      if (typeof location !== "undefined") {
        const isSSL = "https:" === location.protocol;
        let port = location.port;
        if (!port) {
          port = isSSL ? "443" : "80";
        }
        this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      }
      const forceBase64 = opts && opts.forceBase64;
      this.supportsBinary = hasXHR2 && !forceBase64;
      if (this.opts.withCredentials) {
        this.cookieJar = createCookieJar();
      }
    }
    get name() {
      return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
      this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
      this.readyState = "pausing";
      const pause = () => {
        this.readyState = "paused";
        onPause();
      };
      if (this.polling || !this.writable) {
        let total = 0;
        if (this.polling) {
          total++;
          this.once("pollComplete", function() {
            --total || pause();
          });
        }
        if (!this.writable) {
          total++;
          this.once("drain", function() {
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    poll() {
      this.polling = true;
      this.doPoll();
      this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
      const callback = (packet) => {
        if ("opening" === this.readyState && packet.type === "open") {
          this.onOpen();
        }
        if ("close" === packet.type) {
          this.onClose({ description: "transport closed by the server" });
          return false;
        }
        this.onPacket(packet);
      };
      decodePayload(data, this.socket.binaryType).forEach(callback);
      if ("closed" !== this.readyState) {
        this.polling = false;
        this.emitReserved("pollComplete");
        if ("open" === this.readyState) {
          this.poll();
        }
      }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
      const close = () => {
        this.write([{ type: "close" }]);
      };
      if ("open" === this.readyState) {
        close();
      } else {
        this.once("open", close);
      }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
      this.writable = false;
      encodePayload(packets, (data) => {
        this.doWrite(data, () => {
          this.writable = true;
          this.emitReserved("drain");
        });
      });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
      const schema2 = this.opts.secure ? "https" : "http";
      const query = this.query || {};
      if (false !== this.opts.timestampRequests) {
        query[this.opts.timestampParam] = yeast();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      return this.createUri(schema2, query);
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @private
     */
    request(opts = {}) {
      Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
      return new Request$1(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
      const req = this.request({
        method: "POST",
        data
      });
      req.on("success", fn);
      req.on("error", (xhrStatus, context) => {
        this.onError("xhr post error", xhrStatus, context);
      });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
      const req = this.request();
      req.on("data", this.onData.bind(this));
      req.on("error", (xhrStatus, context) => {
        this.onError("xhr poll error", xhrStatus, context);
      });
      this.pollXhr = req;
    }
  }
  let Request$1 = class Request2 extends Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(uri, opts) {
      super();
      installTimerFunctions(this, opts);
      this.opts = opts;
      this.method = opts.method || "GET";
      this.uri = uri;
      this.data = void 0 !== opts.data ? opts.data : null;
      this.create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    create() {
      var _a2;
      const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      opts.xdomain = !!this.opts.xd;
      const xhr = this.xhr = new XHR(opts);
      try {
        xhr.open(this.method, this.uri, true);
        try {
          if (this.opts.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (let i2 in this.opts.extraHeaders) {
              if (this.opts.extraHeaders.hasOwnProperty(i2)) {
                xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
              }
            }
          }
        } catch (e2) {
        }
        if ("POST" === this.method) {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e2) {
          }
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e2) {
        }
        (_a2 = this.opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.addCookies(xhr);
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.opts.withCredentials;
        }
        if (this.opts.requestTimeout) {
          xhr.timeout = this.opts.requestTimeout;
        }
        xhr.onreadystatechange = () => {
          var _a3;
          if (xhr.readyState === 3) {
            (_a3 = this.opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.parseCookies(xhr);
          }
          if (4 !== xhr.readyState)
            return;
          if (200 === xhr.status || 1223 === xhr.status) {
            this.onLoad();
          } else {
            this.setTimeoutFn(() => {
              this.onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
        xhr.send(this.data);
      } catch (e2) {
        this.setTimeoutFn(() => {
          this.onError(e2);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this.index = Request2.requestsCount++;
        Request2.requests[this.index] = this;
      }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    onError(err) {
      this.emitReserved("error", err, this.xhr);
      this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    cleanup(fromError) {
      if ("undefined" === typeof this.xhr || null === this.xhr) {
        return;
      }
      this.xhr.onreadystatechange = empty;
      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e2) {
        }
      }
      if (typeof document !== "undefined") {
        delete Request2.requests[this.index];
      }
      this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    onLoad() {
      const data = this.xhr.responseText;
      if (data !== null) {
        this.emitReserved("data", data);
        this.emitReserved("success");
        this.cleanup();
      }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
      this.cleanup();
    }
  };
  Request$1.requestsCount = 0;
  Request$1.requests = {};
  if (typeof document !== "undefined") {
    if (typeof attachEvent === "function") {
      attachEvent("onunload", unloadHandler);
    } else if (typeof addEventListener === "function") {
      const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
      addEventListener(terminationEvent, unloadHandler, false);
    }
  }
  function unloadHandler() {
    for (let i2 in Request$1.requests) {
      if (Request$1.requests.hasOwnProperty(i2)) {
        Request$1.requests[i2].abort();
      }
    }
  }
  const nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
      return (cb2) => Promise.resolve().then(cb2);
    } else {
      return (cb2, setTimeoutFn) => setTimeoutFn(cb2, 0);
    }
  })();
  const WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
  const usingBrowserWebSocket = true;
  const defaultBinaryType = "arraybuffer";
  const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
  class WS extends Transport {
    /**
     * WebSocket transport constructor.
     *
     * @param {Object} opts - connection options
     * @protected
     */
    constructor(opts) {
      super(opts);
      this.supportsBinary = !opts.forceBase64;
    }
    get name() {
      return "websocket";
    }
    doOpen() {
      if (!this.check()) {
        return;
      }
      const uri = this.uri();
      const protocols = this.opts.protocols;
      const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }
      try {
        this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
      } catch (err) {
        return this.emitReserved("error", err);
      }
      this.ws.binaryType = this.socket.binaryType;
      this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
      this.ws.onopen = () => {
        if (this.opts.autoUnref) {
          this.ws._socket.unref();
        }
        this.onOpen();
      };
      this.ws.onclose = (closeEvent) => this.onClose({
        description: "websocket connection closed",
        context: closeEvent
      });
      this.ws.onmessage = (ev) => this.onData(ev.data);
      this.ws.onerror = (e2) => this.onError("websocket error", e2);
    }
    write(packets) {
      this.writable = false;
      for (let i2 = 0; i2 < packets.length; i2++) {
        const packet = packets[i2];
        const lastPacket = i2 === packets.length - 1;
        encodePacket(packet, this.supportsBinary, (data) => {
          const opts = {};
          try {
            if (usingBrowserWebSocket) {
              this.ws.send(data);
            }
          } catch (e2) {
          }
          if (lastPacket) {
            nextTick(() => {
              this.writable = true;
              this.emitReserved("drain");
            }, this.setTimeoutFn);
          }
        });
      }
    }
    doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
      const schema2 = this.opts.secure ? "wss" : "ws";
      const query = this.query || {};
      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = yeast();
      }
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      return this.createUri(schema2, query);
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @private
     */
    check() {
      return !!WebSocket;
    }
  }
  class WT extends Transport {
    get name() {
      return "webtransport";
    }
    doOpen() {
      if (typeof WebTransport !== "function") {
        return;
      }
      this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
      this.transport.closed.then(() => {
        this.onClose();
      }).catch((err) => {
        this.onError("webtransport error", err);
      });
      this.transport.ready.then(() => {
        this.transport.createBidirectionalStream().then((stream) => {
          const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
          const reader = stream.readable.pipeThrough(decoderStream).getReader();
          const encoderStream = createPacketEncoderStream();
          encoderStream.readable.pipeTo(stream.writable);
          this.writer = encoderStream.writable.getWriter();
          const read = () => {
            reader.read().then(({ done, value: value2 }) => {
              if (done) {
                return;
              }
              this.onPacket(value2);
              read();
            }).catch((err) => {
            });
          };
          read();
          const packet = { type: "open" };
          if (this.query.sid) {
            packet.data = `{"sid":"${this.query.sid}"}`;
          }
          this.writer.write(packet).then(() => this.onOpen());
        });
      });
    }
    write(packets) {
      this.writable = false;
      for (let i2 = 0; i2 < packets.length; i2++) {
        const packet = packets[i2];
        const lastPacket = i2 === packets.length - 1;
        this.writer.write(packet).then(() => {
          if (lastPacket) {
            nextTick(() => {
              this.writable = true;
              this.emitReserved("drain");
            }, this.setTimeoutFn);
          }
        });
      }
    }
    doClose() {
      var _a2;
      (_a2 = this.transport) === null || _a2 === void 0 ? void 0 : _a2.close();
    }
  }
  const transports = {
    websocket: WS,
    webtransport: WT,
    polling: Polling
  };
  const re$1 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  const parts = [
    "source",
    "protocol",
    "authority",
    "userInfo",
    "user",
    "password",
    "host",
    "port",
    "relative",
    "path",
    "directory",
    "file",
    "query",
    "anchor"
  ];
  function parse$1(str2) {
    if (str2.length > 2e3) {
      throw "URI too long";
    }
    const src = str2, b2 = str2.indexOf("["), e2 = str2.indexOf("]");
    if (b2 != -1 && e2 != -1) {
      str2 = str2.substring(0, b2) + str2.substring(b2, e2).replace(/:/g, ";") + str2.substring(e2, str2.length);
    }
    let m2 = re$1.exec(str2 || ""), uri = {}, i2 = 14;
    while (i2--) {
      uri[parts[i2]] = m2[i2] || "";
    }
    if (b2 != -1 && e2 != -1) {
      uri.source = src;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
      uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
      uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri["path"]);
    uri.queryKey = queryKey(uri, uri["query"]);
    return uri;
  }
  function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == "/" || path.length === 0) {
      names.splice(0, 1);
    }
    if (path.slice(-1) == "/") {
      names.splice(names.length - 1, 1);
    }
    return names;
  }
  function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
      if ($1) {
        data[$1] = $2;
      }
    });
    return data;
  }
  let Socket$2 = class Socket2 extends Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts = {}) {
      super();
      this.binaryType = defaultBinaryType;
      this.writeBuffer = [];
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = null;
      }
      if (uri) {
        uri = parse$1(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === "https" || uri.protocol === "wss";
        opts.port = uri.port;
        if (uri.query)
          opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parse$1(opts.host).host;
      }
      installTimerFunctions(this, opts);
      this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
      if (opts.hostname && !opts.port) {
        opts.port = this.secure ? "443" : "80";
      }
      this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
      this.transports = opts.transports || [
        "polling",
        "websocket",
        "webtransport"
      ];
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.opts = Object.assign({
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        timestampParam: "t",
        rememberUpgrade: false,
        addTrailingSlash: true,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {},
        closeOnBeforeunload: false
      }, opts);
      this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
      if (typeof this.opts.query === "string") {
        this.opts.query = decode$2(this.opts.query);
      }
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;
      this.pingTimeoutTimer = null;
      if (typeof addEventListener === "function") {
        if (this.opts.closeOnBeforeunload) {
          this.beforeunloadEventListener = () => {
            if (this.transport) {
              this.transport.removeAllListeners();
              this.transport.close();
            }
          };
          addEventListener("beforeunload", this.beforeunloadEventListener, false);
        }
        if (this.hostname !== "localhost") {
          this.offlineEventListener = () => {
            this.onClose("transport close", {
              description: "network connection lost"
            });
          };
          addEventListener("offline", this.offlineEventListener, false);
        }
      }
      this.open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name2) {
      const query = Object.assign({}, this.opts.query);
      query.EIO = protocol$1;
      query.transport = name2;
      if (this.id)
        query.sid = this.id;
      const opts = Object.assign({}, this.opts, {
        query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[name2]);
      return new transports[name2](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    open() {
      let transport;
      if (this.opts.rememberUpgrade && Socket2.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport = "websocket";
      } else if (0 === this.transports.length) {
        this.setTimeoutFn(() => {
          this.emitReserved("error", "No transports available");
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }
      this.readyState = "opening";
      try {
        transport = this.createTransport(transport);
      } catch (e2) {
        this.transports.shift();
        this.open();
        return;
      }
      transport.open();
      this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport) {
      if (this.transport) {
        this.transport.removeAllListeners();
      }
      this.transport = transport;
      transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    probe(name2) {
      let transport = this.createTransport(name2);
      let failed = false;
      Socket2.priorWebsocketSuccess = false;
      const onTransportOpen = () => {
        if (failed)
          return;
        transport.send([{ type: "ping", data: "probe" }]);
        transport.once("packet", (msg) => {
          if (failed)
            return;
          if ("pong" === msg.type && "probe" === msg.data) {
            this.upgrading = true;
            this.emitReserved("upgrading", transport);
            if (!transport)
              return;
            Socket2.priorWebsocketSuccess = "websocket" === transport.name;
            this.transport.pause(() => {
              if (failed)
                return;
              if ("closed" === this.readyState)
                return;
              cleanup();
              this.setTransport(transport);
              transport.send([{ type: "upgrade" }]);
              this.emitReserved("upgrade", transport);
              transport = null;
              this.upgrading = false;
              this.flush();
            });
          } else {
            const err = new Error("probe error");
            err.transport = transport.name;
            this.emitReserved("upgradeError", err);
          }
        });
      };
      function freezeTransport() {
        if (failed)
          return;
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      const onerror = (err) => {
        const error2 = new Error("probe error: " + err);
        error2.transport = transport.name;
        freezeTransport();
        this.emitReserved("upgradeError", error2);
      };
      function onTransportClose() {
        onerror("transport closed");
      }
      function onclose() {
        onerror("socket closed");
      }
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          freezeTransport();
        }
      }
      const cleanup = () => {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        this.off("close", onclose);
        this.off("upgrading", onupgrade);
      };
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      if (this.upgrades.indexOf("webtransport") !== -1 && name2 !== "webtransport") {
        this.setTimeoutFn(() => {
          if (!failed) {
            transport.open();
          }
        }, 200);
      } else {
        transport.open();
      }
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
      this.readyState = "open";
      Socket2.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emitReserved("open");
      this.flush();
      if ("open" === this.readyState && this.opts.upgrade) {
        let i2 = 0;
        const l2 = this.upgrades.length;
        for (; i2 < l2; i2++) {
          this.probe(this.upgrades[i2]);
        }
      }
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        this.emitReserved("packet", packet);
        this.emitReserved("heartbeat");
        this.resetPingTimeout();
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this.sendPacket("pong");
            this.emitReserved("ping");
            this.emitReserved("pong");
            break;
          case "error":
            const err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;
          case "message":
            this.emitReserved("data", packet.data);
            this.emitReserved("message", packet.data);
            break;
        }
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data) {
      this.emitReserved("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.maxPayload = data.maxPayload;
      this.onOpen();
      if ("closed" === this.readyState)
        return;
      this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    resetPingTimeout() {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.pingTimeoutTimer = this.setTimeoutFn(() => {
        this.onClose("ping timeout");
      }, this.pingInterval + this.pingTimeout);
      if (this.opts.autoUnref) {
        this.pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    onDrain() {
      this.writeBuffer.splice(0, this.prevBufferLen);
      this.prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emitReserved("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        const packets = this.getWritablePackets();
        this.transport.send(packets);
        this.prevBufferLen = packets.length;
        this.emitReserved("flush");
      }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    getWritablePackets() {
      const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
      if (!shouldCheckPayloadSize) {
        return this.writeBuffer;
      }
      let payloadSize = 1;
      for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
        const data = this.writeBuffer[i2].data;
        if (data) {
          payloadSize += byteLength(data);
        }
        if (i2 > 0 && payloadSize > this.maxPayload) {
          return this.writeBuffer.slice(0, i2);
        }
        payloadSize += 2;
      }
      return this.writeBuffer;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    send(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    sendPacket(type2, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = void 0;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      const packet = {
        type: type2,
        data,
        options
      };
      this.emitReserved("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn)
        this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
      const close = () => {
        this.onClose("forced close");
        this.transport.close();
      };
      const cleanupAndClose = () => {
        this.off("upgrade", cleanupAndClose);
        this.off("upgradeError", cleanupAndClose);
        close();
      };
      const waitForUpgrade = () => {
        this.once("upgrade", cleanupAndClose);
        this.once("upgradeError", cleanupAndClose);
      };
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", () => {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    onError(err) {
      Socket2.priorWebsocketSuccess = false;
      this.emitReserved("error", err);
      this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    onClose(reason, description) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.transport.removeAllListeners("close");
        this.transport.close();
        this.transport.removeAllListeners();
        if (typeof removeEventListener === "function") {
          removeEventListener("beforeunload", this.beforeunloadEventListener, false);
          removeEventListener("offline", this.offlineEventListener, false);
        }
        this.readyState = "closed";
        this.id = null;
        this.emitReserved("close", reason, description);
        this.writeBuffer = [];
        this.prevBufferLen = 0;
      }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    filterUpgrades(upgrades) {
      const filteredUpgrades = [];
      let i2 = 0;
      const j2 = upgrades.length;
      for (; i2 < j2; i2++) {
        if (~this.transports.indexOf(upgrades[i2]))
          filteredUpgrades.push(upgrades[i2]);
      }
      return filteredUpgrades;
    }
  };
  Socket$2.protocol = protocol$1;
  function url(uri, path = "", loc) {
    let obj = uri;
    loc = loc || typeof location !== "undefined" && location;
    if (null == uri)
      uri = loc.protocol + "//" + loc.host;
    if (typeof uri === "string") {
      if ("/" === uri.charAt(0)) {
        if ("/" === uri.charAt(1)) {
          uri = loc.protocol + uri;
        } else {
          uri = loc.host + uri;
        }
      }
      if (!/^(https?|wss?):\/\//.test(uri)) {
        if ("undefined" !== typeof loc) {
          uri = loc.protocol + "//" + uri;
        } else {
          uri = "https://" + uri;
        }
      }
      obj = parse$1(uri);
    }
    if (!obj.port) {
      if (/^(http|ws)$/.test(obj.protocol)) {
        obj.port = "80";
      } else if (/^(http|ws)s$/.test(obj.protocol)) {
        obj.port = "443";
      }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
  }
  const withNativeArrayBuffer = typeof ArrayBuffer === "function";
  const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };
  const toString$1 = Object.prototype.toString;
  const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString$1.call(Blob) === "[object BlobConstructor]";
  const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString$1.call(File) === "[object FileConstructor]";
  function isBinary$1(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {
        if (hasBinary(obj[i2])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary$1(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }
    return false;
  }
  function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length;
    return { packet: pack, buffers };
  }
  function _deconstructPacket(data, buffers) {
    if (!data)
      return data;
    if (isBinary$1(data)) {
      const placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      const newData = new Array(data.length);
      for (let i2 = 0; i2 < data.length; i2++) {
        newData[i2] = _deconstructPacket(data[i2], buffers);
      }
      return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
      const newData = {};
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
      }
      return newData;
    }
    return data;
  }
  function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments;
    return packet;
  }
  function _reconstructPacket(data, buffers) {
    if (!data)
      return data;
    if (data && data._placeholder === true) {
      const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
      if (isIndexValid) {
        return buffers[data.num];
      } else {
        throw new Error("illegal attachments");
      }
    } else if (Array.isArray(data)) {
      for (let i2 = 0; i2 < data.length; i2++) {
        data[i2] = _reconstructPacket(data[i2], buffers);
      }
    } else if (typeof data === "object") {
      for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
    }
    return data;
  }
  const RESERVED_EVENTS$1 = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
    // used by the Node.js EventEmitter
  ];
  const protocol = 5;
  var PacketType;
  (function(PacketType2) {
    PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
    PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
    PacketType2[PacketType2["ACK"] = 3] = "ACK";
    PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType || (PacketType = {}));
  class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
      this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (hasBinary(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
      let str2 = "" + obj.type;
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str2 += obj.attachments + "-";
      }
      if (obj.nsp && "/" !== obj.nsp) {
        str2 += obj.nsp + ",";
      }
      if (null != obj.id) {
        str2 += obj.id;
      }
      if (null != obj.data) {
        str2 += JSON.stringify(obj.data, this.replacer);
      }
      return str2;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
      const deconstruction = deconstructPacket(obj);
      const pack = this.encodeAsString(deconstruction.packet);
      const buffers = deconstruction.buffers;
      buffers.unshift(pack);
      return buffers;
    }
  }
  function isObject$6(value2) {
    return Object.prototype.toString.call(value2) === "[object Object]";
  }
  class Decoder extends Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
      super();
      this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
      let packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
          this.reconstructor = new BinaryReconstructor(packet);
          if (packet.attachments === 0) {
            super.emitReserved("decoded", packet);
          }
        } else {
          super.emitReserved("decoded", packet);
        }
      } else if (isBinary$1(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            super.emitReserved("decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str2) {
      let i2 = 0;
      const p2 = {
        type: Number(str2.charAt(0))
      };
      if (PacketType[p2.type] === void 0) {
        throw new Error("unknown packet type " + p2.type);
      }
      if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
        const start = i2 + 1;
        while (str2.charAt(++i2) !== "-" && i2 != str2.length) {
        }
        const buf = str2.substring(start, i2);
        if (buf != Number(buf) || str2.charAt(i2) !== "-") {
          throw new Error("Illegal attachments");
        }
        p2.attachments = Number(buf);
      }
      if ("/" === str2.charAt(i2 + 1)) {
        const start = i2 + 1;
        while (++i2) {
          const c2 = str2.charAt(i2);
          if ("," === c2)
            break;
          if (i2 === str2.length)
            break;
        }
        p2.nsp = str2.substring(start, i2);
      } else {
        p2.nsp = "/";
      }
      const next = str2.charAt(i2 + 1);
      if ("" !== next && Number(next) == next) {
        const start = i2 + 1;
        while (++i2) {
          const c2 = str2.charAt(i2);
          if (null == c2 || Number(c2) != c2) {
            --i2;
            break;
          }
          if (i2 === str2.length)
            break;
        }
        p2.id = Number(str2.substring(start, i2 + 1));
      }
      if (str2.charAt(++i2)) {
        const payload = this.tryParse(str2.substr(i2));
        if (Decoder.isPayloadValid(p2.type, payload)) {
          p2.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      return p2;
    }
    tryParse(str2) {
      try {
        return JSON.parse(str2, this.reviver);
      } catch (e2) {
        return false;
      }
    }
    static isPayloadValid(type2, payload) {
      switch (type2) {
        case PacketType.CONNECT:
          return isObject$6(payload);
        case PacketType.DISCONNECT:
          return payload === void 0;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || isObject$6(payload);
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    }
  }
  class BinaryReconstructor {
    constructor(packet) {
      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        const packet = reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }
  const parser$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Decoder,
    Encoder,
    get PacketType() {
      return PacketType;
    },
    protocol
  }, Symbol.toStringTag, { value: "Module" }));
  function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
      obj.off(ev, fn);
    };
  }
  const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1
  });
  let Socket$1 = class Socket extends Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
      super();
      this.connected = false;
      this.recovered = false;
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this._queue = [];
      this._queueSeq = 0;
      this.ids = 0;
      this.acks = {};
      this.flags = {};
      this.io = io;
      this.nsp = nsp;
      if (opts && opts.auth) {
        this.auth = opts.auth;
      }
      this._opts = Object.assign({}, opts);
      if (this.io._autoConnect)
        this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
      return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
      if (this.subs)
        return;
      const io = this.io;
      this.subs = [
        on(io, "open", this.onopen.bind(this)),
        on(io, "packet", this.onpacket.bind(this)),
        on(io, "error", this.onerror.bind(this)),
        on(io, "close", this.onclose.bind(this))
      ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
      return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
      if (this.connected)
        return this;
      this.subEvents();
      if (!this.io["_reconnecting"])
        this.io.open();
      if ("open" === this.io._readyState)
        this.onopen();
      return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev.toString() + '" is a reserved event name');
      }
      args.unshift(ev);
      if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
        this._addToQueue(args);
        return this;
      }
      const packet = {
        type: PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false;
      if ("function" === typeof args[args.length - 1]) {
        const id2 = this.ids++;
        const ack = args.pop();
        this._registerAckCallback(id2, ack);
        packet.id = id2;
      }
      const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
      if (discardPacket)
        ;
      else if (this.connected) {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id2, ack) {
      var _a2;
      const timeout = (_a2 = this.flags.timeout) !== null && _a2 !== void 0 ? _a2 : this._opts.ackTimeout;
      if (timeout === void 0) {
        this.acks[id2] = ack;
        return;
      }
      const timer = this.io.setTimeoutFn(() => {
        delete this.acks[id2];
        for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
          if (this.sendBuffer[i2].id === id2) {
            this.sendBuffer.splice(i2, 1);
          }
        }
        ack.call(this, new Error("operation has timed out"));
      }, timeout);
      const fn = (...args) => {
        this.io.clearTimeoutFn(timer);
        ack.apply(this, args);
      };
      fn.withError = true;
      this.acks[id2] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
      return new Promise((resolve, reject) => {
        const fn = (arg1, arg2) => {
          return arg1 ? reject(arg1) : resolve(arg2);
        };
        fn.withError = true;
        args.push(fn);
        this.emit(ev, ...args);
      });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
      let ack;
      if (typeof args[args.length - 1] === "function") {
        ack = args.pop();
      }
      const packet = {
        id: this._queueSeq++,
        tryCount: 0,
        pending: false,
        args,
        flags: Object.assign({ fromQueue: true }, this.flags)
      };
      args.push((err, ...responseArgs) => {
        if (packet !== this._queue[0]) {
          return;
        }
        const hasError = err !== null;
        if (hasError) {
          if (packet.tryCount > this._opts.retries) {
            this._queue.shift();
            if (ack) {
              ack(err);
            }
          }
        } else {
          this._queue.shift();
          if (ack) {
            ack(null, ...responseArgs);
          }
        }
        packet.pending = false;
        return this._drainQueue();
      });
      this._queue.push(packet);
      this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
      if (!this.connected || this._queue.length === 0) {
        return;
      }
      const packet = this._queue[0];
      if (packet.pending && !force) {
        return;
      }
      packet.pending = true;
      packet.tryCount++;
      this.flags = packet.flags;
      this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
      packet.nsp = this.nsp;
      this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
      if (typeof this.auth == "function") {
        this.auth((data) => {
          this._sendConnectPacket(data);
        });
      } else {
        this._sendConnectPacket(this.auth);
      }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
      this.packet({
        type: PacketType.CONNECT,
        data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
      });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
      this.connected = false;
      delete this.id;
      this.emitReserved("disconnect", reason, description);
      this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
    _clearAcks() {
      Object.keys(this.acks).forEach((id2) => {
        const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id2);
        if (!isBuffered) {
          const ack = this.acks[id2];
          delete this.acks[id2];
          if (ack.withError) {
            ack.call(this, new Error("socket has been disconnected"));
          }
        }
      });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
      const sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace)
        return;
      switch (packet.type) {
        case PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            this.onconnect(packet.data.sid, packet.data.pid);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const err = new Error(packet.data.message);
          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
      const args = packet.data || [];
      if (null != packet.id) {
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
    emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        const listeners = this._anyListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, args);
        }
      }
      super.emit.apply(this, args);
      if (this._pid && args.length && typeof args[args.length - 1] === "string") {
        this._lastOffset = args[args.length - 1];
      }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id2) {
      const self2 = this;
      let sent = false;
      return function(...args) {
        if (sent)
          return;
        sent = true;
        self2.packet({
          type: PacketType.ACK,
          id: id2,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
      const ack = this.acks[packet.id];
      if (typeof ack !== "function") {
        return;
      }
      delete this.acks[packet.id];
      if (ack.withError) {
        packet.data.unshift(null);
      }
      ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id2, pid) {
      this.id = id2;
      this.recovered = pid && this._pid === pid;
      this._pid = pid;
      this.connected = true;
      this.emitBuffered();
      this.emitReserved("connect");
      this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
      this.receiveBuffer.forEach((args) => this.emitEvent(args));
      this.receiveBuffer = [];
      this.sendBuffer.forEach((packet) => {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
      if (this.subs) {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs = void 0;
      }
      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
      if (this.connected) {
        this.packet({ type: PacketType.DISCONNECT });
      }
      this.destroy();
      if (this.connected) {
        this.onclose("io client disconnect");
      }
      return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
      this.flags.compress = compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
      this.flags.volatile = true;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
      this.flags.timeout = timeout;
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyListeners;
        for (let i2 = 0; i2 < listeners.length; i2++) {
          if (listener === listeners[i2]) {
            listeners.splice(i2, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
      return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
      if (!this._anyOutgoingListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyOutgoingListeners;
        for (let i2 = 0; i2 < listeners.length; i2++) {
          if (listener === listeners[i2]) {
            listeners.splice(i2, 1);
            return this;
          }
        }
      } else {
        this._anyOutgoingListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        const listeners = this._anyOutgoingListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, packet.data);
        }
      }
    }
  };
  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 1e4;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }
  Backoff.prototype.duration = function() {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var rand = Math.random();
      var deviation = Math.floor(rand * this.jitter * ms);
      ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
  };
  Backoff.prototype.reset = function() {
    this.attempts = 0;
  };
  Backoff.prototype.setMin = function(min) {
    this.ms = min;
  };
  Backoff.prototype.setMax = function(max) {
    this.max = max;
  };
  Backoff.prototype.setJitter = function(jitter) {
    this.jitter = jitter;
  };
  class Manager extends Emitter {
    constructor(uri, opts) {
      var _a2;
      super();
      this.nsps = {};
      this.subs = [];
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      this.opts = opts;
      installTimerFunctions(this, opts);
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1e3);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
      this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
      this.backoff = new Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
      this._readyState = "closed";
      this.uri = uri;
      const _parser = opts.parser || parser$1;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this._autoConnect = opts.autoConnect !== false;
      if (this._autoConnect)
        this.open();
    }
    reconnection(v2) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v2;
      return this;
    }
    reconnectionAttempts(v2) {
      if (v2 === void 0)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v2;
      return this;
    }
    reconnectionDelay(v2) {
      var _a2;
      if (v2 === void 0)
        return this._reconnectionDelay;
      this._reconnectionDelay = v2;
      (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v2);
      return this;
    }
    randomizationFactor(v2) {
      var _a2;
      if (v2 === void 0)
        return this._randomizationFactor;
      this._randomizationFactor = v2;
      (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v2);
      return this;
    }
    reconnectionDelayMax(v2) {
      var _a2;
      if (v2 === void 0)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v2;
      (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v2);
      return this;
    }
    timeout(v2) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v2;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
      if (~this._readyState.indexOf("open"))
        return this;
      this.engine = new Socket$2(this.uri, this.opts);
      const socket = this.engine;
      const self2 = this;
      this._readyState = "opening";
      this.skipReconnect = false;
      const openSubDestroy = on(socket, "open", function() {
        self2.onopen();
        fn && fn();
      });
      const onError = (err) => {
        this.cleanup();
        this._readyState = "closed";
        this.emitReserved("error", err);
        if (fn) {
          fn(err);
        } else {
          this.maybeReconnectOnOpen();
        }
      };
      const errorSub = on(socket, "error", onError);
      if (false !== this._timeout) {
        const timeout = this._timeout;
        const timer = this.setTimeoutFn(() => {
          openSubDestroy();
          onError(new Error("timeout"));
          socket.close();
        }, timeout);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(() => {
          this.clearTimeoutFn(timer);
        });
      }
      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
      this.cleanup();
      this._readyState = "open";
      this.emitReserved("open");
      const socket = this.engine;
      this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
      try {
        this.decoder.add(data);
      } catch (e2) {
        this.onclose("parse error", e2);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
      nextTick(() => {
        this.emitReserved("packet", packet);
      }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
      let socket = this.nsps[nsp];
      if (!socket) {
        socket = new Socket$1(this, nsp, opts);
        this.nsps[nsp] = socket;
      } else if (this._autoConnect && !socket.active) {
        socket.connect();
      }
      return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
      const nsps = Object.keys(this.nsps);
      for (const nsp of nsps) {
        const socket2 = this.nsps[nsp];
        if (socket2.active) {
          return;
        }
      }
      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
      const encodedPackets = this.encoder.encode(packet);
      for (let i2 = 0; i2 < encodedPackets.length; i2++) {
        this.engine.write(encodedPackets[i2], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
      this.skipReconnect = true;
      this._reconnecting = false;
      this.onclose("forced close");
      if (this.engine)
        this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
      return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
    onclose(reason, description) {
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason, description);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
      if (this._reconnecting || this.skipReconnect)
        return this;
      const self2 = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        const delay = this.backoff.duration();
        this._reconnecting = true;
        const timer = this.setTimeoutFn(() => {
          if (self2.skipReconnect)
            return;
          this.emitReserved("reconnect_attempt", self2.backoff.attempts);
          if (self2.skipReconnect)
            return;
          self2.open((err) => {
            if (err) {
              self2._reconnecting = false;
              self2.reconnect();
              this.emitReserved("reconnect_error", err);
            } else {
              self2.onreconnect();
            }
          });
        }, delay);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(() => {
          this.clearTimeoutFn(timer);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
      const attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    }
  }
  const cache = {};
  function lookup(uri, opts) {
    if (typeof uri === "object") {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    const parsed = url(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id2 = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id2] && path in cache[id2]["nsps"];
    const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
    let io;
    if (newConnection) {
      io = new Manager(source, opts);
    } else {
      if (!cache[id2]) {
        cache[id2] = new Manager(source, opts);
      }
      io = cache[id2];
    }
    if (parsed.query && !opts.query) {
      opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
  }
  Object.assign(lookup, {
    Manager,
    Socket: Socket$1,
    io: lookup,
    connect: lookup
  });
  var warn$2 = {};
  Object.defineProperty(warn$2, "__esModule", {
    value: true
  });
  var warn$1 = function warn2(s2) {
    console.warn("[react-gtm]", s2);
  };
  warn$2.default = warn$1;
  var _warn = warn$2;
  var _warn2 = _interopRequireDefault$3(_warn);
  function _interopRequireDefault$3(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var Snippets = {
    tags: function tags(_ref) {
      var id2 = _ref.id, events = _ref.events, dataLayer = _ref.dataLayer, dataLayerName = _ref.dataLayerName, preview = _ref.preview, auth = _ref.auth;
      var gtm_auth = "&gtm_auth=" + auth;
      var gtm_preview = "&gtm_preview=" + preview;
      if (!id2)
        (0, _warn2.default)("GTM Id is required");
      var iframe = '\n      <iframe src="https://www.googletagmanager.com/ns.html?id=' + id2 + gtm_auth + gtm_preview + '&gtm_cookies_win=x"\n        height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>';
      var script = "\n      (function(w,d,s,l,i){w[l]=w[l]||[];\n        w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', " + JSON.stringify(events).slice(1, -1) + "});\n        var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';\n        j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'" + gtm_auth + gtm_preview + "&gtm_cookies_win=x';\n        f.parentNode.insertBefore(j,f);\n      })(window,document,'script','" + dataLayerName + "','" + id2 + "');";
      var dataLayerVar = this.dataLayer(dataLayer, dataLayerName);
      return {
        iframe,
        script,
        dataLayerVar
      };
    },
    dataLayer: function dataLayer(_dataLayer, dataLayerName) {
      return "\n      window." + dataLayerName + " = window." + dataLayerName + " || [];\n      window." + dataLayerName + ".push(" + JSON.stringify(_dataLayer) + ")";
    }
  };
  var Snippets_1 = Snippets;
  var _Snippets = Snippets_1;
  var _Snippets2 = _interopRequireDefault$2(_Snippets);
  function _interopRequireDefault$2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var TagManager$1 = {
    dataScript: function dataScript(dataLayer) {
      var script = document.createElement("script");
      script.innerHTML = dataLayer;
      return script;
    },
    gtm: function gtm(args) {
      var snippets = _Snippets2.default.tags(args);
      var noScript = function noScript2() {
        var noscript = document.createElement("noscript");
        noscript.innerHTML = snippets.iframe;
        return noscript;
      };
      var script = function script2() {
        var script3 = document.createElement("script");
        script3.innerHTML = snippets.script;
        return script3;
      };
      var dataScript = this.dataScript(snippets.dataLayerVar);
      return {
        noScript,
        script,
        dataScript
      };
    },
    initialize: function initialize(_ref) {
      var gtmId = _ref.gtmId, _ref$events = _ref.events, events = _ref$events === void 0 ? {} : _ref$events, dataLayer = _ref.dataLayer, _ref$dataLayerName = _ref.dataLayerName, dataLayerName = _ref$dataLayerName === void 0 ? "dataLayer" : _ref$dataLayerName, _ref$auth = _ref.auth, auth = _ref$auth === void 0 ? "" : _ref$auth, _ref$preview = _ref.preview, preview = _ref$preview === void 0 ? "" : _ref$preview;
      var gtm = this.gtm({
        id: gtmId,
        events,
        dataLayer: dataLayer || void 0,
        dataLayerName,
        auth,
        preview
      });
      if (dataLayer)
        document.head.appendChild(gtm.dataScript);
      document.head.insertBefore(gtm.script(), document.head.childNodes[0]);
      document.body.insertBefore(gtm.noScript(), document.body.childNodes[0]);
    },
    dataLayer: function dataLayer(_ref2) {
      var _dataLayer = _ref2.dataLayer, _ref2$dataLayerName = _ref2.dataLayerName, dataLayerName = _ref2$dataLayerName === void 0 ? "dataLayer" : _ref2$dataLayerName;
      if (window[dataLayerName])
        return window[dataLayerName].push(_dataLayer);
      var snippets = _Snippets2.default.dataLayer(_dataLayer, dataLayerName);
      var dataScript = this.dataScript(snippets);
      document.head.insertBefore(dataScript, document.head.childNodes[0]);
    }
  };
  var TagManager_1 = TagManager$1;
  var _TagManager = TagManager_1;
  var _TagManager2 = _interopRequireDefault$1(_TagManager);
  function _interopRequireDefault$1(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var dist = _TagManager2.default;
  const TagManager = /* @__PURE__ */ getDefaultExportFromCjs(dist);
  const createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState2 = (partial, replace2) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState2 = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if (({ "VITE_API_URL": "http://localhost:8000", "VITE_PUBLIC_TOKEN": "39ece367b84b4bd19622692cc70361f2", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState: setState2, getState: getState2, getInitialState, subscribe, destroy };
    const initialState = state = createState(setState2, getState2, api);
    return api;
  };
  const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
  var withSelector = { exports: {} };
  var withSelector_production_min = {};
  var shim = { exports: {} };
  var useSyncExternalStoreShim_production_min = {};
  /**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var e$1 = reactExports;
  function h$4(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var k$1 = "function" === typeof Object.is ? Object.is : h$4, l$2 = e$1.useState, m$1 = e$1.useEffect, n$3 = e$1.useLayoutEffect, p$2 = e$1.useDebugValue;
  function q$1(a2, b2) {
    var d2 = b2(), f2 = l$2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
    n$3(function() {
      c2.value = d2;
      c2.getSnapshot = b2;
      r$2(c2) && g2({ inst: c2 });
    }, [a2, d2, b2]);
    m$1(function() {
      r$2(c2) && g2({ inst: c2 });
      return a2(function() {
        r$2(c2) && g2({ inst: c2 });
      });
    }, [a2]);
    p$2(d2);
    return d2;
  }
  function r$2(a2) {
    var b2 = a2.getSnapshot;
    a2 = a2.value;
    try {
      var d2 = b2();
      return !k$1(a2, d2);
    } catch (f2) {
      return true;
    }
  }
  function t$2(a2, b2) {
    return b2();
  }
  var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$2 : q$1;
  useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$1.useSyncExternalStore ? e$1.useSyncExternalStore : u$3;
  {
    shim.exports = useSyncExternalStoreShim_production_min;
  }
  var shimExports = shim.exports;
  /**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var h$3 = reactExports, n$2 = shimExports;
  function p$1(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var q = "function" === typeof Object.is ? Object.is : p$1, r$1 = n$2.useSyncExternalStore, t$1 = h$3.useRef, u$2 = h$3.useEffect, v$2 = h$3.useMemo, w$1 = h$3.useDebugValue;
  withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
    var c2 = t$1(null);
    if (null === c2.current) {
      var f2 = { hasValue: false, value: null };
      c2.current = f2;
    } else
      f2 = c2.current;
    c2 = v$2(function() {
      function a3(a4) {
        if (!c3) {
          c3 = true;
          d3 = a4;
          a4 = l2(a4);
          if (void 0 !== g2 && f2.hasValue) {
            var b3 = f2.value;
            if (g2(b3, a4))
              return k2 = b3;
          }
          return k2 = a4;
        }
        b3 = k2;
        if (q(d3, a4))
          return b3;
        var e3 = l2(a4);
        if (void 0 !== g2 && g2(b3, e3))
          return b3;
        d3 = a4;
        return k2 = e3;
      }
      var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
      return [function() {
        return a3(b2());
      }, null === m2 ? void 0 : function() {
        return a3(m2());
      }];
    }, [b2, e2, l2, g2]);
    var d2 = r$1(a2, c2[0], c2[1]);
    u$2(function() {
      f2.hasValue = true;
      f2.value = d2;
    }, [d2]);
    w$1(d2);
    return d2;
  };
  {
    withSelector.exports = withSelector_production_min;
  }
  var withSelectorExports = withSelector.exports;
  const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
  const { useDebugValue } = React$1;
  const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
  let didWarnAboutEqualityFn = false;
  const identity = (arg) => arg;
  function useStore$1(api, selector = identity, equalityFn) {
    if (({ "VITE_API_URL": "http://localhost:8000", "VITE_PUBLIC_TOKEN": "39ece367b84b4bd19622692cc70361f2", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
      console.warn(
        "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
      );
      didWarnAboutEqualityFn = true;
    }
    const slice = useSyncExternalStoreWithSelector(
      api.subscribe,
      api.getState,
      api.getServerState || api.getInitialState,
      selector,
      equalityFn
    );
    useDebugValue(slice);
    return slice;
  }
  const createImpl = (createState) => {
    if (({ "VITE_API_URL": "http://localhost:8000", "VITE_PUBLIC_TOKEN": "39ece367b84b4bd19622692cc70361f2", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": false } ? "production" : void 0) !== "production" && typeof createState !== "function") {
      console.warn(
        "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
      );
    }
    const api = typeof createState === "function" ? createStore(createState) : createState;
    const useBoundStore = (selector, equalityFn) => useStore$1(api, selector, equalityFn);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  const create$1 = (createState) => createState ? createImpl(createState) : createImpl;
  const decodeCache = {};
  function getDecodeCache(exclude) {
    let cache2 = decodeCache[exclude];
    if (cache2) {
      return cache2;
    }
    cache2 = decodeCache[exclude] = [];
    for (let i2 = 0; i2 < 128; i2++) {
      const ch2 = String.fromCharCode(i2);
      cache2.push(ch2);
    }
    for (let i2 = 0; i2 < exclude.length; i2++) {
      const ch2 = exclude.charCodeAt(i2);
      cache2[ch2] = "%" + ("0" + ch2.toString(16).toUpperCase()).slice(-2);
    }
    return cache2;
  }
  function decode$1(string, exclude) {
    if (typeof exclude !== "string") {
      exclude = decode$1.defaultChars;
    }
    const cache2 = getDecodeCache(exclude);
    return string.replace(/(%[a-f0-9]{2})+/gi, function(seq2) {
      let result = "";
      for (let i2 = 0, l2 = seq2.length; i2 < l2; i2 += 3) {
        const b1 = parseInt(seq2.slice(i2 + 1, i2 + 3), 16);
        if (b1 < 128) {
          result += cache2[b1];
          continue;
        }
        if ((b1 & 224) === 192 && i2 + 3 < l2) {
          const b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
          if ((b2 & 192) === 128) {
            const chr = b1 << 6 & 1984 | b2 & 63;
            if (chr < 128) {
              result += "��";
            } else {
              result += String.fromCharCode(chr);
            }
            i2 += 3;
            continue;
          }
        }
        if ((b1 & 240) === 224 && i2 + 6 < l2) {
          const b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
          const b3 = parseInt(seq2.slice(i2 + 7, i2 + 9), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128) {
            const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
            if (chr < 2048 || chr >= 55296 && chr <= 57343) {
              result += "���";
            } else {
              result += String.fromCharCode(chr);
            }
            i2 += 6;
            continue;
          }
        }
        if ((b1 & 248) === 240 && i2 + 9 < l2) {
          const b2 = parseInt(seq2.slice(i2 + 4, i2 + 6), 16);
          const b3 = parseInt(seq2.slice(i2 + 7, i2 + 9), 16);
          const b4 = parseInt(seq2.slice(i2 + 10, i2 + 12), 16);
          if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
            let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
            if (chr < 65536 || chr > 1114111) {
              result += "����";
            } else {
              chr -= 65536;
              result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
            }
            i2 += 9;
            continue;
          }
        }
        result += "�";
      }
      return result;
    });
  }
  decode$1.defaultChars = ";/?:@&=+$,#";
  decode$1.componentChars = "";
  const encodeCache = {};
  function getEncodeCache(exclude) {
    let cache2 = encodeCache[exclude];
    if (cache2) {
      return cache2;
    }
    cache2 = encodeCache[exclude] = [];
    for (let i2 = 0; i2 < 128; i2++) {
      const ch2 = String.fromCharCode(i2);
      if (/^[0-9a-z]$/i.test(ch2)) {
        cache2.push(ch2);
      } else {
        cache2.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
      }
    }
    for (let i2 = 0; i2 < exclude.length; i2++) {
      cache2[exclude.charCodeAt(i2)] = exclude[i2];
    }
    return cache2;
  }
  function encode$3(string, exclude, keepEscaped) {
    if (typeof exclude !== "string") {
      keepEscaped = exclude;
      exclude = encode$3.defaultChars;
    }
    if (typeof keepEscaped === "undefined") {
      keepEscaped = true;
    }
    const cache2 = getEncodeCache(exclude);
    let result = "";
    for (let i2 = 0, l2 = string.length; i2 < l2; i2++) {
      const code2 = string.charCodeAt(i2);
      if (keepEscaped && code2 === 37 && i2 + 2 < l2) {
        if (/^[0-9a-f]{2}$/i.test(string.slice(i2 + 1, i2 + 3))) {
          result += string.slice(i2, i2 + 3);
          i2 += 2;
          continue;
        }
      }
      if (code2 < 128) {
        result += cache2[code2];
        continue;
      }
      if (code2 >= 55296 && code2 <= 57343) {
        if (code2 >= 55296 && code2 <= 56319 && i2 + 1 < l2) {
          const nextCode = string.charCodeAt(i2 + 1);
          if (nextCode >= 56320 && nextCode <= 57343) {
            result += encodeURIComponent(string[i2] + string[i2 + 1]);
            i2++;
            continue;
          }
        }
        result += "%EF%BF%BD";
        continue;
      }
      result += encodeURIComponent(string[i2]);
    }
    return result;
  }
  encode$3.defaultChars = ";/?:@&=+$,-_.!~*'()#";
  encode$3.componentChars = "-_.!~*'()";
  function format(url2) {
    let result = "";
    result += url2.protocol || "";
    result += url2.slashes ? "//" : "";
    result += url2.auth ? url2.auth + "@" : "";
    if (url2.hostname && url2.hostname.indexOf(":") !== -1) {
      result += "[" + url2.hostname + "]";
    } else {
      result += url2.hostname || "";
    }
    result += url2.port ? ":" + url2.port : "";
    result += url2.pathname || "";
    result += url2.search || "";
    result += url2.hash || "";
    return result;
  }
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
  }
  const protocolPattern = /^([a-z0-9.+-]+:)/i;
  const portPattern = /:[0-9]*$/;
  const simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  const delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
  const unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
  const autoEscape = ["'"].concat(unwise);
  const nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
  const hostEndingChars = ["/", "?", "#"];
  const hostnameMaxLen = 255;
  const hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
  const hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  const hostlessProtocol = {
    javascript: true,
    "javascript:": true
  };
  const slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  };
  function urlParse(url2, slashesDenoteHost) {
    if (url2 && url2 instanceof Url)
      return url2;
    const u2 = new Url();
    u2.parse(url2, slashesDenoteHost);
    return u2;
  }
  Url.prototype.parse = function(url2, slashesDenoteHost) {
    let lowerProto, hec, slashes;
    let rest = url2;
    rest = rest.trim();
    if (!slashesDenoteHost && url2.split("#").length === 1) {
      const simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
        }
        return this;
      }
    }
    let proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = proto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      let hostEnd = -1;
      for (let i2 = 0; i2 < hostEndingChars.length; i2++) {
        hec = rest.indexOf(hostEndingChars[i2]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      let auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = auth;
      }
      hostEnd = -1;
      for (let i2 = 0; i2 < nonHostChars.length; i2++) {
        hec = rest.indexOf(nonHostChars[i2]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (hostEnd === -1) {
        hostEnd = rest.length;
      }
      if (rest[hostEnd - 1] === ":") {
        hostEnd--;
      }
      const host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost(host);
      this.hostname = this.hostname || "";
      const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        const hostparts = this.hostname.split(/\./);
        for (let i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
          const part = hostparts[i2];
          if (!part) {
            continue;
          }
          if (!part.match(hostnamePartPattern)) {
            let newpart = "";
            for (let j2 = 0, k2 = part.length; j2 < k2; j2++) {
              if (part.charCodeAt(j2) > 127) {
                newpart += "x";
              } else {
                newpart += part[j2];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              const validParts = hostparts.slice(0, i2);
              const notHost = hostparts.slice(i2 + 1);
              const bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      }
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      }
    }
    const hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    const qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      rest = rest.slice(0, qm);
    }
    if (rest) {
      this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "";
    }
    return this;
  };
  Url.prototype.parseHost = function(host) {
    let port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
  const mdurl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    decode: decode$1,
    encode: encode$3,
    format,
    parse: urlParse
  }, Symbol.toStringTag, { value: "Module" }));
  const Any = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  const Cc = /[\0-\x1F\x7F-\x9F]/;
  const regex$2 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  const P$1 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  const regex$1 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
  const Z$2 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  const ucmicro = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Any,
    Cc,
    Cf: regex$2,
    P: P$1,
    S: regex$1,
    Z: Z$2
  }, Symbol.toStringTag, { value: "Module" }));
  const htmlDecodeTree = new Uint16Array(
    // prettier-ignore
    'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((c2) => c2.charCodeAt(0))
  );
  const xmlDecodeTree = new Uint16Array(
    // prettier-ignore
    "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((c2) => c2.charCodeAt(0))
  );
  var _a;
  const decodeMap = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  const fromCodePoint$1 = (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      let output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    }
  );
  function replaceCodePoint(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
  }
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  const TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  function isNumber$1(code2) {
    return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric(code2) {
    return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber$1(code2);
  }
  function isEntityInAttributeInvalidEnd(code2) {
    return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
  }
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode || (DecodingMode = {}));
  class EntityDecoder {
    constructor(decodeTree, emitCodePoint, errors2) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors2;
      this.state = EntityDecoderState.EntityStart;
      this.consumed = 1;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.decodeMode = DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */
    startEntity(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    }
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    write(str2, offset) {
      switch (this.state) {
        case EntityDecoderState.EntityStart: {
          if (str2.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str2, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str2, offset);
        }
        case EntityDecoderState.NumericStart: {
          return this.stateNumericStart(str2, offset);
        }
        case EntityDecoderState.NumericDecimal: {
          return this.stateNumericDecimal(str2, offset);
        }
        case EntityDecoderState.NumericHex: {
          return this.stateNumericHex(str2, offset);
        }
        case EntityDecoderState.NamedEntity: {
          return this.stateNamedEntity(str2, offset);
        }
      }
    }
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericStart(str2, offset) {
      if (offset >= str2.length) {
        return -1;
      }
      if ((str2.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
        this.state = EntityDecoderState.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str2, offset + 1);
      }
      this.state = EntityDecoderState.NumericDecimal;
      return this.stateNumericDecimal(str2, offset);
    }
    addToNumericResult(str2, start, end, base2) {
      if (start !== end) {
        const digitCount = end - start;
        this.result = this.result * Math.pow(base2, digitCount) + parseInt(str2.substr(start, digitCount), base2);
        this.consumed += digitCount;
      }
    }
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericHex(str2, offset) {
      const startIdx = offset;
      while (offset < str2.length) {
        const char = str2.charCodeAt(offset);
        if (isNumber$1(char) || isHexadecimalCharacter(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str2, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str2, startIdx, offset, 16);
      return -1;
    }
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericDecimal(str2, offset) {
      const startIdx = offset;
      while (offset < str2.length) {
        const char = str2.charCodeAt(offset);
        if (isNumber$1(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str2, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str2, startIdx, offset, 10);
      return -1;
    }
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    emitNumericEntity(lastCp, expectedLength) {
      var _a2;
      if (this.consumed <= expectedLength) {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      if (lastCp === CharCodes.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === DecodingMode.Strict) {
        return 0;
      }
      this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    }
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNamedEntity(str2, offset) {
      const { decodeTree } = this;
      let current = decodeTree[this.treeIndex];
      let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      for (; offset < str2.length; offset++, this.excess++) {
        const char = str2.charCodeAt(offset);
        this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
        if (this.treeIndex < 0) {
          return this.result === 0 || // If we are parsing an attribute
          this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
          (valueLength === 0 || // And there should be no invalid characters.
          isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        if (valueLength !== 0) {
          if (char === CharCodes.SEMI) {
            return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
          }
          if (this.decodeMode !== DecodingMode.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    }
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    emitNotTerminatedNamedEntity() {
      var _a2;
      const { result, decodeTree } = this;
      const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result, valueLength, this.consumed);
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
      return this.consumed;
    }
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    emitNamedEntityData(result, valueLength, consumed) {
      const { decodeTree } = this;
      this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
      if (valueLength === 3) {
        this.emitCodePoint(decodeTree[result + 2], consumed);
      }
      return consumed;
    }
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    end() {
      var _a2;
      switch (this.state) {
        case EntityDecoderState.NamedEntity: {
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
        case EntityDecoderState.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState.NumericStart: {
          (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState.EntityStart: {
          return 0;
        }
      }
    }
  }
  function getDecoder(decodeTree) {
    let ret = "";
    const decoder = new EntityDecoder(decodeTree, (str2) => ret += fromCodePoint$1(str2));
    return function decodeWithTrie(str2, decodeMode) {
      let lastIndex = 0;
      let offset = 0;
      while ((offset = str2.indexOf("&", offset)) >= 0) {
        ret += str2.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        const len = decoder.write(
          str2,
          // Skip the "&"
          offset + 1
        );
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      const result = ret + str2.slice(lastIndex);
      ret = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      const value2 = char - jumpOffset;
      return value2 < 0 || value2 >= branchCount ? -1 : decodeTree[nodeIdx + value2] - 1;
    }
    let lo = nodeIdx;
    let hi2 = lo + branchCount - 1;
    while (lo <= hi2) {
      const mid = lo + hi2 >>> 1;
      const midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi2 = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  const htmlDecoder = getDecoder(htmlDecodeTree);
  getDecoder(xmlDecodeTree);
  function decodeHTML(str2, mode = DecodingMode.Legacy) {
    return htmlDecoder(str2, mode);
  }
  function _class$2(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString$3(obj) {
    return _class$2(obj) === "[object String]";
  }
  const _hasOwnProperty$4 = Object.prototype.hasOwnProperty;
  function has(object, key) {
    return _hasOwnProperty$4.call(object, key);
  }
  function assign$1(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be object");
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function arrayReplaceAt(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }
  function isValidEntityCode(c2) {
    if (c2 >= 55296 && c2 <= 57343) {
      return false;
    }
    if (c2 >= 64976 && c2 <= 65007) {
      return false;
    }
    if ((c2 & 65535) === 65535 || (c2 & 65535) === 65534) {
      return false;
    }
    if (c2 >= 0 && c2 <= 8) {
      return false;
    }
    if (c2 === 11) {
      return false;
    }
    if (c2 >= 14 && c2 <= 31) {
      return false;
    }
    if (c2 >= 127 && c2 <= 159) {
      return false;
    }
    if (c2 > 1114111) {
      return false;
    }
    return true;
  }
  function fromCodePoint(c2) {
    if (c2 > 65535) {
      c2 -= 65536;
      const surrogate1 = 55296 + (c2 >> 10);
      const surrogate2 = 56320 + (c2 & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c2);
  }
  const UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
  const ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  const UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
  const DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
  function replaceEntityPattern(match, name2) {
    if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
      const code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
      if (isValidEntityCode(code2)) {
        return fromCodePoint(code2);
      }
      return match;
    }
    const decoded = decodeHTML(match);
    if (decoded !== match) {
      return decoded;
    }
    return match;
  }
  function unescapeMd(str2) {
    if (str2.indexOf("\\") < 0) {
      return str2;
    }
    return str2.replace(UNESCAPE_MD_RE, "$1");
  }
  function unescapeAll(str2) {
    if (str2.indexOf("\\") < 0 && str2.indexOf("&") < 0) {
      return str2;
    }
    return str2.replace(UNESCAPE_ALL_RE, function(match, escaped, entity2) {
      if (escaped) {
        return escaped;
      }
      return replaceEntityPattern(match, entity2);
    });
  }
  const HTML_ESCAPE_TEST_RE = /[&<>"]/;
  const HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  const HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function replaceUnsafeChar(ch2) {
    return HTML_REPLACEMENTS[ch2];
  }
  function escapeHtml(str2) {
    if (HTML_ESCAPE_TEST_RE.test(str2)) {
      return str2.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str2;
  }
  const REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
  function escapeRE$1(str2) {
    return str2.replace(REGEXP_ESCAPE_RE, "\\$&");
  }
  function isSpace(code2) {
    switch (code2) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function isWhiteSpace(code2) {
    if (code2 >= 8192 && code2 <= 8202) {
      return true;
    }
    switch (code2) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  function isPunctChar(ch2) {
    return P$1.test(ch2) || regex$1.test(ch2);
  }
  function isMdAsciiPunct(ch2) {
    switch (ch2) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function normalizeReference(str2) {
    str2 = str2.trim().replace(/\s+/g, " ");
    if ("ẞ".toLowerCase() === "Ṿ") {
      str2 = str2.replace(/ẞ/g, "ß");
    }
    return str2.toLowerCase().toUpperCase();
  }
  const lib = { mdurl, ucmicro };
  const utils$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    arrayReplaceAt,
    assign: assign$1,
    escapeHtml,
    escapeRE: escapeRE$1,
    fromCodePoint,
    has,
    isMdAsciiPunct,
    isPunctChar,
    isSpace,
    isString: isString$3,
    isValidEntityCode,
    isWhiteSpace,
    lib,
    normalizeReference,
    unescapeAll,
    unescapeMd
  }, Symbol.toStringTag, { value: "Module" }));
  function parseLinkLabel(state, start, disableNested) {
    let level, found, marker, prevPos;
    const max = state.posMax;
    const oldPos = state.pos;
    state.pos = start + 1;
    level = 1;
    while (state.pos < max) {
      marker = state.src.charCodeAt(state.pos);
      if (marker === 93) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }
      prevPos = state.pos;
      state.md.inline.skipToken(state);
      if (marker === 91) {
        if (prevPos === state.pos - 1) {
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
    }
    let labelEnd = -1;
    if (found) {
      labelEnd = state.pos;
    }
    state.pos = oldPos;
    return labelEnd;
  }
  function parseLinkDestination(str2, start, max) {
    let code2;
    let pos = start;
    const result = {
      ok: false,
      pos: 0,
      str: ""
    };
    if (str2.charCodeAt(pos) === 60) {
      pos++;
      while (pos < max) {
        code2 = str2.charCodeAt(pos);
        if (code2 === 10) {
          return result;
        }
        if (code2 === 60) {
          return result;
        }
        if (code2 === 62) {
          result.pos = pos + 1;
          result.str = unescapeAll(str2.slice(start + 1, pos));
          result.ok = true;
          return result;
        }
        if (code2 === 92 && pos + 1 < max) {
          pos += 2;
          continue;
        }
        pos++;
      }
      return result;
    }
    let level = 0;
    while (pos < max) {
      code2 = str2.charCodeAt(pos);
      if (code2 === 32) {
        break;
      }
      if (code2 < 32 || code2 === 127) {
        break;
      }
      if (code2 === 92 && pos + 1 < max) {
        if (str2.charCodeAt(pos + 1) === 32) {
          break;
        }
        pos += 2;
        continue;
      }
      if (code2 === 40) {
        level++;
        if (level > 32) {
          return result;
        }
      }
      if (code2 === 41) {
        if (level === 0) {
          break;
        }
        level--;
      }
      pos++;
    }
    if (start === pos) {
      return result;
    }
    if (level !== 0) {
      return result;
    }
    result.str = unescapeAll(str2.slice(start, pos));
    result.pos = pos;
    result.ok = true;
    return result;
  }
  function parseLinkTitle(str2, start, max, prev_state) {
    let code2;
    let pos = start;
    const state = {
      // if `true`, this is a valid link title
      ok: false,
      // if `true`, this link can be continued on the next line
      can_continue: false,
      // if `ok`, it's the position of the first character after the closing marker
      pos: 0,
      // if `ok`, it's the unescaped title
      str: "",
      // expected closing marker character code
      marker: 0
    };
    if (prev_state) {
      state.str = prev_state.str;
      state.marker = prev_state.marker;
    } else {
      if (pos >= max) {
        return state;
      }
      let marker = str2.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return state;
      }
      start++;
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      state.marker = marker;
    }
    while (pos < max) {
      code2 = str2.charCodeAt(pos);
      if (code2 === state.marker) {
        state.pos = pos + 1;
        state.str += unescapeAll(str2.slice(start, pos));
        state.ok = true;
        return state;
      } else if (code2 === 40 && state.marker === 41) {
        return state;
      } else if (code2 === 92 && pos + 1 < max) {
        pos++;
      }
      pos++;
    }
    state.can_continue = true;
    state.str += unescapeAll(str2.slice(start, pos));
    return state;
  }
  const helpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    parseLinkDestination,
    parseLinkLabel,
    parseLinkTitle
  }, Symbol.toStringTag, { value: "Module" }));
  const default_rules = {};
  default_rules.code_inline = function(tokens, idx, options, env, slf) {
    const token = tokens[idx];
    return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
  };
  default_rules.code_block = function(tokens, idx, options, env, slf) {
    const token = tokens[idx];
    return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
  };
  default_rules.fence = function(tokens, idx, options, env, slf) {
    const token = tokens[idx];
    const info = token.info ? unescapeAll(token.info).trim() : "";
    let langName = "";
    let langAttrs = "";
    if (info) {
      const arr = info.split(/(\s+)/g);
      langName = arr[0];
      langAttrs = arr.slice(2).join("");
    }
    let highlighted;
    if (options.highlight) {
      highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
    } else {
      highlighted = escapeHtml(token.content);
    }
    if (highlighted.indexOf("<pre") === 0) {
      return highlighted + "\n";
    }
    if (info) {
      const i2 = token.attrIndex("class");
      const tmpAttrs = token.attrs ? token.attrs.slice() : [];
      if (i2 < 0) {
        tmpAttrs.push(["class", options.langPrefix + langName]);
      } else {
        tmpAttrs[i2] = tmpAttrs[i2].slice();
        tmpAttrs[i2][1] += " " + options.langPrefix + langName;
      }
      const tmpToken = {
        attrs: tmpAttrs
      };
      return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
    }
    return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
  };
  default_rules.image = function(tokens, idx, options, env, slf) {
    const token = tokens[idx];
    token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
    return slf.renderToken(tokens, idx, options);
  };
  default_rules.hardbreak = function(tokens, idx, options) {
    return options.xhtmlOut ? "<br />\n" : "<br>\n";
  };
  default_rules.softbreak = function(tokens, idx, options) {
    return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
  };
  default_rules.text = function(tokens, idx) {
    return escapeHtml(tokens[idx].content);
  };
  default_rules.html_block = function(tokens, idx) {
    return tokens[idx].content;
  };
  default_rules.html_inline = function(tokens, idx) {
    return tokens[idx].content;
  };
  function Renderer() {
    this.rules = assign$1({}, default_rules);
  }
  Renderer.prototype.renderAttrs = function renderAttrs(token) {
    let i2, l2, result;
    if (!token.attrs) {
      return "";
    }
    result = "";
    for (i2 = 0, l2 = token.attrs.length; i2 < l2; i2++) {
      result += " " + escapeHtml(token.attrs[i2][0]) + '="' + escapeHtml(token.attrs[i2][1]) + '"';
    }
    return result;
  };
  Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
    const token = tokens[idx];
    let result = "";
    if (token.hidden) {
      return "";
    }
    if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
      result += "\n";
    }
    result += (token.nesting === -1 ? "</" : "<") + token.tag;
    result += this.renderAttrs(token);
    if (token.nesting === 0 && options.xhtmlOut) {
      result += " /";
    }
    let needLf = false;
    if (token.block) {
      needLf = true;
      if (token.nesting === 1) {
        if (idx + 1 < tokens.length) {
          const nextToken = tokens[idx + 1];
          if (nextToken.type === "inline" || nextToken.hidden) {
            needLf = false;
          } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
            needLf = false;
          }
        }
      }
    }
    result += needLf ? ">\n" : ">";
    return result;
  };
  Renderer.prototype.renderInline = function(tokens, options, env) {
    let result = "";
    const rules = this.rules;
    for (let i2 = 0, len = tokens.length; i2 < len; i2++) {
      const type2 = tokens[i2].type;
      if (typeof rules[type2] !== "undefined") {
        result += rules[type2](tokens, i2, options, env, this);
      } else {
        result += this.renderToken(tokens, i2, options);
      }
    }
    return result;
  };
  Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
    let result = "";
    for (let i2 = 0, len = tokens.length; i2 < len; i2++) {
      switch (tokens[i2].type) {
        case "text":
          result += tokens[i2].content;
          break;
        case "image":
          result += this.renderInlineAsText(tokens[i2].children, options, env);
          break;
        case "html_inline":
        case "html_block":
          result += tokens[i2].content;
          break;
        case "softbreak":
        case "hardbreak":
          result += "\n";
          break;
      }
    }
    return result;
  };
  Renderer.prototype.render = function(tokens, options, env) {
    let result = "";
    const rules = this.rules;
    for (let i2 = 0, len = tokens.length; i2 < len; i2++) {
      const type2 = tokens[i2].type;
      if (type2 === "inline") {
        result += this.renderInline(tokens[i2].children, options, env);
      } else if (typeof rules[type2] !== "undefined") {
        result += rules[type2](tokens, i2, options, env, this);
      } else {
        result += this.renderToken(tokens, i2, options, env);
      }
    }
    return result;
  };
  function Ruler() {
    this.__rules__ = [];
    this.__cache__ = null;
  }
  Ruler.prototype.__find__ = function(name2) {
    for (let i2 = 0; i2 < this.__rules__.length; i2++) {
      if (this.__rules__[i2].name === name2) {
        return i2;
      }
    }
    return -1;
  };
  Ruler.prototype.__compile__ = function() {
    const self2 = this;
    const chains = [""];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      rule.alt.forEach(function(altName) {
        if (chains.indexOf(altName) < 0) {
          chains.push(altName);
        }
      });
    });
    self2.__cache__ = {};
    chains.forEach(function(chain) {
      self2.__cache__[chain] = [];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        if (chain && rule.alt.indexOf(chain) < 0) {
          return;
        }
        self2.__cache__[chain].push(rule.fn);
      });
    });
  };
  Ruler.prototype.at = function(name2, fn, options) {
    const index2 = this.__find__(name2);
    const opt = options || {};
    if (index2 === -1) {
      throw new Error("Parser rule not found: " + name2);
    }
    this.__rules__[index2].fn = fn;
    this.__rules__[index2].alt = opt.alt || [];
    this.__cache__ = null;
  };
  Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
    const index2 = this.__find__(beforeName);
    const opt = options || {};
    if (index2 === -1) {
      throw new Error("Parser rule not found: " + beforeName);
    }
    this.__rules__.splice(index2, 0, {
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.after = function(afterName, ruleName, fn, options) {
    const index2 = this.__find__(afterName);
    const opt = options || {};
    if (index2 === -1) {
      throw new Error("Parser rule not found: " + afterName);
    }
    this.__rules__.splice(index2 + 1, 0, {
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.push = function(ruleName, fn, options) {
    const opt = options || {};
    this.__rules__.push({
      name: ruleName,
      enabled: true,
      fn,
      alt: opt.alt || []
    });
    this.__cache__ = null;
  };
  Ruler.prototype.enable = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    const result = [];
    list2.forEach(function(name2) {
      const idx = this.__find__(name2);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name2);
      }
      this.__rules__[idx].enabled = true;
      result.push(name2);
    }, this);
    this.__cache__ = null;
    return result;
  };
  Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    this.__rules__.forEach(function(rule) {
      rule.enabled = false;
    });
    this.enable(list2, ignoreInvalid);
  };
  Ruler.prototype.disable = function(list2, ignoreInvalid) {
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    const result = [];
    list2.forEach(function(name2) {
      const idx = this.__find__(name2);
      if (idx < 0) {
        if (ignoreInvalid) {
          return;
        }
        throw new Error("Rules manager: invalid rule name " + name2);
      }
      this.__rules__[idx].enabled = false;
      result.push(name2);
    }, this);
    this.__cache__ = null;
    return result;
  };
  Ruler.prototype.getRules = function(chainName) {
    if (this.__cache__ === null) {
      this.__compile__();
    }
    return this.__cache__[chainName] || [];
  };
  function Token(type2, tag, nesting) {
    this.type = type2;
    this.tag = tag;
    this.attrs = null;
    this.map = null;
    this.nesting = nesting;
    this.level = 0;
    this.children = null;
    this.content = "";
    this.markup = "";
    this.info = "";
    this.meta = null;
    this.block = false;
    this.hidden = false;
  }
  Token.prototype.attrIndex = function attrIndex(name2) {
    if (!this.attrs) {
      return -1;
    }
    const attrs = this.attrs;
    for (let i2 = 0, len = attrs.length; i2 < len; i2++) {
      if (attrs[i2][0] === name2) {
        return i2;
      }
    }
    return -1;
  };
  Token.prototype.attrPush = function attrPush(attrData) {
    if (this.attrs) {
      this.attrs.push(attrData);
    } else {
      this.attrs = [attrData];
    }
  };
  Token.prototype.attrSet = function attrSet2(name2, value2) {
    const idx = this.attrIndex(name2);
    const attrData = [name2, value2];
    if (idx < 0) {
      this.attrPush(attrData);
    } else {
      this.attrs[idx] = attrData;
    }
  };
  Token.prototype.attrGet = function attrGet(name2) {
    const idx = this.attrIndex(name2);
    let value2 = null;
    if (idx >= 0) {
      value2 = this.attrs[idx][1];
    }
    return value2;
  };
  Token.prototype.attrJoin = function attrJoin(name2, value2) {
    const idx = this.attrIndex(name2);
    if (idx < 0) {
      this.attrPush([name2, value2]);
    } else {
      this.attrs[idx][1] = this.attrs[idx][1] + " " + value2;
    }
  };
  function StateCore(src, md2, env) {
    this.src = src;
    this.env = env;
    this.tokens = [];
    this.inlineMode = false;
    this.md = md2;
  }
  StateCore.prototype.Token = Token;
  const NEWLINES_RE = /\r\n?|\n/g;
  const NULL_RE = /\0/g;
  function normalize(state) {
    let str2;
    str2 = state.src.replace(NEWLINES_RE, "\n");
    str2 = str2.replace(NULL_RE, "�");
    state.src = str2;
  }
  function block(state) {
    let token;
    if (state.inlineMode) {
      token = new state.Token("inline", "", 0);
      token.content = state.src;
      token.map = [0, 1];
      token.children = [];
      state.tokens.push(token);
    } else {
      state.md.block.parse(state.src, state.md, state.env, state.tokens);
    }
  }
  function inline(state) {
    const tokens = state.tokens;
    for (let i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
      const tok = tokens[i2];
      if (tok.type === "inline") {
        state.md.inline.parse(tok.content, state.md, state.env, tok.children);
      }
    }
  }
  function isLinkOpen$1(str2) {
    return /^<a[>\s]/i.test(str2);
  }
  function isLinkClose$1(str2) {
    return /^<\/a\s*>/i.test(str2);
  }
  function linkify$1(state) {
    const blockTokens = state.tokens;
    if (!state.md.options.linkify) {
      return;
    }
    for (let j2 = 0, l2 = blockTokens.length; j2 < l2; j2++) {
      if (blockTokens[j2].type !== "inline" || !state.md.linkify.pretest(blockTokens[j2].content)) {
        continue;
      }
      let tokens = blockTokens[j2].children;
      let htmlLinkLevel = 0;
      for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
        const currentToken = tokens[i2];
        if (currentToken.type === "link_close") {
          i2--;
          while (tokens[i2].level !== currentToken.level && tokens[i2].type !== "link_open") {
            i2--;
          }
          continue;
        }
        if (currentToken.type === "html_inline") {
          if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
            htmlLinkLevel--;
          }
          if (isLinkClose$1(currentToken.content)) {
            htmlLinkLevel++;
          }
        }
        if (htmlLinkLevel > 0) {
          continue;
        }
        if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
          const text2 = currentToken.content;
          let links = state.md.linkify.match(text2);
          const nodes = [];
          let level = currentToken.level;
          let lastPos = 0;
          if (links.length > 0 && links[0].index === 0 && i2 > 0 && tokens[i2 - 1].type === "text_special") {
            links = links.slice(1);
          }
          for (let ln = 0; ln < links.length; ln++) {
            const url2 = links[ln].url;
            const fullUrl = state.md.normalizeLink(url2);
            if (!state.md.validateLink(fullUrl)) {
              continue;
            }
            let urlText = links[ln].text;
            if (!links[ln].schema) {
              urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
            } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
              urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
            } else {
              urlText = state.md.normalizeLinkText(urlText);
            }
            const pos = links[ln].index;
            if (pos > lastPos) {
              const token = new state.Token("text", "", 0);
              token.content = text2.slice(lastPos, pos);
              token.level = level;
              nodes.push(token);
            }
            const token_o = new state.Token("link_open", "a", 1);
            token_o.attrs = [["href", fullUrl]];
            token_o.level = level++;
            token_o.markup = "linkify";
            token_o.info = "auto";
            nodes.push(token_o);
            const token_t = new state.Token("text", "", 0);
            token_t.content = urlText;
            token_t.level = level;
            nodes.push(token_t);
            const token_c = new state.Token("link_close", "a", -1);
            token_c.level = --level;
            token_c.markup = "linkify";
            token_c.info = "auto";
            nodes.push(token_c);
            lastPos = links[ln].lastIndex;
          }
          if (lastPos < text2.length) {
            const token = new state.Token("text", "", 0);
            token.content = text2.slice(lastPos);
            token.level = level;
            nodes.push(token);
          }
          blockTokens[j2].children = tokens = arrayReplaceAt(tokens, i2, nodes);
        }
      }
    }
  }
  const RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
  const SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
  const SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
  const SCOPED_ABBR = {
    c: "©",
    r: "®",
    tm: "™"
  };
  function replaceFn(match, name2) {
    return SCOPED_ABBR[name2.toLowerCase()];
  }
  function replace_scoped(inlineTokens) {
    let inside_autolink = 0;
    for (let i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
      const token = inlineTokens[i2];
      if (token.type === "text" && !inside_autolink) {
        token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
      }
      if (token.type === "link_open" && token.info === "auto") {
        inside_autolink--;
      }
      if (token.type === "link_close" && token.info === "auto") {
        inside_autolink++;
      }
    }
  }
  function replace_rare(inlineTokens) {
    let inside_autolink = 0;
    for (let i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
      const token = inlineTokens[i2];
      if (token.type === "text" && !inside_autolink) {
        if (RARE_RE.test(token.content)) {
          token.content = token.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
        }
      }
      if (token.type === "link_open" && token.info === "auto") {
        inside_autolink--;
      }
      if (token.type === "link_close" && token.info === "auto") {
        inside_autolink++;
      }
    }
  }
  function replace(state) {
    let blkIdx;
    if (!state.md.options.typographer) {
      return;
    }
    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline") {
        continue;
      }
      if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
        replace_scoped(state.tokens[blkIdx].children);
      }
      if (RARE_RE.test(state.tokens[blkIdx].content)) {
        replace_rare(state.tokens[blkIdx].children);
      }
    }
  }
  const QUOTE_TEST_RE = /['"]/;
  const QUOTE_RE = /['"]/g;
  const APOSTROPHE = "’";
  function replaceAt(str2, index2, ch2) {
    return str2.slice(0, index2) + ch2 + str2.slice(index2 + 1);
  }
  function process_inlines(tokens, state) {
    let j2;
    const stack = [];
    for (let i2 = 0; i2 < tokens.length; i2++) {
      const token = tokens[i2];
      const thisLevel = tokens[i2].level;
      for (j2 = stack.length - 1; j2 >= 0; j2--) {
        if (stack[j2].level <= thisLevel) {
          break;
        }
      }
      stack.length = j2 + 1;
      if (token.type !== "text") {
        continue;
      }
      let text2 = token.content;
      let pos = 0;
      let max = text2.length;
      OUTER:
        while (pos < max) {
          QUOTE_RE.lastIndex = pos;
          const t2 = QUOTE_RE.exec(text2);
          if (!t2) {
            break;
          }
          let canOpen = true;
          let canClose = true;
          pos = t2.index + 1;
          const isSingle = t2[0] === "'";
          let lastChar = 32;
          if (t2.index - 1 >= 0) {
            lastChar = text2.charCodeAt(t2.index - 1);
          } else {
            for (j2 = i2 - 1; j2 >= 0; j2--) {
              if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak")
                break;
              if (!tokens[j2].content)
                continue;
              lastChar = tokens[j2].content.charCodeAt(tokens[j2].content.length - 1);
              break;
            }
          }
          let nextChar = 32;
          if (pos < max) {
            nextChar = text2.charCodeAt(pos);
          } else {
            for (j2 = i2 + 1; j2 < tokens.length; j2++) {
              if (tokens[j2].type === "softbreak" || tokens[j2].type === "hardbreak")
                break;
              if (!tokens[j2].content)
                continue;
              nextChar = tokens[j2].content.charCodeAt(0);
              break;
            }
          }
          const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
          const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
          const isLastWhiteSpace = isWhiteSpace(lastChar);
          const isNextWhiteSpace = isWhiteSpace(nextChar);
          if (isNextWhiteSpace) {
            canOpen = false;
          } else if (isNextPunctChar) {
            if (!(isLastWhiteSpace || isLastPunctChar)) {
              canOpen = false;
            }
          }
          if (isLastWhiteSpace) {
            canClose = false;
          } else if (isLastPunctChar) {
            if (!(isNextWhiteSpace || isNextPunctChar)) {
              canClose = false;
            }
          }
          if (nextChar === 34 && t2[0] === '"') {
            if (lastChar >= 48 && lastChar <= 57) {
              canClose = canOpen = false;
            }
          }
          if (canOpen && canClose) {
            canOpen = isLastPunctChar;
            canClose = isNextPunctChar;
          }
          if (!canOpen && !canClose) {
            if (isSingle) {
              token.content = replaceAt(token.content, t2.index, APOSTROPHE);
            }
            continue;
          }
          if (canClose) {
            for (j2 = stack.length - 1; j2 >= 0; j2--) {
              let item = stack[j2];
              if (stack[j2].level < thisLevel) {
                break;
              }
              if (item.single === isSingle && stack[j2].level === thisLevel) {
                item = stack[j2];
                let openQuote;
                let closeQuote;
                if (isSingle) {
                  openQuote = state.md.options.quotes[2];
                  closeQuote = state.md.options.quotes[3];
                } else {
                  openQuote = state.md.options.quotes[0];
                  closeQuote = state.md.options.quotes[1];
                }
                token.content = replaceAt(token.content, t2.index, closeQuote);
                tokens[item.token].content = replaceAt(
                  tokens[item.token].content,
                  item.pos,
                  openQuote
                );
                pos += closeQuote.length - 1;
                if (item.token === i2) {
                  pos += openQuote.length - 1;
                }
                text2 = token.content;
                max = text2.length;
                stack.length = j2;
                continue OUTER;
              }
            }
          }
          if (canOpen) {
            stack.push({
              token: i2,
              pos: t2.index,
              single: isSingle,
              level: thisLevel
            });
          } else if (canClose && isSingle) {
            token.content = replaceAt(token.content, t2.index, APOSTROPHE);
          }
        }
    }
  }
  function smartquotes(state) {
    if (!state.md.options.typographer) {
      return;
    }
    for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
      if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
        continue;
      }
      process_inlines(state.tokens[blkIdx].children, state);
    }
  }
  function text_join(state) {
    let curr, last;
    const blockTokens = state.tokens;
    const l2 = blockTokens.length;
    for (let j2 = 0; j2 < l2; j2++) {
      if (blockTokens[j2].type !== "inline")
        continue;
      const tokens = blockTokens[j2].children;
      const max = tokens.length;
      for (curr = 0; curr < max; curr++) {
        if (tokens[curr].type === "text_special") {
          tokens[curr].type = "text";
        }
      }
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    }
  }
  const _rules$2 = [
    ["normalize", normalize],
    ["block", block],
    ["inline", inline],
    ["linkify", linkify$1],
    ["replacements", replace],
    ["smartquotes", smartquotes],
    // `text_join` finds `text_special` tokens (for escape sequences)
    // and joins them with the rest of the text
    ["text_join", text_join]
  ];
  function Core() {
    this.ruler = new Ruler();
    for (let i2 = 0; i2 < _rules$2.length; i2++) {
      this.ruler.push(_rules$2[i2][0], _rules$2[i2][1]);
    }
  }
  Core.prototype.process = function(state) {
    const rules = this.ruler.getRules("");
    for (let i2 = 0, l2 = rules.length; i2 < l2; i2++) {
      rules[i2](state);
    }
  };
  Core.prototype.State = StateCore;
  function StateBlock(src, md2, env, tokens) {
    this.src = src;
    this.md = md2;
    this.env = env;
    this.tokens = tokens;
    this.bMarks = [];
    this.eMarks = [];
    this.tShift = [];
    this.sCount = [];
    this.bsCount = [];
    this.blkIndent = 0;
    this.line = 0;
    this.lineMax = 0;
    this.tight = false;
    this.ddIndent = -1;
    this.listIndent = -1;
    this.parentType = "root";
    this.level = 0;
    const s2 = this.src;
    for (let start = 0, pos = 0, indent = 0, offset = 0, len = s2.length, indent_found = false; pos < len; pos++) {
      const ch2 = s2.charCodeAt(pos);
      if (!indent_found) {
        if (isSpace(ch2)) {
          indent++;
          if (ch2 === 9) {
            offset += 4 - offset % 4;
          } else {
            offset++;
          }
          continue;
        } else {
          indent_found = true;
        }
      }
      if (ch2 === 10 || pos === len - 1) {
        if (ch2 !== 10) {
          pos++;
        }
        this.bMarks.push(start);
        this.eMarks.push(pos);
        this.tShift.push(indent);
        this.sCount.push(offset);
        this.bsCount.push(0);
        indent_found = false;
        indent = 0;
        offset = 0;
        start = pos + 1;
      }
    }
    this.bMarks.push(s2.length);
    this.eMarks.push(s2.length);
    this.tShift.push(0);
    this.sCount.push(0);
    this.bsCount.push(0);
    this.lineMax = this.bMarks.length - 1;
  }
  StateBlock.prototype.push = function(type2, tag, nesting) {
    const token = new Token(type2, tag, nesting);
    token.block = true;
    if (nesting < 0)
      this.level--;
    token.level = this.level;
    if (nesting > 0)
      this.level++;
    this.tokens.push(token);
    return token;
  };
  StateBlock.prototype.isEmpty = function isEmpty2(line) {
    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
  };
  StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
    for (let max = this.lineMax; from < max; from++) {
      if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
        break;
      }
    }
    return from;
  };
  StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
    for (let max = this.src.length; pos < max; pos++) {
      const ch2 = this.src.charCodeAt(pos);
      if (!isSpace(ch2)) {
        break;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
    if (pos <= min) {
      return pos;
    }
    while (pos > min) {
      if (!isSpace(this.src.charCodeAt(--pos))) {
        return pos + 1;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipChars = function skipChars(pos, code2) {
    for (let max = this.src.length; pos < max; pos++) {
      if (this.src.charCodeAt(pos) !== code2) {
        break;
      }
    }
    return pos;
  };
  StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
    if (pos <= min) {
      return pos;
    }
    while (pos > min) {
      if (code2 !== this.src.charCodeAt(--pos)) {
        return pos + 1;
      }
    }
    return pos;
  };
  StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
    if (begin >= end) {
      return "";
    }
    const queue = new Array(end - begin);
    for (let i2 = 0, line = begin; line < end; line++, i2++) {
      let lineIndent = 0;
      const lineStart = this.bMarks[line];
      let first = lineStart;
      let last;
      if (line + 1 < end || keepLastLF) {
        last = this.eMarks[line] + 1;
      } else {
        last = this.eMarks[line];
      }
      while (first < last && lineIndent < indent) {
        const ch2 = this.src.charCodeAt(first);
        if (isSpace(ch2)) {
          if (ch2 === 9) {
            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
          } else {
            lineIndent++;
          }
        } else if (first - lineStart < this.tShift[line]) {
          lineIndent++;
        } else {
          break;
        }
        first++;
      }
      if (lineIndent > indent) {
        queue[i2] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
      } else {
        queue[i2] = this.src.slice(first, last);
      }
    }
    return queue.join("");
  };
  StateBlock.prototype.Token = Token;
  const MAX_AUTOCOMPLETED_CELLS = 65536;
  function getLine(state, line) {
    const pos = state.bMarks[line] + state.tShift[line];
    const max = state.eMarks[line];
    return state.src.slice(pos, max);
  }
  function escapedSplit(str2) {
    const result = [];
    const max = str2.length;
    let pos = 0;
    let ch2 = str2.charCodeAt(pos);
    let isEscaped = false;
    let lastPos = 0;
    let current = "";
    while (pos < max) {
      if (ch2 === 124) {
        if (!isEscaped) {
          result.push(current + str2.substring(lastPos, pos));
          current = "";
          lastPos = pos + 1;
        } else {
          current += str2.substring(lastPos, pos - 1);
          lastPos = pos;
        }
      }
      isEscaped = ch2 === 92;
      pos++;
      ch2 = str2.charCodeAt(pos);
    }
    result.push(current + str2.substring(lastPos));
    return result;
  }
  function table(state, startLine, endLine, silent) {
    if (startLine + 2 > endLine) {
      return false;
    }
    let nextLine = startLine + 1;
    if (state.sCount[nextLine] < state.blkIndent) {
      return false;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    }
    let pos = state.bMarks[nextLine] + state.tShift[nextLine];
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    const firstCh = state.src.charCodeAt(pos++);
    if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
      return false;
    }
    if (pos >= state.eMarks[nextLine]) {
      return false;
    }
    const secondCh = state.src.charCodeAt(pos++);
    if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
      return false;
    }
    if (firstCh === 45 && isSpace(secondCh)) {
      return false;
    }
    while (pos < state.eMarks[nextLine]) {
      const ch2 = state.src.charCodeAt(pos);
      if (ch2 !== 124 && ch2 !== 45 && ch2 !== 58 && !isSpace(ch2)) {
        return false;
      }
      pos++;
    }
    let lineText = getLine(state, startLine + 1);
    let columns = lineText.split("|");
    const aligns = [];
    for (let i2 = 0; i2 < columns.length; i2++) {
      const t2 = columns[i2].trim();
      if (!t2) {
        if (i2 === 0 || i2 === columns.length - 1) {
          continue;
        } else {
          return false;
        }
      }
      if (!/^:?-+:?$/.test(t2)) {
        return false;
      }
      if (t2.charCodeAt(t2.length - 1) === 58) {
        aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
      } else if (t2.charCodeAt(0) === 58) {
        aligns.push("left");
      } else {
        aligns.push("");
      }
    }
    lineText = getLine(state, startLine).trim();
    if (lineText.indexOf("|") === -1) {
      return false;
    }
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    const columnCount = columns.length;
    if (columnCount === 0 || columnCount !== aligns.length) {
      return false;
    }
    if (silent) {
      return true;
    }
    const oldParentType = state.parentType;
    state.parentType = "table";
    const terminatorRules = state.md.block.ruler.getRules("blockquote");
    const token_to = state.push("table_open", "table", 1);
    const tableLines = [startLine, 0];
    token_to.map = tableLines;
    const token_tho = state.push("thead_open", "thead", 1);
    token_tho.map = [startLine, startLine + 1];
    const token_htro = state.push("tr_open", "tr", 1);
    token_htro.map = [startLine, startLine + 1];
    for (let i2 = 0; i2 < columns.length; i2++) {
      const token_ho = state.push("th_open", "th", 1);
      if (aligns[i2]) {
        token_ho.attrs = [["style", "text-align:" + aligns[i2]]];
      }
      const token_il = state.push("inline", "", 0);
      token_il.content = columns[i2].trim();
      token_il.children = [];
      state.push("th_close", "th", -1);
    }
    state.push("tr_close", "tr", -1);
    state.push("thead_close", "thead", -1);
    let tbodyLines;
    let autocompletedCells = 0;
    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      let terminate = false;
      for (let i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
        if (terminatorRules[i2](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      lineText = getLine(state, nextLine).trim();
      if (!lineText) {
        break;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      autocompletedCells += columnCount - columns.length;
      if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
        break;
      }
      if (nextLine === startLine + 2) {
        const token_tbo = state.push("tbody_open", "tbody", 1);
        token_tbo.map = tbodyLines = [startLine + 2, 0];
      }
      const token_tro = state.push("tr_open", "tr", 1);
      token_tro.map = [nextLine, nextLine + 1];
      for (let i2 = 0; i2 < columnCount; i2++) {
        const token_tdo = state.push("td_open", "td", 1);
        if (aligns[i2]) {
          token_tdo.attrs = [["style", "text-align:" + aligns[i2]]];
        }
        const token_il = state.push("inline", "", 0);
        token_il.content = columns[i2] ? columns[i2].trim() : "";
        token_il.children = [];
        state.push("td_close", "td", -1);
      }
      state.push("tr_close", "tr", -1);
    }
    if (tbodyLines) {
      state.push("tbody_close", "tbody", -1);
      tbodyLines[1] = nextLine;
    }
    state.push("table_close", "table", -1);
    tableLines[1] = nextLine;
    state.parentType = oldParentType;
    state.line = nextLine;
    return true;
  }
  function code(state, startLine, endLine) {
    if (state.sCount[startLine] - state.blkIndent < 4) {
      return false;
    }
    let nextLine = startLine + 1;
    let last = nextLine;
    while (nextLine < endLine) {
      if (state.isEmpty(nextLine)) {
        nextLine++;
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        nextLine++;
        last = nextLine;
        continue;
      }
      break;
    }
    state.line = last;
    const token = state.push("code_block", "code", 0);
    token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
    token.map = [startLine, state.line];
    return true;
  }
  function fence(state, startLine, endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (pos + 3 > max) {
      return false;
    }
    const marker = state.src.charCodeAt(pos);
    if (marker !== 126 && marker !== 96) {
      return false;
    }
    let mem = pos;
    pos = state.skipChars(pos, marker);
    let len = pos - mem;
    if (len < 3) {
      return false;
    }
    const markup = state.src.slice(mem, pos);
    const params = state.src.slice(pos, max);
    if (marker === 96) {
      if (params.indexOf(String.fromCharCode(marker)) >= 0) {
        return false;
      }
    }
    if (silent) {
      return true;
    }
    let nextLine = startLine;
    let haveEndMarker = false;
    for (; ; ) {
      nextLine++;
      if (nextLine >= endLine) {
        break;
      }
      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos < max && state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (state.src.charCodeAt(pos) !== marker) {
        continue;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        continue;
      }
      pos = state.skipChars(pos, marker);
      if (pos - mem < len) {
        continue;
      }
      pos = state.skipSpaces(pos);
      if (pos < max) {
        continue;
      }
      haveEndMarker = true;
      break;
    }
    len = state.sCount[startLine];
    state.line = nextLine + (haveEndMarker ? 1 : 0);
    const token = state.push("fence", "code", 0);
    token.info = params;
    token.content = state.getLines(startLine + 1, nextLine, len, true);
    token.markup = markup;
    token.map = [startLine, state.line];
    return true;
  }
  function blockquote(state, startLine, endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max = state.eMarks[startLine];
    const oldLineMax = state.lineMax;
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 62) {
      return false;
    }
    if (silent) {
      return true;
    }
    const oldBMarks = [];
    const oldBSCount = [];
    const oldSCount = [];
    const oldTShift = [];
    const terminatorRules = state.md.block.ruler.getRules("blockquote");
    const oldParentType = state.parentType;
    state.parentType = "blockquote";
    let lastLineEmpty = false;
    let nextLine;
    for (nextLine = startLine; nextLine < endLine; nextLine++) {
      const isOutdented = state.sCount[nextLine] < state.blkIndent;
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos >= max) {
        break;
      }
      if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
        let initial = state.sCount[nextLine] + 1;
        let spaceAfterMarker;
        let adjustTab;
        if (state.src.charCodeAt(pos) === 32) {
          pos++;
          initial++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 9) {
          spaceAfterMarker = true;
          if ((state.bsCount[nextLine] + initial) % 4 === 3) {
            pos++;
            initial++;
            adjustTab = false;
          } else {
            adjustTab = true;
          }
        } else {
          spaceAfterMarker = false;
        }
        let offset = initial;
        oldBMarks.push(state.bMarks[nextLine]);
        state.bMarks[nextLine] = pos;
        while (pos < max) {
          const ch2 = state.src.charCodeAt(pos);
          if (isSpace(ch2)) {
            if (ch2 === 9) {
              offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
            } else {
              offset++;
            }
          } else {
            break;
          }
          pos++;
        }
        lastLineEmpty = pos >= max;
        oldBSCount.push(state.bsCount[nextLine]);
        state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = offset - initial;
        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = pos - state.bMarks[nextLine];
        continue;
      }
      if (lastLineEmpty) {
        break;
      }
      let terminate = false;
      for (let i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
        if (terminatorRules[i2](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        state.lineMax = nextLine;
        if (state.blkIndent !== 0) {
          oldBMarks.push(state.bMarks[nextLine]);
          oldBSCount.push(state.bsCount[nextLine]);
          oldTShift.push(state.tShift[nextLine]);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] -= state.blkIndent;
        }
        break;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      oldBSCount.push(state.bsCount[nextLine]);
      oldTShift.push(state.tShift[nextLine]);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = -1;
    }
    const oldIndent = state.blkIndent;
    state.blkIndent = 0;
    const token_o = state.push("blockquote_open", "blockquote", 1);
    token_o.markup = ">";
    const lines = [startLine, 0];
    token_o.map = lines;
    state.md.block.tokenize(state, startLine, nextLine);
    const token_c = state.push("blockquote_close", "blockquote", -1);
    token_c.markup = ">";
    state.lineMax = oldLineMax;
    state.parentType = oldParentType;
    lines[1] = state.line;
    for (let i2 = 0; i2 < oldTShift.length; i2++) {
      state.bMarks[i2 + startLine] = oldBMarks[i2];
      state.tShift[i2 + startLine] = oldTShift[i2];
      state.sCount[i2 + startLine] = oldSCount[i2];
      state.bsCount[i2 + startLine] = oldBSCount[i2];
    }
    state.blkIndent = oldIndent;
    return true;
  }
  function hr(state, startLine, endLine, silent) {
    const max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    const marker = state.src.charCodeAt(pos++);
    if (marker !== 42 && marker !== 45 && marker !== 95) {
      return false;
    }
    let cnt = 1;
    while (pos < max) {
      const ch2 = state.src.charCodeAt(pos++);
      if (ch2 !== marker && !isSpace(ch2)) {
        return false;
      }
      if (ch2 === marker) {
        cnt++;
      }
    }
    if (cnt < 3) {
      return false;
    }
    if (silent) {
      return true;
    }
    state.line = startLine + 1;
    const token = state.push("hr", "hr", 0);
    token.map = [startLine, state.line];
    token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
    return true;
  }
  function skipBulletListMarker(state, startLine) {
    const max = state.eMarks[startLine];
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    const marker = state.src.charCodeAt(pos++);
    if (marker !== 42 && marker !== 45 && marker !== 43) {
      return -1;
    }
    if (pos < max) {
      const ch2 = state.src.charCodeAt(pos);
      if (!isSpace(ch2)) {
        return -1;
      }
    }
    return pos;
  }
  function skipOrderedListMarker(state, startLine) {
    const start = state.bMarks[startLine] + state.tShift[startLine];
    const max = state.eMarks[startLine];
    let pos = start;
    if (pos + 1 >= max) {
      return -1;
    }
    let ch2 = state.src.charCodeAt(pos++);
    if (ch2 < 48 || ch2 > 57) {
      return -1;
    }
    for (; ; ) {
      if (pos >= max) {
        return -1;
      }
      ch2 = state.src.charCodeAt(pos++);
      if (ch2 >= 48 && ch2 <= 57) {
        if (pos - start >= 10) {
          return -1;
        }
        continue;
      }
      if (ch2 === 41 || ch2 === 46) {
        break;
      }
      return -1;
    }
    if (pos < max) {
      ch2 = state.src.charCodeAt(pos);
      if (!isSpace(ch2)) {
        return -1;
      }
    }
    return pos;
  }
  function markTightParagraphs(state, idx) {
    const level = state.level + 2;
    for (let i2 = idx + 2, l2 = state.tokens.length - 2; i2 < l2; i2++) {
      if (state.tokens[i2].level === level && state.tokens[i2].type === "paragraph_open") {
        state.tokens[i2 + 2].hidden = true;
        state.tokens[i2].hidden = true;
        i2 += 2;
      }
    }
  }
  function list(state, startLine, endLine, silent) {
    let max, pos, start, token;
    let nextLine = startLine;
    let tight = true;
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
      return false;
    }
    let isTerminatingParagraph = false;
    if (silent && state.parentType === "paragraph") {
      if (state.sCount[nextLine] >= state.blkIndent) {
        isTerminatingParagraph = true;
      }
    }
    let isOrdered;
    let markerValue;
    let posAfterMarker;
    if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
      isOrdered = true;
      start = state.bMarks[nextLine] + state.tShift[nextLine];
      markerValue = Number(state.src.slice(start, posAfterMarker - 1));
      if (isTerminatingParagraph && markerValue !== 1)
        return false;
    } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
      isOrdered = false;
    } else {
      return false;
    }
    if (isTerminatingParagraph) {
      if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
        return false;
    }
    if (silent) {
      return true;
    }
    const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
    const listTokIdx = state.tokens.length;
    if (isOrdered) {
      token = state.push("ordered_list_open", "ol", 1);
      if (markerValue !== 1) {
        token.attrs = [["start", markerValue]];
      }
    } else {
      token = state.push("bullet_list_open", "ul", 1);
    }
    const listLines = [nextLine, 0];
    token.map = listLines;
    token.markup = String.fromCharCode(markerCharCode);
    let prevEmptyEnd = false;
    const terminatorRules = state.md.block.ruler.getRules("list");
    const oldParentType = state.parentType;
    state.parentType = "list";
    while (nextLine < endLine) {
      pos = posAfterMarker;
      max = state.eMarks[nextLine];
      const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
      let offset = initial;
      while (pos < max) {
        const ch2 = state.src.charCodeAt(pos);
        if (ch2 === 9) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else if (ch2 === 32) {
          offset++;
        } else {
          break;
        }
        pos++;
      }
      const contentStart = pos;
      let indentAfterMarker;
      if (contentStart >= max) {
        indentAfterMarker = 1;
      } else {
        indentAfterMarker = offset - initial;
      }
      if (indentAfterMarker > 4) {
        indentAfterMarker = 1;
      }
      const indent = initial + indentAfterMarker;
      token = state.push("list_item_open", "li", 1);
      token.markup = String.fromCharCode(markerCharCode);
      const itemLines = [nextLine, 0];
      token.map = itemLines;
      if (isOrdered) {
        token.info = state.src.slice(start, posAfterMarker - 1);
      }
      const oldTight = state.tight;
      const oldTShift = state.tShift[nextLine];
      const oldSCount = state.sCount[nextLine];
      const oldListIndent = state.listIndent;
      state.listIndent = state.blkIndent;
      state.blkIndent = indent;
      state.tight = true;
      state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
      state.sCount[nextLine] = offset;
      if (contentStart >= max && state.isEmpty(nextLine + 1)) {
        state.line = Math.min(state.line + 2, endLine);
      } else {
        state.md.block.tokenize(state, nextLine, endLine, true);
      }
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
      state.blkIndent = state.listIndent;
      state.listIndent = oldListIndent;
      state.tShift[nextLine] = oldTShift;
      state.sCount[nextLine] = oldSCount;
      state.tight = oldTight;
      token = state.push("list_item_close", "li", -1);
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = state.line;
      itemLines[1] = nextLine;
      if (nextLine >= endLine) {
        break;
      }
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        break;
      }
      let terminate = false;
      for (let i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
        if (terminatorRules[i2](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
      if (isOrdered) {
        posAfterMarker = skipOrderedListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
        start = state.bMarks[nextLine] + state.tShift[nextLine];
      } else {
        posAfterMarker = skipBulletListMarker(state, nextLine);
        if (posAfterMarker < 0) {
          break;
        }
      }
      if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
        break;
      }
    }
    if (isOrdered) {
      token = state.push("ordered_list_close", "ol", -1);
    } else {
      token = state.push("bullet_list_close", "ul", -1);
    }
    token.markup = String.fromCharCode(markerCharCode);
    listLines[1] = nextLine;
    state.line = nextLine;
    state.parentType = oldParentType;
    if (tight) {
      markTightParagraphs(state, listTokIdx);
    }
    return true;
  }
  function reference(state, startLine, _endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max = state.eMarks[startLine];
    let nextLine = startLine + 1;
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 91) {
      return false;
    }
    function getNextLine(nextLine2) {
      const endLine = state.lineMax;
      if (nextLine2 >= endLine || state.isEmpty(nextLine2)) {
        return null;
      }
      let isContinuation = false;
      if (state.sCount[nextLine2] - state.blkIndent > 3) {
        isContinuation = true;
      }
      if (state.sCount[nextLine2] < 0) {
        isContinuation = true;
      }
      if (!isContinuation) {
        const terminatorRules = state.md.block.ruler.getRules("reference");
        const oldParentType = state.parentType;
        state.parentType = "reference";
        let terminate = false;
        for (let i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine2, endLine, true)) {
            terminate = true;
            break;
          }
        }
        state.parentType = oldParentType;
        if (terminate) {
          return null;
        }
      }
      const pos2 = state.bMarks[nextLine2] + state.tShift[nextLine2];
      const max2 = state.eMarks[nextLine2];
      return state.src.slice(pos2, max2 + 1);
    }
    let str2 = state.src.slice(pos, max + 1);
    max = str2.length;
    let labelEnd = -1;
    for (pos = 1; pos < max; pos++) {
      const ch2 = str2.charCodeAt(pos);
      if (ch2 === 91) {
        return false;
      } else if (ch2 === 93) {
        labelEnd = pos;
        break;
      } else if (ch2 === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str2 += lineContent;
          max = str2.length;
          nextLine++;
        }
      } else if (ch2 === 92) {
        pos++;
        if (pos < max && str2.charCodeAt(pos) === 10) {
          const lineContent = getNextLine(nextLine);
          if (lineContent !== null) {
            str2 += lineContent;
            max = str2.length;
            nextLine++;
          }
        }
      }
    }
    if (labelEnd < 0 || str2.charCodeAt(labelEnd + 1) !== 58) {
      return false;
    }
    for (pos = labelEnd + 2; pos < max; pos++) {
      const ch2 = str2.charCodeAt(pos);
      if (ch2 === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str2 += lineContent;
          max = str2.length;
          nextLine++;
        }
      } else if (isSpace(ch2))
        ;
      else {
        break;
      }
    }
    const destRes = state.md.helpers.parseLinkDestination(str2, pos, max);
    if (!destRes.ok) {
      return false;
    }
    const href = state.md.normalizeLink(destRes.str);
    if (!state.md.validateLink(href)) {
      return false;
    }
    pos = destRes.pos;
    const destEndPos = pos;
    const destEndLineNo = nextLine;
    const start = pos;
    for (; pos < max; pos++) {
      const ch2 = str2.charCodeAt(pos);
      if (ch2 === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str2 += lineContent;
          max = str2.length;
          nextLine++;
        }
      } else if (isSpace(ch2))
        ;
      else {
        break;
      }
    }
    let titleRes = state.md.helpers.parseLinkTitle(str2, pos, max);
    while (titleRes.can_continue) {
      const lineContent = getNextLine(nextLine);
      if (lineContent === null)
        break;
      str2 += lineContent;
      pos = max;
      max = str2.length;
      nextLine++;
      titleRes = state.md.helpers.parseLinkTitle(str2, pos, max, titleRes);
    }
    let title;
    if (pos < max && start !== pos && titleRes.ok) {
      title = titleRes.str;
      pos = titleRes.pos;
    } else {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
    }
    while (pos < max) {
      const ch2 = str2.charCodeAt(pos);
      if (!isSpace(ch2)) {
        break;
      }
      pos++;
    }
    if (pos < max && str2.charCodeAt(pos) !== 10) {
      if (title) {
        title = "";
        pos = destEndPos;
        nextLine = destEndLineNo;
        while (pos < max) {
          const ch2 = str2.charCodeAt(pos);
          if (!isSpace(ch2)) {
            break;
          }
          pos++;
        }
      }
    }
    if (pos < max && str2.charCodeAt(pos) !== 10) {
      return false;
    }
    const label = normalizeReference(str2.slice(1, labelEnd));
    if (!label) {
      return false;
    }
    if (silent) {
      return true;
    }
    if (typeof state.env.references === "undefined") {
      state.env.references = {};
    }
    if (typeof state.env.references[label] === "undefined") {
      state.env.references[label] = { title, href };
    }
    state.line = nextLine;
    return true;
  }
  const block_names = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
  const attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
  const unquoted = "[^\"'=<>`\\x00-\\x20]+";
  const single_quoted = "'[^']*'";
  const double_quoted = '"[^"]*"';
  const attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
  const attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
  const open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
  const close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
  const comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
  const processing = "<[?][\\s\\S]*?[?]>";
  const declaration = "<![A-Za-z][^>]*>";
  const cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
  const HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
  const HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
  const HTML_SEQUENCES = [
    [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
    [/^<!--/, /-->/, true],
    [/^<\?/, /\?>/, true],
    [/^<![A-Z]/, />/, true],
    [/^<!\[CDATA\[/, /\]\]>/, true],
    [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
    [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
  ];
  function html_block(state, startLine, endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (!state.md.options.html) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    let lineText = state.src.slice(pos, max);
    let i2 = 0;
    for (; i2 < HTML_SEQUENCES.length; i2++) {
      if (HTML_SEQUENCES[i2][0].test(lineText)) {
        break;
      }
    }
    if (i2 === HTML_SEQUENCES.length) {
      return false;
    }
    if (silent) {
      return HTML_SEQUENCES[i2][2];
    }
    let nextLine = startLine + 1;
    if (!HTML_SEQUENCES[i2][1].test(lineText)) {
      for (; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        lineText = state.src.slice(pos, max);
        if (HTML_SEQUENCES[i2][1].test(lineText)) {
          if (lineText.length !== 0) {
            nextLine++;
          }
          break;
        }
      }
    }
    state.line = nextLine;
    const token = state.push("html_block", "", 0);
    token.map = [startLine, nextLine];
    token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
    return true;
  }
  function heading(state, startLine, endLine, silent) {
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    let ch2 = state.src.charCodeAt(pos);
    if (ch2 !== 35 || pos >= max) {
      return false;
    }
    let level = 1;
    ch2 = state.src.charCodeAt(++pos);
    while (ch2 === 35 && pos < max && level <= 6) {
      level++;
      ch2 = state.src.charCodeAt(++pos);
    }
    if (level > 6 || pos < max && !isSpace(ch2)) {
      return false;
    }
    if (silent) {
      return true;
    }
    max = state.skipSpacesBack(max, pos);
    const tmp = state.skipCharsBack(max, 35, pos);
    if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
      max = tmp;
    }
    state.line = startLine + 1;
    const token_o = state.push("heading_open", "h" + String(level), 1);
    token_o.markup = "########".slice(0, level);
    token_o.map = [startLine, state.line];
    const token_i = state.push("inline", "", 0);
    token_i.content = state.src.slice(pos, max).trim();
    token_i.map = [startLine, state.line];
    token_i.children = [];
    const token_c = state.push("heading_close", "h" + String(level), -1);
    token_c.markup = "########".slice(0, level);
    return true;
  }
  function lheading(state, startLine, endLine) {
    const terminatorRules = state.md.block.ruler.getRules("paragraph");
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    const oldParentType = state.parentType;
    state.parentType = "paragraph";
    let level = 0;
    let marker;
    let nextLine = startLine + 1;
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] >= state.blkIndent) {
        let pos = state.bMarks[nextLine] + state.tShift[nextLine];
        const max = state.eMarks[nextLine];
        if (pos < max) {
          marker = state.src.charCodeAt(pos);
          if (marker === 45 || marker === 61) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);
            if (pos >= max) {
              level = marker === 61 ? 1 : 2;
              break;
            }
          }
        }
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      let terminate = false;
      for (let i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
        if (terminatorRules[i2](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    if (!level) {
      return false;
    }
    const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine + 1;
    const token_o = state.push("heading_open", "h" + String(level), 1);
    token_o.markup = String.fromCharCode(marker);
    token_o.map = [startLine, state.line];
    const token_i = state.push("inline", "", 0);
    token_i.content = content;
    token_i.map = [startLine, state.line - 1];
    token_i.children = [];
    const token_c = state.push("heading_close", "h" + String(level), -1);
    token_c.markup = String.fromCharCode(marker);
    state.parentType = oldParentType;
    return true;
  }
  function paragraph(state, startLine, endLine) {
    const terminatorRules = state.md.block.ruler.getRules("paragraph");
    const oldParentType = state.parentType;
    let nextLine = startLine + 1;
    state.parentType = "paragraph";
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      if (state.sCount[nextLine] - state.blkIndent > 3) {
        continue;
      }
      if (state.sCount[nextLine] < 0) {
        continue;
      }
      let terminate = false;
      for (let i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
        if (terminatorRules[i2](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
    const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    state.line = nextLine;
    const token_o = state.push("paragraph_open", "p", 1);
    token_o.map = [startLine, state.line];
    const token_i = state.push("inline", "", 0);
    token_i.content = content;
    token_i.map = [startLine, state.line];
    token_i.children = [];
    state.push("paragraph_close", "p", -1);
    state.parentType = oldParentType;
    return true;
  }
  const _rules$1 = [
    // First 2 params - rule name & source. Secondary array - list of rules,
    // which can be terminated by this one.
    ["table", table, ["paragraph", "reference"]],
    ["code", code],
    ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
    ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
    ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
    ["list", list, ["paragraph", "reference", "blockquote"]],
    ["reference", reference],
    ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
    ["heading", heading, ["paragraph", "reference", "blockquote"]],
    ["lheading", lheading],
    ["paragraph", paragraph]
  ];
  function ParserBlock() {
    this.ruler = new Ruler();
    for (let i2 = 0; i2 < _rules$1.length; i2++) {
      this.ruler.push(_rules$1[i2][0], _rules$1[i2][1], { alt: (_rules$1[i2][2] || []).slice() });
    }
  }
  ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
    const rules = this.ruler.getRules("");
    const len = rules.length;
    const maxNesting = state.md.options.maxNesting;
    let line = startLine;
    let hasEmptyLines = false;
    while (line < endLine) {
      state.line = line = state.skipEmptyLines(line);
      if (line >= endLine) {
        break;
      }
      if (state.sCount[line] < state.blkIndent) {
        break;
      }
      if (state.level >= maxNesting) {
        state.line = endLine;
        break;
      }
      const prevLine = state.line;
      let ok2 = false;
      for (let i2 = 0; i2 < len; i2++) {
        ok2 = rules[i2](state, line, endLine, false);
        if (ok2) {
          if (prevLine >= state.line) {
            throw new Error("block rule didn't increment state.line");
          }
          break;
        }
      }
      if (!ok2)
        throw new Error("none of the block rules matched");
      state.tight = !hasEmptyLines;
      if (state.isEmpty(state.line - 1)) {
        hasEmptyLines = true;
      }
      line = state.line;
      if (line < endLine && state.isEmpty(line)) {
        hasEmptyLines = true;
        line++;
        state.line = line;
      }
    }
  };
  ParserBlock.prototype.parse = function(src, md2, env, outTokens) {
    if (!src) {
      return;
    }
    const state = new this.State(src, md2, env, outTokens);
    this.tokenize(state, state.line, state.lineMax);
  };
  ParserBlock.prototype.State = StateBlock;
  function StateInline(src, md2, env, outTokens) {
    this.src = src;
    this.env = env;
    this.md = md2;
    this.tokens = outTokens;
    this.tokens_meta = Array(outTokens.length);
    this.pos = 0;
    this.posMax = this.src.length;
    this.level = 0;
    this.pending = "";
    this.pendingLevel = 0;
    this.cache = {};
    this.delimiters = [];
    this._prev_delimiters = [];
    this.backticks = {};
    this.backticksScanned = false;
    this.linkLevel = 0;
  }
  StateInline.prototype.pushPending = function() {
    const token = new Token("text", "", 0);
    token.content = this.pending;
    token.level = this.pendingLevel;
    this.tokens.push(token);
    this.pending = "";
    return token;
  };
  StateInline.prototype.push = function(type2, tag, nesting) {
    if (this.pending) {
      this.pushPending();
    }
    const token = new Token(type2, tag, nesting);
    let token_meta = null;
    if (nesting < 0) {
      this.level--;
      this.delimiters = this._prev_delimiters.pop();
    }
    token.level = this.level;
    if (nesting > 0) {
      this.level++;
      this._prev_delimiters.push(this.delimiters);
      this.delimiters = [];
      token_meta = { delimiters: this.delimiters };
    }
    this.pendingLevel = this.level;
    this.tokens.push(token);
    this.tokens_meta.push(token_meta);
    return token;
  };
  StateInline.prototype.scanDelims = function(start, canSplitWord) {
    const max = this.posMax;
    const marker = this.src.charCodeAt(start);
    const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
    let pos = start;
    while (pos < max && this.src.charCodeAt(pos) === marker) {
      pos++;
    }
    const count = pos - start;
    const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
    const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
    const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
    const isLastWhiteSpace = isWhiteSpace(lastChar);
    const isNextWhiteSpace = isWhiteSpace(nextChar);
    const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
    const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
    const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
    const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
    return { can_open, can_close, length: count };
  };
  StateInline.prototype.Token = Token;
  function isTerminatorChar(ch2) {
    switch (ch2) {
      case 10:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 42:
      case 43:
      case 45:
      case 58:
      case 60:
      case 61:
      case 62:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function text(state, silent) {
    let pos = state.pos;
    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
      pos++;
    }
    if (pos === state.pos) {
      return false;
    }
    if (!silent) {
      state.pending += state.src.slice(state.pos, pos);
    }
    state.pos = pos;
    return true;
  }
  const SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
  function linkify(state, silent) {
    if (!state.md.options.linkify)
      return false;
    if (state.linkLevel > 0)
      return false;
    const pos = state.pos;
    const max = state.posMax;
    if (pos + 3 > max)
      return false;
    if (state.src.charCodeAt(pos) !== 58)
      return false;
    if (state.src.charCodeAt(pos + 1) !== 47)
      return false;
    if (state.src.charCodeAt(pos + 2) !== 47)
      return false;
    const match = state.pending.match(SCHEME_RE);
    if (!match)
      return false;
    const proto = match[1];
    const link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
    if (!link2)
      return false;
    let url2 = link2.url;
    if (url2.length <= proto.length)
      return false;
    url2 = url2.replace(/\*+$/, "");
    const fullUrl = state.md.normalizeLink(url2);
    if (!state.md.validateLink(fullUrl))
      return false;
    if (!silent) {
      state.pending = state.pending.slice(0, -proto.length);
      const token_o = state.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "linkify";
      token_o.info = "auto";
      const token_t = state.push("text", "", 0);
      token_t.content = state.md.normalizeLinkText(url2);
      const token_c = state.push("link_close", "a", -1);
      token_c.markup = "linkify";
      token_c.info = "auto";
    }
    state.pos += url2.length - proto.length;
    return true;
  }
  function newline(state, silent) {
    let pos = state.pos;
    if (state.src.charCodeAt(pos) !== 10) {
      return false;
    }
    const pmax = state.pending.length - 1;
    const max = state.posMax;
    if (!silent) {
      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
          let ws = pmax - 1;
          while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
            ws--;
          state.pending = state.pending.slice(0, ws);
          state.push("hardbreak", "br", 0);
        } else {
          state.pending = state.pending.slice(0, -1);
          state.push("softbreak", "br", 0);
        }
      } else {
        state.push("softbreak", "br", 0);
      }
    }
    pos++;
    while (pos < max && isSpace(state.src.charCodeAt(pos))) {
      pos++;
    }
    state.pos = pos;
    return true;
  }
  const ESCAPED = [];
  for (let i2 = 0; i2 < 256; i2++) {
    ESCAPED.push(0);
  }
  "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch2) {
    ESCAPED[ch2.charCodeAt(0)] = 1;
  });
  function escape$1(state, silent) {
    let pos = state.pos;
    const max = state.posMax;
    if (state.src.charCodeAt(pos) !== 92)
      return false;
    pos++;
    if (pos >= max)
      return false;
    let ch1 = state.src.charCodeAt(pos);
    if (ch1 === 10) {
      if (!silent) {
        state.push("hardbreak", "br", 0);
      }
      pos++;
      while (pos < max) {
        ch1 = state.src.charCodeAt(pos);
        if (!isSpace(ch1))
          break;
        pos++;
      }
      state.pos = pos;
      return true;
    }
    let escapedStr = state.src[pos];
    if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
      const ch2 = state.src.charCodeAt(pos + 1);
      if (ch2 >= 56320 && ch2 <= 57343) {
        escapedStr += state.src[pos + 1];
        pos++;
      }
    }
    const origStr = "\\" + escapedStr;
    if (!silent) {
      const token = state.push("text_special", "", 0);
      if (ch1 < 256 && ESCAPED[ch1] !== 0) {
        token.content = escapedStr;
      } else {
        token.content = origStr;
      }
      token.markup = origStr;
      token.info = "escape";
    }
    state.pos = pos + 1;
    return true;
  }
  function backtick(state, silent) {
    let pos = state.pos;
    const ch2 = state.src.charCodeAt(pos);
    if (ch2 !== 96) {
      return false;
    }
    const start = pos;
    pos++;
    const max = state.posMax;
    while (pos < max && state.src.charCodeAt(pos) === 96) {
      pos++;
    }
    const marker = state.src.slice(start, pos);
    const openerLength = marker.length;
    if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    }
    let matchEnd = pos;
    let matchStart;
    while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
      matchEnd = matchStart + 1;
      while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
        matchEnd++;
      }
      const closerLength = matchEnd - matchStart;
      if (closerLength === openerLength) {
        if (!silent) {
          const token = state.push("code_inline", "code", 0);
          token.markup = marker;
          token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
        }
        state.pos = matchEnd;
        return true;
      }
      state.backticks[closerLength] = matchStart;
    }
    state.backticksScanned = true;
    if (!silent)
      state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  function strikethrough_tokenize(state, silent) {
    const start = state.pos;
    const marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 126) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, true);
    let len = scanned.length;
    const ch2 = String.fromCharCode(marker);
    if (len < 2) {
      return false;
    }
    let token;
    if (len % 2) {
      token = state.push("text", "", 0);
      token.content = ch2;
      len--;
    }
    for (let i2 = 0; i2 < len; i2 += 2) {
      token = state.push("text", "", 0);
      token.content = ch2 + ch2;
      state.delimiters.push({
        marker,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        token: state.tokens.length - 1,
        end: -1,
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess$1(state, delimiters) {
    let token;
    const loneMarkers = [];
    const max = delimiters.length;
    for (let i2 = 0; i2 < max; i2++) {
      const startDelim = delimiters[i2];
      if (startDelim.marker !== 126) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      token = state.tokens[startDelim.token];
      token.type = "s_open";
      token.tag = "s";
      token.nesting = 1;
      token.markup = "~~";
      token.content = "";
      token = state.tokens[endDelim.token];
      token.type = "s_close";
      token.tag = "s";
      token.nesting = -1;
      token.markup = "~~";
      token.content = "";
      if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
        loneMarkers.push(endDelim.token - 1);
      }
    }
    while (loneMarkers.length) {
      const i2 = loneMarkers.pop();
      let j2 = i2 + 1;
      while (j2 < state.tokens.length && state.tokens[j2].type === "s_close") {
        j2++;
      }
      j2--;
      if (i2 !== j2) {
        token = state.tokens[j2];
        state.tokens[j2] = state.tokens[i2];
        state.tokens[i2] = token;
      }
    }
  }
  function strikethrough_postProcess(state) {
    const tokens_meta = state.tokens_meta;
    const max = state.tokens_meta.length;
    postProcess$1(state, state.delimiters);
    for (let curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess$1(state, tokens_meta[curr].delimiters);
      }
    }
  }
  const r_strikethrough = {
    tokenize: strikethrough_tokenize,
    postProcess: strikethrough_postProcess
  };
  function emphasis_tokenize(state, silent) {
    const start = state.pos;
    const marker = state.src.charCodeAt(start);
    if (silent) {
      return false;
    }
    if (marker !== 95 && marker !== 42) {
      return false;
    }
    const scanned = state.scanDelims(state.pos, marker === 42);
    for (let i2 = 0; i2 < scanned.length; i2++) {
      const token = state.push("text", "", 0);
      token.content = String.fromCharCode(marker);
      state.delimiters.push({
        // Char code of the starting marker (number).
        //
        marker,
        // Total length of these series of delimiters.
        //
        length: scanned.length,
        // A position of the token this delimiter corresponds to.
        //
        token: state.tokens.length - 1,
        // If this delimiter is matched as a valid opener, `end` will be
        // equal to its position, otherwise it's `-1`.
        //
        end: -1,
        // Boolean flags that determine if this delimiter could open or close
        // an emphasis.
        //
        open: scanned.can_open,
        close: scanned.can_close
      });
    }
    state.pos += scanned.length;
    return true;
  }
  function postProcess(state, delimiters) {
    const max = delimiters.length;
    for (let i2 = max - 1; i2 >= 0; i2--) {
      const startDelim = delimiters[i2];
      if (startDelim.marker !== 95 && startDelim.marker !== 42) {
        continue;
      }
      if (startDelim.end === -1) {
        continue;
      }
      const endDelim = delimiters[startDelim.end];
      const isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
      delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
      delimiters[startDelim.end + 1].token === endDelim.token + 1;
      const ch2 = String.fromCharCode(startDelim.marker);
      const token_o = state.tokens[startDelim.token];
      token_o.type = isStrong ? "strong_open" : "em_open";
      token_o.tag = isStrong ? "strong" : "em";
      token_o.nesting = 1;
      token_o.markup = isStrong ? ch2 + ch2 : ch2;
      token_o.content = "";
      const token_c = state.tokens[endDelim.token];
      token_c.type = isStrong ? "strong_close" : "em_close";
      token_c.tag = isStrong ? "strong" : "em";
      token_c.nesting = -1;
      token_c.markup = isStrong ? ch2 + ch2 : ch2;
      token_c.content = "";
      if (isStrong) {
        state.tokens[delimiters[i2 - 1].token].content = "";
        state.tokens[delimiters[startDelim.end + 1].token].content = "";
        i2--;
      }
    }
  }
  function emphasis_post_process(state) {
    const tokens_meta = state.tokens_meta;
    const max = state.tokens_meta.length;
    postProcess(state, state.delimiters);
    for (let curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess(state, tokens_meta[curr].delimiters);
      }
    }
  }
  const r_emphasis = {
    tokenize: emphasis_tokenize,
    postProcess: emphasis_post_process
  };
  function link(state, silent) {
    let code2, label, res, ref;
    let href = "";
    let title = "";
    let start = state.pos;
    let parseReference = true;
    if (state.src.charCodeAt(state.pos) !== 91) {
      return false;
    }
    const oldPos = state.pos;
    const max = state.posMax;
    const labelStart = state.pos + 1;
    const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
    if (labelEnd < 0) {
      return false;
    }
    let pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      parseReference = false;
      pos++;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
        start = pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        }
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41) {
        parseReference = true;
      }
      pos++;
    }
    if (parseReference) {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;
      const token_o = state.push("link_open", "a", 1);
      const attrs = [["href", href]];
      token_o.attrs = attrs;
      if (title) {
        attrs.push(["title", title]);
      }
      state.linkLevel++;
      state.md.inline.tokenize(state);
      state.linkLevel--;
      state.push("link_close", "a", -1);
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  }
  function image(state, silent) {
    let code2, content, label, pos, ref, res, title, start;
    let href = "";
    const oldPos = state.pos;
    const max = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 33) {
      return false;
    }
    if (state.src.charCodeAt(state.pos + 1) !== 91) {
      return false;
    }
    const labelStart = state.pos + 2;
    const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
    if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      pos++;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      } else {
        title = "";
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41) {
        state.pos = oldPos;
        return false;
      }
      pos++;
    } else {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      content = state.src.slice(labelStart, labelEnd);
      const tokens = [];
      state.md.inline.parse(
        content,
        state.md,
        state.env,
        tokens
      );
      const token = state.push("image", "img", 0);
      const attrs = [["src", href], ["alt", ""]];
      token.attrs = attrs;
      token.children = tokens;
      token.content = content;
      if (title) {
        attrs.push(["title", title]);
      }
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  }
  const EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
  const AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
  function autolink(state, silent) {
    let pos = state.pos;
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    const start = state.pos;
    const max = state.posMax;
    for (; ; ) {
      if (++pos >= max)
        return false;
      const ch2 = state.src.charCodeAt(pos);
      if (ch2 === 60)
        return false;
      if (ch2 === 62)
        break;
    }
    const url2 = state.src.slice(start + 1, pos);
    if (AUTOLINK_RE.test(url2)) {
      const fullUrl = state.md.normalizeLink(url2);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        const token_o = state.push("link_open", "a", 1);
        token_o.attrs = [["href", fullUrl]];
        token_o.markup = "autolink";
        token_o.info = "auto";
        const token_t = state.push("text", "", 0);
        token_t.content = state.md.normalizeLinkText(url2);
        const token_c = state.push("link_close", "a", -1);
        token_c.markup = "autolink";
        token_c.info = "auto";
      }
      state.pos += url2.length + 2;
      return true;
    }
    if (EMAIL_RE.test(url2)) {
      const fullUrl = state.md.normalizeLink("mailto:" + url2);
      if (!state.md.validateLink(fullUrl)) {
        return false;
      }
      if (!silent) {
        const token_o = state.push("link_open", "a", 1);
        token_o.attrs = [["href", fullUrl]];
        token_o.markup = "autolink";
        token_o.info = "auto";
        const token_t = state.push("text", "", 0);
        token_t.content = state.md.normalizeLinkText(url2);
        const token_c = state.push("link_close", "a", -1);
        token_c.markup = "autolink";
        token_c.info = "auto";
      }
      state.pos += url2.length + 2;
      return true;
    }
    return false;
  }
  function isLinkOpen(str2) {
    return /^<a[>\s]/i.test(str2);
  }
  function isLinkClose(str2) {
    return /^<\/a\s*>/i.test(str2);
  }
  function isLetter(ch2) {
    const lc2 = ch2 | 32;
    return lc2 >= 97 && lc2 <= 122;
  }
  function html_inline(state, silent) {
    if (!state.md.options.html) {
      return false;
    }
    const max = state.posMax;
    const pos = state.pos;
    if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
      return false;
    }
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 !== 33 && ch2 !== 63 && ch2 !== 47 && !isLetter(ch2)) {
      return false;
    }
    const match = state.src.slice(pos).match(HTML_TAG_RE);
    if (!match) {
      return false;
    }
    if (!silent) {
      const token = state.push("html_inline", "", 0);
      token.content = match[0];
      if (isLinkOpen(token.content))
        state.linkLevel++;
      if (isLinkClose(token.content))
        state.linkLevel--;
    }
    state.pos += match[0].length;
    return true;
  }
  const DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
  const NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
  function entity(state, silent) {
    const pos = state.pos;
    const max = state.posMax;
    if (state.src.charCodeAt(pos) !== 38)
      return false;
    if (pos + 1 >= max)
      return false;
    const ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 === 35) {
      const match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          const code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          const token = state.push("text_special", "", 0);
          token.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
          token.markup = match[0];
          token.info = "entity";
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      const match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        const decoded = decodeHTML(match[0]);
        if (decoded !== match[0]) {
          if (!silent) {
            const token = state.push("text_special", "", 0);
            token.content = decoded;
            token.markup = match[0];
            token.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      }
    }
    return false;
  }
  function processDelimiters(delimiters) {
    const openersBottom = {};
    const max = delimiters.length;
    if (!max)
      return;
    let headerIdx = 0;
    let lastTokenIdx = -2;
    const jumps = [];
    for (let closerIdx = 0; closerIdx < max; closerIdx++) {
      const closer = delimiters[closerIdx];
      jumps.push(0);
      if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
        headerIdx = closerIdx;
      }
      lastTokenIdx = closer.token;
      closer.length = closer.length || 0;
      if (!closer.close)
        continue;
      if (!openersBottom.hasOwnProperty(closer.marker)) {
        openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
      }
      const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
      let openerIdx = headerIdx - jumps[headerIdx] - 1;
      let newMinOpenerIdx = openerIdx;
      for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
        const opener = delimiters[openerIdx];
        if (opener.marker !== closer.marker)
          continue;
        if (opener.open && opener.end < 0) {
          let isOddMatch = false;
          if (opener.close || closer.open) {
            if ((opener.length + closer.length) % 3 === 0) {
              if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                isOddMatch = true;
              }
            }
          }
          if (!isOddMatch) {
            const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
            jumps[closerIdx] = closerIdx - openerIdx + lastJump;
            jumps[openerIdx] = lastJump;
            closer.open = false;
            opener.end = closerIdx;
            opener.close = false;
            newMinOpenerIdx = -1;
            lastTokenIdx = -2;
            break;
          }
        }
      }
      if (newMinOpenerIdx !== -1) {
        openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
      }
    }
  }
  function link_pairs(state) {
    const tokens_meta = state.tokens_meta;
    const max = state.tokens_meta.length;
    processDelimiters(state.delimiters);
    for (let curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        processDelimiters(tokens_meta[curr].delimiters);
      }
    }
  }
  function fragments_join(state) {
    let curr, last;
    let level = 0;
    const tokens = state.tokens;
    const max = state.tokens.length;
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].nesting < 0)
        level--;
      tokens[curr].level = level;
      if (tokens[curr].nesting > 0)
        level++;
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  }
  const _rules = [
    ["text", text],
    ["linkify", linkify],
    ["newline", newline],
    ["escape", escape$1],
    ["backticks", backtick],
    ["strikethrough", r_strikethrough.tokenize],
    ["emphasis", r_emphasis.tokenize],
    ["link", link],
    ["image", image],
    ["autolink", autolink],
    ["html_inline", html_inline],
    ["entity", entity]
  ];
  const _rules2 = [
    ["balance_pairs", link_pairs],
    ["strikethrough", r_strikethrough.postProcess],
    ["emphasis", r_emphasis.postProcess],
    // rules for pairs separate '**' into its own text tokens, which may be left unused,
    // rule below merges unused segments back with the rest of the text
    ["fragments_join", fragments_join]
  ];
  function ParserInline() {
    this.ruler = new Ruler();
    for (let i2 = 0; i2 < _rules.length; i2++) {
      this.ruler.push(_rules[i2][0], _rules[i2][1]);
    }
    this.ruler2 = new Ruler();
    for (let i2 = 0; i2 < _rules2.length; i2++) {
      this.ruler2.push(_rules2[i2][0], _rules2[i2][1]);
    }
  }
  ParserInline.prototype.skipToken = function(state) {
    const pos = state.pos;
    const rules = this.ruler.getRules("");
    const len = rules.length;
    const maxNesting = state.md.options.maxNesting;
    const cache2 = state.cache;
    if (typeof cache2[pos] !== "undefined") {
      state.pos = cache2[pos];
      return;
    }
    let ok2 = false;
    if (state.level < maxNesting) {
      for (let i2 = 0; i2 < len; i2++) {
        state.level++;
        ok2 = rules[i2](state, true);
        state.level--;
        if (ok2) {
          if (pos >= state.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    } else {
      state.pos = state.posMax;
    }
    if (!ok2) {
      state.pos++;
    }
    cache2[pos] = state.pos;
  };
  ParserInline.prototype.tokenize = function(state) {
    const rules = this.ruler.getRules("");
    const len = rules.length;
    const end = state.posMax;
    const maxNesting = state.md.options.maxNesting;
    while (state.pos < end) {
      const prevPos = state.pos;
      let ok2 = false;
      if (state.level < maxNesting) {
        for (let i2 = 0; i2 < len; i2++) {
          ok2 = rules[i2](state, false);
          if (ok2) {
            if (prevPos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      }
      if (ok2) {
        if (state.pos >= end) {
          break;
        }
        continue;
      }
      state.pending += state.src[state.pos++];
    }
    if (state.pending) {
      state.pushPending();
    }
  };
  ParserInline.prototype.parse = function(str2, md2, env, outTokens) {
    const state = new this.State(str2, md2, env, outTokens);
    this.tokenize(state);
    const rules = this.ruler2.getRules("");
    const len = rules.length;
    for (let i2 = 0; i2 < len; i2++) {
      rules[i2](state);
    }
  };
  ParserInline.prototype.State = StateInline;
  function reFactory(opts) {
    const re2 = {};
    opts = opts || {};
    re2.src_Any = Any.source;
    re2.src_Cc = Cc.source;
    re2.src_Z = Z$2.source;
    re2.src_P = P$1.source;
    re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
    re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
    const text_separators = "[><｜]";
    re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
    re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
    re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
    re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
    re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
    re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
    ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
    re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
    re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
    re2.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
    re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
    re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
    re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
    re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
    re2.src_host_strict = re2.src_host + re2.src_host_terminator;
    re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
    re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
    re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
    re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
    re2.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re2.src_ZPCc + "))((?![$+<=>^`|｜])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
    re2.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re2.src_ZPCc + "))((?![$+<=>^`|｜])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
    return re2;
  }
  function assign(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function _class$1(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString$2(obj) {
    return _class$1(obj) === "[object String]";
  }
  function isObject$5(obj) {
    return _class$1(obj) === "[object Object]";
  }
  function isRegExp$2(obj) {
    return _class$1(obj) === "[object RegExp]";
  }
  function isFunction$4(obj) {
    return _class$1(obj) === "[object Function]";
  }
  function escapeRE(str2) {
    return str2.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
  }
  const defaultOptions$1 = {
    fuzzyLink: true,
    fuzzyEmail: true,
    fuzzyIP: false
  };
  function isOptionsObj(obj) {
    return Object.keys(obj || {}).reduce(function(acc, k2) {
      return acc || defaultOptions$1.hasOwnProperty(k2);
    }, false);
  }
  const defaultSchemas = {
    "http:": {
      validate: function(text2, pos, self2) {
        const tail = text2.slice(pos);
        if (!self2.re.http) {
          self2.re.http = new RegExp(
            "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
            "i"
          );
        }
        if (self2.re.http.test(tail)) {
          return tail.match(self2.re.http)[0].length;
        }
        return 0;
      }
    },
    "https:": "http:",
    "ftp:": "http:",
    "//": {
      validate: function(text2, pos, self2) {
        const tail = text2.slice(pos);
        if (!self2.re.no_http) {
          self2.re.no_http = new RegExp(
            "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
            // with code comments
            "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
            "i"
          );
        }
        if (self2.re.no_http.test(tail)) {
          if (pos >= 3 && text2[pos - 3] === ":") {
            return 0;
          }
          if (pos >= 3 && text2[pos - 3] === "/") {
            return 0;
          }
          return tail.match(self2.re.no_http)[0].length;
        }
        return 0;
      }
    },
    "mailto:": {
      validate: function(text2, pos, self2) {
        const tail = text2.slice(pos);
        if (!self2.re.mailto) {
          self2.re.mailto = new RegExp(
            "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
            "i"
          );
        }
        if (self2.re.mailto.test(tail)) {
          return tail.match(self2.re.mailto)[0].length;
        }
        return 0;
      }
    }
  };
  const tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
  const tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
  function resetScanCache(self2) {
    self2.__index__ = -1;
    self2.__text_cache__ = "";
  }
  function createValidator(re2) {
    return function(text2, pos) {
      const tail = text2.slice(pos);
      if (re2.test(tail)) {
        return tail.match(re2)[0].length;
      }
      return 0;
    };
  }
  function createNormalizer() {
    return function(match, self2) {
      self2.normalize(match);
    };
  }
  function compile(self2) {
    const re2 = self2.re = reFactory(self2.__opts__);
    const tlds = self2.__tlds__.slice();
    self2.onCompile();
    if (!self2.__tlds_replaced__) {
      tlds.push(tlds_2ch_src_re);
    }
    tlds.push(re2.src_xn);
    re2.src_tlds = tlds.join("|");
    function untpl(tpl) {
      return tpl.replace("%TLDS%", re2.src_tlds);
    }
    re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
    re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
    re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
    re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
    const aliases = [];
    self2.__compiled__ = {};
    function schemaError(name2, val) {
      throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
    }
    Object.keys(self2.__schemas__).forEach(function(name2) {
      const val = self2.__schemas__[name2];
      if (val === null) {
        return;
      }
      const compiled = { validate: null, link: null };
      self2.__compiled__[name2] = compiled;
      if (isObject$5(val)) {
        if (isRegExp$2(val.validate)) {
          compiled.validate = createValidator(val.validate);
        } else if (isFunction$4(val.validate)) {
          compiled.validate = val.validate;
        } else {
          schemaError(name2, val);
        }
        if (isFunction$4(val.normalize)) {
          compiled.normalize = val.normalize;
        } else if (!val.normalize) {
          compiled.normalize = createNormalizer();
        } else {
          schemaError(name2, val);
        }
        return;
      }
      if (isString$2(val)) {
        aliases.push(name2);
        return;
      }
      schemaError(name2, val);
    });
    aliases.forEach(function(alias) {
      if (!self2.__compiled__[self2.__schemas__[alias]]) {
        return;
      }
      self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
      self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
    });
    self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
    const slist = Object.keys(self2.__compiled__).filter(function(name2) {
      return name2.length > 0 && self2.__compiled__[name2];
    }).map(escapeRE).join("|");
    self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
    self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
    self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
    self2.re.pretest = RegExp(
      "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
      "i"
    );
    resetScanCache(self2);
  }
  function Match(self2, shift) {
    const start = self2.__index__;
    const end = self2.__last_index__;
    const text2 = self2.__text_cache__.slice(start, end);
    this.schema = self2.__schema__.toLowerCase();
    this.index = start + shift;
    this.lastIndex = end + shift;
    this.raw = text2;
    this.text = text2;
    this.url = text2;
  }
  function createMatch(self2, shift) {
    const match = new Match(self2, shift);
    self2.__compiled__[match.schema].normalize(match, self2);
    return match;
  }
  function LinkifyIt(schemas, options) {
    if (!(this instanceof LinkifyIt)) {
      return new LinkifyIt(schemas, options);
    }
    if (!options) {
      if (isOptionsObj(schemas)) {
        options = schemas;
        schemas = {};
      }
    }
    this.__opts__ = assign({}, defaultOptions$1, options);
    this.__index__ = -1;
    this.__last_index__ = -1;
    this.__schema__ = "";
    this.__text_cache__ = "";
    this.__schemas__ = assign({}, defaultSchemas, schemas);
    this.__compiled__ = {};
    this.__tlds__ = tlds_default;
    this.__tlds_replaced__ = false;
    this.re = {};
    compile(this);
  }
  LinkifyIt.prototype.add = function add(schema2, definition) {
    this.__schemas__[schema2] = definition;
    compile(this);
    return this;
  };
  LinkifyIt.prototype.set = function set2(options) {
    this.__opts__ = assign(this.__opts__, options);
    return this;
  };
  LinkifyIt.prototype.test = function test2(text2) {
    this.__text_cache__ = text2;
    this.__index__ = -1;
    if (!text2.length) {
      return false;
    }
    let m2, ml2, me2, len, shift, next, re2, tld_pos, at_pos;
    if (this.re.schema_test.test(text2)) {
      re2 = this.re.schema_search;
      re2.lastIndex = 0;
      while ((m2 = re2.exec(text2)) !== null) {
        len = this.testSchemaAt(text2, m2[2], re2.lastIndex);
        if (len) {
          this.__schema__ = m2[2];
          this.__index__ = m2.index + m2[1].length;
          this.__last_index__ = m2.index + m2[0].length + len;
          break;
        }
      }
    }
    if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
      tld_pos = text2.search(this.re.host_fuzzy_test);
      if (tld_pos >= 0) {
        if (this.__index__ < 0 || tld_pos < this.__index__) {
          if ((ml2 = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
            shift = ml2.index + ml2[1].length;
            if (this.__index__ < 0 || shift < this.__index__) {
              this.__schema__ = "";
              this.__index__ = shift;
              this.__last_index__ = ml2.index + ml2[0].length;
            }
          }
        }
      }
    }
    if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
      at_pos = text2.indexOf("@");
      if (at_pos >= 0) {
        if ((me2 = text2.match(this.re.email_fuzzy)) !== null) {
          shift = me2.index + me2[1].length;
          next = me2.index + me2[0].length;
          if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
            this.__schema__ = "mailto:";
            this.__index__ = shift;
            this.__last_index__ = next;
          }
        }
      }
    }
    return this.__index__ >= 0;
  };
  LinkifyIt.prototype.pretest = function pretest(text2) {
    return this.re.pretest.test(text2);
  };
  LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema2, pos) {
    if (!this.__compiled__[schema2.toLowerCase()]) {
      return 0;
    }
    return this.__compiled__[schema2.toLowerCase()].validate(text2, pos, this);
  };
  LinkifyIt.prototype.match = function match(text2) {
    const result = [];
    let shift = 0;
    if (this.__index__ >= 0 && this.__text_cache__ === text2) {
      result.push(createMatch(this, shift));
      shift = this.__last_index__;
    }
    let tail = shift ? text2.slice(shift) : text2;
    while (this.test(tail)) {
      result.push(createMatch(this, shift));
      tail = tail.slice(this.__last_index__);
      shift += this.__last_index__;
    }
    if (result.length) {
      return result;
    }
    return null;
  };
  LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
    this.__text_cache__ = text2;
    this.__index__ = -1;
    if (!text2.length)
      return null;
    const m2 = this.re.schema_at_start.exec(text2);
    if (!m2)
      return null;
    const len = this.testSchemaAt(text2, m2[2], m2[0].length);
    if (!len)
      return null;
    this.__schema__ = m2[2];
    this.__index__ = m2.index + m2[1].length;
    this.__last_index__ = m2.index + m2[0].length + len;
    return createMatch(this, 0);
  };
  LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
    list2 = Array.isArray(list2) ? list2 : [list2];
    if (!keepOld) {
      this.__tlds__ = list2.slice();
      this.__tlds_replaced__ = true;
      compile(this);
      return this;
    }
    this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el2, idx, arr) {
      return el2 !== arr[idx - 1];
    }).reverse();
    compile(this);
    return this;
  };
  LinkifyIt.prototype.normalize = function normalize2(match) {
    if (!match.schema) {
      match.url = "http://" + match.url;
    }
    if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
      match.url = "mailto:" + match.url;
    }
  };
  LinkifyIt.prototype.onCompile = function onCompile() {
  };
  const maxInt = 2147483647;
  const base = 36;
  const tMin = 1;
  const tMax = 26;
  const skew = 38;
  const damp = 700;
  const initialBias = 72;
  const initialN = 128;
  const delimiter = "-";
  const regexPunycode = /^xn--/;
  const regexNonASCII = /[^\0-\x7F]/;
  const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  const baseMinusTMin = base - tMin;
  const floor = Math.floor;
  const stringFromCharCode = String.fromCharCode;
  function error(type2) {
    throw new RangeError(errors[type2]);
  }
  function map$1(array, callback) {
    const result = [];
    let length2 = array.length;
    while (length2--) {
      result[length2] = callback(array[length2]);
    }
    return result;
  }
  function mapDomain(domain, callback) {
    const parts2 = domain.split("@");
    let result = "";
    if (parts2.length > 1) {
      result = parts2[0] + "@";
      domain = parts2[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map$1(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length2 = string.length;
    while (counter < length2) {
      const value2 = string.charCodeAt(counter++);
      if (value2 >= 55296 && value2 <= 56319 && counter < length2) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value2);
          counter--;
        }
      } else {
        output.push(value2);
      }
    }
    return output;
  }
  const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  const basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  const digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  const adapt = function(delta, numPoints, firstTime) {
    let k2 = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  const decode = function(input) {
    const output = [];
    const inputLength = input.length;
    let i2 = 0;
    let n2 = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j2 = 0; j2 < basic; ++j2) {
      if (input.charCodeAt(j2) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j2));
    }
    for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
      const oldi = i2;
      for (let w2 = 1, k2 = base; ; k2 += base) {
        if (index2 >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index2++));
        if (digit >= base) {
          error("invalid-input");
        }
        if (digit > floor((maxInt - i2) / w2)) {
          error("overflow");
        }
        i2 += digit * w2;
        const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
        if (digit < t2) {
          break;
        }
        const baseMinusT = base - t2;
        if (w2 > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w2 *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i2 - oldi, out, oldi == 0);
      if (floor(i2 / out) > maxInt - n2) {
        error("overflow");
      }
      n2 += floor(i2 / out);
      i2 %= out;
      output.splice(i2++, 0, n2);
    }
    return String.fromCodePoint(...output);
  };
  const encode$2 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n2 = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m2 = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n2 && currentValue < m2) {
          m2 = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m2 - n2) * handledCPCountPlusOne;
      n2 = m2;
      for (const currentValue of input) {
        if (currentValue < n2 && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n2) {
          let q2 = delta;
          for (let k2 = base; ; k2 += base) {
            const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
            if (q2 < t2) {
              break;
            }
            const qMinusT = q2 - t2;
            const baseMinusT = base - t2;
            output.push(
              stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
            );
            q2 = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q2, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n2;
    }
    return output.join("");
  };
  const toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  const toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode$2(string) : string;
    });
  };
  const punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    "version": "2.3.1",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    "ucs2": {
      "decode": ucs2decode,
      "encode": ucs2encode
    },
    "decode": decode,
    "encode": encode$2,
    "toASCII": toASCII,
    "toUnicode": toUnicode
  };
  const cfg_default = {
    options: {
      // Enable HTML tags in source
      html: false,
      // Use '/' to close single tags (<br />)
      xhtmlOut: false,
      // Convert '\n' in paragraphs into <br>
      breaks: false,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: false,
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "“”‘’",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 100
    },
    components: {
      core: {},
      block: {},
      inline: {}
    }
  };
  const cfg_zero = {
    options: {
      // Enable HTML tags in source
      html: false,
      // Use '/' to close single tags (<br />)
      xhtmlOut: false,
      // Convert '\n' in paragraphs into <br>
      breaks: false,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: false,
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "“”‘’",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 20
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline",
          "text_join"
        ]
      },
      block: {
        rules: [
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "text"
        ],
        rules2: [
          "balance_pairs",
          "fragments_join"
        ]
      }
    }
  };
  const cfg_commonmark = {
    options: {
      // Enable HTML tags in source
      html: true,
      // Use '/' to close single tags (<br />)
      xhtmlOut: true,
      // Convert '\n' in paragraphs into <br>
      breaks: false,
      // CSS language prefix for fenced blocks
      langPrefix: "language-",
      // autoconvert URL-like texts to links
      linkify: false,
      // Enable some language-neutral replacements + quotes beautification
      typographer: false,
      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: "“”‘’",
      /* “”‘’ */
      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,
      // Internal protection, recursion limit
      maxNesting: 20
    },
    components: {
      core: {
        rules: [
          "normalize",
          "block",
          "inline",
          "text_join"
        ]
      },
      block: {
        rules: [
          "blockquote",
          "code",
          "fence",
          "heading",
          "hr",
          "html_block",
          "lheading",
          "list",
          "reference",
          "paragraph"
        ]
      },
      inline: {
        rules: [
          "autolink",
          "backticks",
          "emphasis",
          "entity",
          "escape",
          "html_inline",
          "image",
          "link",
          "newline",
          "text"
        ],
        rules2: [
          "balance_pairs",
          "emphasis",
          "fragments_join"
        ]
      }
    }
  };
  const config$2 = {
    default: cfg_default,
    zero: cfg_zero,
    commonmark: cfg_commonmark
  };
  const BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
  const GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
  function validateLink(url2) {
    const str2 = url2.trim().toLowerCase();
    return BAD_PROTO_RE.test(str2) ? GOOD_DATA_RE.test(str2) : true;
  }
  const RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
  function normalizeLink(url2) {
    const parsed = urlParse(url2, true);
    if (parsed.hostname) {
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toASCII(parsed.hostname);
        } catch (er) {
        }
      }
    }
    return encode$3(format(parsed));
  }
  function normalizeLinkText(url2) {
    const parsed = urlParse(url2, true);
    if (parsed.hostname) {
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toUnicode(parsed.hostname);
        } catch (er) {
        }
      }
    }
    return decode$1(format(parsed), decode$1.defaultChars + "%");
  }
  function MarkdownIt(presetName, options) {
    if (!(this instanceof MarkdownIt)) {
      return new MarkdownIt(presetName, options);
    }
    if (!options) {
      if (!isString$3(presetName)) {
        options = presetName || {};
        presetName = "default";
      }
    }
    this.inline = new ParserInline();
    this.block = new ParserBlock();
    this.core = new Core();
    this.renderer = new Renderer();
    this.linkify = new LinkifyIt();
    this.validateLink = validateLink;
    this.normalizeLink = normalizeLink;
    this.normalizeLinkText = normalizeLinkText;
    this.utils = utils$2;
    this.helpers = assign$1({}, helpers);
    this.options = {};
    this.configure(presetName);
    if (options) {
      this.set(options);
    }
  }
  MarkdownIt.prototype.set = function(options) {
    assign$1(this.options, options);
    return this;
  };
  MarkdownIt.prototype.configure = function(presets) {
    const self2 = this;
    if (isString$3(presets)) {
      const presetName = presets;
      presets = config$2[presetName];
      if (!presets) {
        throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
      }
    }
    if (!presets) {
      throw new Error("Wrong `markdown-it` preset, can't be empty");
    }
    if (presets.options) {
      self2.set(presets.options);
    }
    if (presets.components) {
      Object.keys(presets.components).forEach(function(name2) {
        if (presets.components[name2].rules) {
          self2[name2].ruler.enableOnly(presets.components[name2].rules);
        }
        if (presets.components[name2].rules2) {
          self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
        }
      });
    }
    return this;
  };
  MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
    let result = [];
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    ["core", "block", "inline"].forEach(function(chain) {
      result = result.concat(this[chain].ruler.enable(list2, true));
    }, this);
    result = result.concat(this.inline.ruler2.enable(list2, true));
    const missed = list2.filter(function(name2) {
      return result.indexOf(name2) < 0;
    });
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
    }
    return this;
  };
  MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
    let result = [];
    if (!Array.isArray(list2)) {
      list2 = [list2];
    }
    ["core", "block", "inline"].forEach(function(chain) {
      result = result.concat(this[chain].ruler.disable(list2, true));
    }, this);
    result = result.concat(this.inline.ruler2.disable(list2, true));
    const missed = list2.filter(function(name2) {
      return result.indexOf(name2) < 0;
    });
    if (missed.length && !ignoreInvalid) {
      throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
    }
    return this;
  };
  MarkdownIt.prototype.use = function(plugin) {
    const args = [this].concat(Array.prototype.slice.call(arguments, 1));
    plugin.apply(plugin, args);
    return this;
  };
  MarkdownIt.prototype.parse = function(src, env) {
    if (typeof src !== "string") {
      throw new Error("Input data should be a String");
    }
    const state = new this.core.State(src, this, env);
    this.core.process(state);
    return state.tokens;
  };
  MarkdownIt.prototype.render = function(src, env) {
    env = env || {};
    return this.renderer.render(this.parse(src, env), this.options, env);
  };
  MarkdownIt.prototype.parseInline = function(src, env) {
    const state = new this.core.State(src, this, env);
    state.inlineMode = true;
    this.core.process(state);
    return state.tokens;
  };
  MarkdownIt.prototype.renderInline = function(src, env) {
    env = env || {};
    return this.renderer.render(this.parseInline(src, env), this.options, env);
  };
  var disableCheckboxes = true;
  var useLabelWrapper = false;
  var useLabelAfter = false;
  var markdownItTaskLists = function(md2, options) {
    if (options) {
      disableCheckboxes = !options.enabled;
      useLabelWrapper = !!options.label;
      useLabelAfter = !!options.labelAfter;
    }
    md2.core.ruler.after("inline", "github-task-lists", function(state) {
      var tokens = state.tokens;
      for (var i2 = 2; i2 < tokens.length; i2++) {
        if (isTodoItem(tokens, i2)) {
          todoify(tokens[i2], state.Token);
          attrSet(tokens[i2 - 2], "class", "task-list-item" + (!disableCheckboxes ? " enabled" : ""));
          attrSet(tokens[parentToken(tokens, i2 - 2)], "class", "contains-task-list");
        }
      }
    });
  };
  function attrSet(token, name2, value2) {
    var index2 = token.attrIndex(name2);
    var attr = [name2, value2];
    if (index2 < 0) {
      token.attrPush(attr);
    } else {
      token.attrs[index2] = attr;
    }
  }
  function parentToken(tokens, index2) {
    var targetLevel = tokens[index2].level - 1;
    for (var i2 = index2 - 1; i2 >= 0; i2--) {
      if (tokens[i2].level === targetLevel) {
        return i2;
      }
    }
    return -1;
  }
  function isTodoItem(tokens, index2) {
    return isInline(tokens[index2]) && isParagraph(tokens[index2 - 1]) && isListItem(tokens[index2 - 2]) && startsWithTodoMarkdown(tokens[index2]);
  }
  function todoify(token, TokenConstructor) {
    token.children.unshift(makeCheckbox(token, TokenConstructor));
    token.children[1].content = token.children[1].content.slice(3);
    token.content = token.content.slice(3);
    if (useLabelWrapper) {
      if (useLabelAfter) {
        token.children.pop();
        var id2 = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
        token.children[0].content = token.children[0].content.slice(0, -1) + ' id="' + id2 + '">';
        token.children.push(afterLabel(token.content, id2, TokenConstructor));
      } else {
        token.children.unshift(beginLabel(TokenConstructor));
        token.children.push(endLabel(TokenConstructor));
      }
    }
  }
  function makeCheckbox(token, TokenConstructor) {
    var checkbox = new TokenConstructor("html_inline", "", 0);
    var disabledAttr = disableCheckboxes ? ' disabled="" ' : "";
    if (token.content.indexOf("[ ] ") === 0) {
      checkbox.content = '<input class="task-list-item-checkbox"' + disabledAttr + 'type="checkbox">';
    } else if (token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0) {
      checkbox.content = '<input class="task-list-item-checkbox" checked=""' + disabledAttr + 'type="checkbox">';
    }
    return checkbox;
  }
  function beginLabel(TokenConstructor) {
    var token = new TokenConstructor("html_inline", "", 0);
    token.content = "<label>";
    return token;
  }
  function endLabel(TokenConstructor) {
    var token = new TokenConstructor("html_inline", "", 0);
    token.content = "</label>";
    return token;
  }
  function afterLabel(content, id2, TokenConstructor) {
    var token = new TokenConstructor("html_inline", "", 0);
    token.content = '<label class="task-list-item-label" for="' + id2 + '">' + content + "</label>";
    token.attrs = [{ for: id2 }];
    return token;
  }
  function isInline(token) {
    return token.type === "inline";
  }
  function isParagraph(token) {
    return token.type === "paragraph_open";
  }
  function isListItem(token) {
    return token.type === "list_item_open";
  }
  function startsWithTodoMarkdown(token) {
    return token.content.indexOf("[ ] ") === 0 || token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0;
  }
  const TaskLists = /* @__PURE__ */ getDefaultExportFromCjs(markdownItTaskLists);
  const DEV_MODE = false;
  function getParams(opts) {
    if (!Array.isArray(opts))
      opts = [opts];
    const urlParams = new URLSearchParams(window.location.search);
    let obj = {};
    opts.forEach((name2) => obj[name2] = urlParams.get(name2));
    const result = opts.length == 1 ? obj[opts[0]] : obj;
    return result;
  }
  const fullURL = location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "");
  const getHost = function() {
    let preConfig = getParams("config");
    if (preConfig && preConfig !== "")
      preConfig = JSON.parse(atob(preConfig));
    let HOST2 = preConfig ? `${preConfig.address}:${preConfig.port}` : getParams("host") || fullURL;
    return HOST2;
  };
  let ENVIRONMENT = "localhost";
  const getEnvironment = async () => {
    const host = getHost();
    try {
      const response = await fetch(`${host}/config`);
      if (response.ok) {
        ENVIRONMENT = "localhost";
        const myEvent = new CustomEvent("environment-change", {
          detail: { environment: "localhost" }
        });
        document.dispatchEvent(myEvent);
        return "localhost";
      } else
        throw Error("The response was unsuccesfull");
    } catch (e2) {
      ENVIRONMENT = "localStorage";
      const myEvent = new CustomEvent("environment-change", {
        detail: { environment: "localStorage" }
      });
      document.dispatchEvent(myEvent);
      return "localStorage";
    }
  };
  getEnvironment();
  const RIGOBOT_HOST = "https://rigobot.herokuapp.com";
  const convertMarkdownToHTML = (markdown, allowHTML = true) => {
    const md2 = new MarkdownIt({
      html: allowHTML,
      linkify: true,
      typographer: true
      // highlight: true,
    }).use(TaskLists, { enabled: true });
    let html = md2.render(markdown);
    html = replaceSrc(html);
    return html;
  };
  const changeSidebarVisibility = () => {
    const sidebar = document.querySelector(".sidebar-component");
    if (sidebar) {
      const style = window.getComputedStyle(sidebar);
      if (style.left === "0px") {
        sidebar.classList.remove("sidebar-appear");
        sidebar.classList.add("sidebar-disappear");
      } else {
        sidebar == null ? void 0 : sidebar.classList.remove("sidebar-disappear");
        sidebar == null ? void 0 : sidebar.classList.add("sidebar-appear");
      }
      void (sidebar == null ? void 0 : sidebar.offsetWidth);
    }
  };
  function replaceSrc(rawText) {
    const regex2 = /src="\.\.\/\.\./g;
    let host = getHost();
    if (ENVIRONMENT === "localStorage") {
      host = "";
    }
    const modifiedText = rawText.replace(regex2, `src="${host}`);
    return modifiedText;
  }
  const getExercise = async (slug) => {
    return await fetch(`${getHost()}/exercise/${slug}`);
  };
  const startChat = async (purpose_id, token) => {
    const conversationUrl = RIGOBOT_HOST + "/v1/conversation/?purpose=" + purpose_id;
    const config2 = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Token " + token
      }
    };
    const resp = await fetch(conversationUrl, config2);
    const data = await resp.json();
    return data;
  };
  const disconnected = () => {
  };
  const onConnectCli = () => {
    const modal = document.querySelector(
      "#socket-disconnected"
    );
    if (modal) {
      modal.style.display = "none";
    }
  };
  function fixParams(str2) {
    return str2.replace(/\?/g, "&");
  }
  const getParamsObject = () => {
    let params = window.location.hash.substring(1);
    params = fixParams(params);
    if (!params) {
      const url2 = window.location.href;
      const urlObj = new URL(url2);
      params = urlObj.search;
      params = fixParams(params);
    }
    params = fixParams(params);
    const paramsUrlSearch = new URLSearchParams(params);
    let paramsObject = {};
    for (const [key, value2] of paramsUrlSearch.entries()) {
      paramsObject[key] = value2;
    }
    return paramsObject;
  };
  const debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  };
  const removeSpecialCharacters = (inputString) => {
    return inputString.replace(/\x1B[@-_][0-?]*[ -/]*[@-~]/g, "");
  };
  const replaceSlot = (string, slot, value2) => {
    const slotRegex = new RegExp(slot, "g");
    return string.replace(slotRegex, value2);
  };
  const setWindowHash = (params) => {
    const hashString = Object.entries(params).map(
      ([key, value2]) => `${encodeURIComponent(key)}=${encodeURIComponent(value2)}`
    ).join("&");
    const url2 = window.location.origin + window.location.pathname;
    history.replaceState(null, "", url2);
    window.location.hash = hashString;
  };
  function randomInRange(min, max) {
    return Math.random() * (max - min) + min;
  }
  let e = { data: "" }, t = (t2) => "object" == typeof window ? ((t2 ? t2.querySelector("#_goober") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t2 || e, l$1 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a = /\/\*[^]*?\*\/|  +/g, n$1 = /\n+/g, o = (e2, t2) => {
    let r2 = "", l2 = "", a2 = "";
    for (let n2 in e2) {
      let c2 = e2[n2];
      "@" == n2[0] ? "i" == n2[1] ? r2 = n2 + " " + c2 + ";" : l2 += "f" == n2[1] ? o(c2, n2) : n2 + "{" + o(c2, "k" == n2[1] ? "" : t2) + "}" : "object" == typeof c2 ? l2 += o(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/(^:.*)|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + " " + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, "-$&").toLowerCase(), a2 += o.p ? o.p(n2, c2) : n2 + ":" + c2 + ";");
    }
    return r2 + (t2 && a2 ? t2 + "{" + a2 + "}" : a2) + l2;
  }, c = {}, s = (e2) => {
    if ("object" == typeof e2) {
      let t2 = "";
      for (let r2 in e2)
        t2 += r2 + s(e2[r2]);
      return t2;
    }
    return e2;
  }, i$2 = (e2, t2, r2, i2, p2) => {
    let u2 = s(e2), d2 = c[u2] || (c[u2] = ((e3) => {
      let t3 = 0, r3 = 11;
      for (; t3 < e3.length; )
        r3 = 101 * r3 + e3.charCodeAt(t3++) >>> 0;
      return "go" + r3;
    })(u2));
    if (!c[d2]) {
      let t3 = u2 !== e2 ? e2 : ((e3) => {
        let t4, r3, o2 = [{}];
        for (; t4 = l$1.exec(e3.replace(a, "")); )
          t4[4] ? o2.shift() : t4[3] ? (r3 = t4[3].replace(n$1, " ").trim(), o2.unshift(o2[0][r3] = o2[0][r3] || {})) : o2[0][t4[1]] = t4[2].replace(n$1, " ").trim();
        return o2[0];
      })(e2);
      c[d2] = o(p2 ? { ["@keyframes " + d2]: t3 } : t3, r2 ? "" : "." + d2);
    }
    let f2 = r2 && c.g ? c.g : null;
    return r2 && (c.g = c[d2]), ((e3, t3, r3, l2) => {
      l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r3 ? e3 + t3.data : t3.data + e3);
    })(c[d2], t2, i2, f2), d2;
  }, p = (e2, t2, r2) => e2.reduce((e3, l2, a2) => {
    let n2 = t2[a2];
    if (n2 && n2.call) {
      let e4 = n2(r2), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;
      n2 = t3 ? "." + t3 : e4 && "object" == typeof e4 ? e4.props ? "" : o(e4, "") : false === e4 ? "" : e4;
    }
    return e3 + l2 + (null == n2 ? "" : n2);
  }, "");
  function u$1(e2) {
    let r2 = this || {}, l2 = e2.call ? e2(r2.p) : e2;
    return i$2(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r2.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r2.p) : t2), {}) : l2, t(r2.target), r2.g, r2.o, r2.k);
  }
  let d, f, g;
  u$1.bind({ g: 1 });
  let h$2 = u$1.bind({ k: 1 });
  function m(e2, t2, r2, l2) {
    o.p = t2, d = e2, f = r2, g = l2;
  }
  function j(e2, t2) {
    let r2 = this || {};
    return function() {
      let l2 = arguments;
      function a2(n2, o2) {
        let c2 = Object.assign({}, n2), s2 = c2.className || a2.className;
        r2.p = Object.assign({ theme: f && f() }, c2), r2.o = / *go\d+/.test(s2), c2.className = u$1.apply(r2, l2) + (s2 ? " " + s2 : ""), t2 && (c2.ref = o2);
        let i2 = e2;
        return e2[0] && (i2 = c2.as || e2, delete c2.as), g && i2[0] && g(c2), d(i2, c2);
      }
      return t2 ? t2(a2) : a2;
    };
  }
  var W = (e2) => typeof e2 == "function", T = (e2, t2) => W(e2) ? e2(t2) : e2;
  var U = (() => {
    let e2 = 0;
    return () => (++e2).toString();
  })(), b = (() => {
    let e2;
    return () => {
      if (e2 === void 0 && typeof window < "u") {
        let t2 = matchMedia("(prefers-reduced-motion: reduce)");
        e2 = !t2 || t2.matches;
      }
      return e2;
    };
  })();
  var Q = 20;
  var S = /* @__PURE__ */ new Map(), X = 1e3, $$1 = (e2) => {
    if (S.has(e2))
      return;
    let t2 = setTimeout(() => {
      S.delete(e2), u({ type: 4, toastId: e2 });
    }, X);
    S.set(e2, t2);
  }, J = (e2) => {
    let t2 = S.get(e2);
    t2 && clearTimeout(t2);
  }, v$1 = (e2, t2) => {
    switch (t2.type) {
      case 0:
        return { ...e2, toasts: [t2.toast, ...e2.toasts].slice(0, Q) };
      case 1:
        return t2.toast.id && J(t2.toast.id), { ...e2, toasts: e2.toasts.map((r2) => r2.id === t2.toast.id ? { ...r2, ...t2.toast } : r2) };
      case 2:
        let { toast: o2 } = t2;
        return e2.toasts.find((r2) => r2.id === o2.id) ? v$1(e2, { type: 1, toast: o2 }) : v$1(e2, { type: 0, toast: o2 });
      case 3:
        let { toastId: s2 } = t2;
        return s2 ? $$1(s2) : e2.toasts.forEach((r2) => {
          $$1(r2.id);
        }), { ...e2, toasts: e2.toasts.map((r2) => r2.id === s2 || s2 === void 0 ? { ...r2, visible: false } : r2) };
      case 4:
        return t2.toastId === void 0 ? { ...e2, toasts: [] } : { ...e2, toasts: e2.toasts.filter((r2) => r2.id !== t2.toastId) };
      case 5:
        return { ...e2, pausedAt: t2.time };
      case 6:
        let a2 = t2.time - (e2.pausedAt || 0);
        return { ...e2, pausedAt: void 0, toasts: e2.toasts.map((r2) => ({ ...r2, pauseDuration: r2.pauseDuration + a2 })) };
    }
  }, A = [], P = { toasts: [], pausedAt: void 0 }, u = (e2) => {
    P = v$1(P, e2), A.forEach((t2) => {
      t2(P);
    });
  }, Y$1 = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, I = (e2 = {}) => {
    let [t2, o2] = reactExports.useState(P);
    reactExports.useEffect(() => (A.push(o2), () => {
      let a2 = A.indexOf(o2);
      a2 > -1 && A.splice(a2, 1);
    }), [t2]);
    let s2 = t2.toasts.map((a2) => {
      var r2, c2;
      return { ...e2, ...e2[a2.type], ...a2, duration: a2.duration || ((r2 = e2[a2.type]) == null ? void 0 : r2.duration) || (e2 == null ? void 0 : e2.duration) || Y$1[a2.type], style: { ...e2.style, ...(c2 = e2[a2.type]) == null ? void 0 : c2.style, ...a2.style } };
    });
    return { ...t2, toasts: s2 };
  };
  var G = (e2, t2 = "blank", o2) => ({ createdAt: Date.now(), visible: true, type: t2, ariaProps: { role: "status", "aria-live": "polite" }, message: e2, pauseDuration: 0, ...o2, id: (o2 == null ? void 0 : o2.id) || U() }), h$1 = (e2) => (t2, o2) => {
    let s2 = G(t2, e2, o2);
    return u({ type: 2, toast: s2 }), s2.id;
  }, n = (e2, t2) => h$1("blank")(e2, t2);
  n.error = h$1("error");
  n.success = h$1("success");
  n.loading = h$1("loading");
  n.custom = h$1("custom");
  n.dismiss = (e2) => {
    u({ type: 3, toastId: e2 });
  };
  n.remove = (e2) => u({ type: 4, toastId: e2 });
  n.promise = (e2, t2, o2) => {
    let s2 = n.loading(t2.loading, { ...o2, ...o2 == null ? void 0 : o2.loading });
    return e2.then((a2) => (n.success(T(t2.success, a2), { id: s2, ...o2, ...o2 == null ? void 0 : o2.success }), a2)).catch((a2) => {
      n.error(T(t2.error, a2), { id: s2, ...o2, ...o2 == null ? void 0 : o2.error });
    }), e2;
  };
  var Z$1 = (e2, t2) => {
    u({ type: 1, toast: { id: e2, height: t2 } });
  }, ee$1 = () => {
    u({ type: 5, time: Date.now() });
  }, D$1 = (e2) => {
    let { toasts: t2, pausedAt: o2 } = I(e2);
    reactExports.useEffect(() => {
      if (o2)
        return;
      let r2 = Date.now(), c2 = t2.map((i2) => {
        if (i2.duration === 1 / 0)
          return;
        let d2 = (i2.duration || 0) + i2.pauseDuration - (r2 - i2.createdAt);
        if (d2 < 0) {
          i2.visible && n.dismiss(i2.id);
          return;
        }
        return setTimeout(() => n.dismiss(i2.id), d2);
      });
      return () => {
        c2.forEach((i2) => i2 && clearTimeout(i2));
      };
    }, [t2, o2]);
    let s2 = reactExports.useCallback(() => {
      o2 && u({ type: 6, time: Date.now() });
    }, [o2]), a2 = reactExports.useCallback((r2, c2) => {
      let { reverseOrder: i2 = false, gutter: d2 = 8, defaultPosition: p2 } = c2 || {}, g2 = t2.filter((m2) => (m2.position || p2) === (r2.position || p2) && m2.height), E2 = g2.findIndex((m2) => m2.id === r2.id), x2 = g2.filter((m2, R2) => R2 < E2 && m2.visible).length;
      return g2.filter((m2) => m2.visible).slice(...i2 ? [x2 + 1] : [0, x2]).reduce((m2, R2) => m2 + (R2.height || 0) + d2, 0);
    }, [t2]);
    return { toasts: t2, handlers: { updateHeight: Z$1, startPause: ee$1, endPause: s2, calculateOffset: a2 } };
  };
  var oe = h$2`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, re = h$2`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, se$1 = h$2`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, _$2 = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e2) => e2.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se$1} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`;
  var ne = h$2`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, V = j("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e2) => e2.secondary || "#e0e0e0"};
  border-right-color: ${(e2) => e2.primary || "#616161"};
  animation: ${ne} 1s linear infinite;
`;
  var pe = h$2`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, de$1 = h$2`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, w = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de$1} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e2) => e2.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`;
  var ue = j("div")`
  position: absolute;
`, le$1 = j("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Te = h$2`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fe$1 = j("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Te} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, M = ({ toast: e2 }) => {
    let { icon: t2, type: o2, iconTheme: s2 } = e2;
    return t2 !== void 0 ? typeof t2 == "string" ? reactExports.createElement(fe$1, null, t2) : t2 : o2 === "blank" ? null : reactExports.createElement(le$1, null, reactExports.createElement(V, { ...s2 }), o2 !== "loading" && reactExports.createElement(ue, null, o2 === "error" ? reactExports.createElement(_$2, { ...s2 }) : reactExports.createElement(w, { ...s2 })));
  };
  var ye = (e2) => `
0% {transform: translate3d(0,${e2 * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ge = (e2) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e2 * -150}%,-1px) scale(.6); opacity:0;}
`, he$1 = "0%{opacity:0;} 100%{opacity:1;}", xe = "0%{opacity:1;} 100%{opacity:0;}", be$1 = j("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Se = j("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ae = (e2, t2) => {
    let s2 = e2.includes("top") ? 1 : -1, [a2, r2] = b() ? [he$1, xe] : [ye(s2), ge(s2)];
    return { animation: t2 ? `${h$2(a2)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${h$2(r2)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
  }, F = reactExports.memo(({ toast: e2, position: t2, style: o2, children: s2 }) => {
    let a2 = e2.height ? Ae(e2.position || t2 || "top-center", e2.visible) : { opacity: 0 }, r2 = reactExports.createElement(M, { toast: e2 }), c2 = reactExports.createElement(Se, { ...e2.ariaProps }, T(e2.message, e2));
    return reactExports.createElement(be$1, { className: e2.className, style: { ...a2, ...o2, ...e2.style } }, typeof s2 == "function" ? s2({ icon: r2, message: c2 }) : reactExports.createElement(reactExports.Fragment, null, r2, c2));
  });
  m(reactExports.createElement);
  var Ee$1 = ({ id: e2, className: t2, style: o2, onHeightUpdate: s2, children: a2 }) => {
    let r2 = reactExports.useCallback((c2) => {
      if (c2) {
        let i2 = () => {
          let d2 = c2.getBoundingClientRect().height;
          s2(e2, d2);
        };
        i2(), new MutationObserver(i2).observe(c2, { subtree: true, childList: true, characterData: true });
      }
    }, [e2, s2]);
    return reactExports.createElement("div", { ref: r2, className: t2, style: o2 }, a2);
  }, Re = (e2, t2) => {
    let o2 = e2.includes("top"), s2 = o2 ? { top: 0 } : { bottom: 0 }, a2 = e2.includes("center") ? { justifyContent: "center" } : e2.includes("right") ? { justifyContent: "flex-end" } : {};
    return { left: 0, right: 0, display: "flex", position: "absolute", transition: b() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t2 * (o2 ? 1 : -1)}px)`, ...s2, ...a2 };
  }, ve = u$1`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, O = 16, Ie = ({ reverseOrder: e2, position: t2 = "top-center", toastOptions: o2, gutter: s2, children: a2, containerStyle: r2, containerClassName: c2 }) => {
    let { toasts: i2, handlers: d2 } = D$1(o2);
    return reactExports.createElement("div", { style: { position: "fixed", zIndex: 9999, top: O, left: O, right: O, bottom: O, pointerEvents: "none", ...r2 }, className: c2, onMouseEnter: d2.startPause, onMouseLeave: d2.endPause }, i2.map((p2) => {
      let g2 = p2.position || t2, E2 = d2.calculateOffset(p2, { reverseOrder: e2, gutter: s2, defaultPosition: t2 }), x2 = Re(g2, E2);
      return reactExports.createElement(Ee$1, { id: p2.id, key: p2.id, onHeightUpdate: d2.updateHeight, className: p2.visible ? ve : "", style: x2 }, p2.type === "custom" ? T(p2.message, p2) : a2 ? a2(p2) : reactExports.createElement(F, { toast: p2, position: g2 }));
    }));
  };
  var _t = n;
  const messages = {
    us: {
      testing: "Testing your code...",
      initializing: "Setting up the coding environment",
      compiling: "Building your code...",
      pending: "Working...",
      connecting: "Connecting...",
      saving: "Saving Files...",
      ready: "Ready...",
      compilerError: "Compiler error.",
      compilerWarning: "Compiled with warnings",
      compilerSuccess: "Compiled successfully!",
      testingError: "Check the terminal for more detailed info.",
      testingSuccess: "Everything as expected.",
      internalError: "Woops! There has been an internal error",
      prettifying: "Making code prettier",
      prettifySuccess: "Look how beautiful your code is now",
      completed: "Excellent!",
      prettifyError: "Warning! Unable to prettify and save",
      openWindow: "Opening window...",
      dialog: "Dialog Received",
      goodMessages: [
        "Yeah!",
        "Wuju!",
        "OMG!",
        "YUUUUPPPIII!",
        "Congrats!",
        "Way to go!",
        "I'm soooo happy!",
        "Nice!",
        "I'm sooo happy for you",
        "For now...",
        "Maybe you are smart?",
        "Coding is your thing",
        "You are good at this"
      ],
      badMessages: [
        "Not as expected, don't panic!",
        "Not as expected, keep trying!",
        "You'll get it the next time!",
        "Never give up!",
        "No pain no gain.",
        "Not correct my friend.",
        "Focus on the force inside you."
      ]
    },
    es: {
      testing: "Testeando tu código...",
      initializing: "Configurando el entorno de codificación",
      compiling: "Construyendo tu código...",
      pending: "Trabajando...",
      connecting: "Conectando...",
      saving: "Guardando archivos...",
      ready: "Listo...",
      compilerError: "Error de compilación.",
      compilerWarning: "Compilado con advertencias",
      compilerSuccess: "¡Compilado con éxito!",
      testingError: "Consulta la terminal para más información detallada.",
      testingSuccess: "Todo como se esperaba.",
      internalError: "¡Ups! Ha habido un error interno",
      prettifying: "Haciendo el código más bonito",
      prettifySuccess: "Mira qué bonito está tu código ahora",
      completed: "¡Excelente!",
      prettifyError: "¡Advertencia! No se pudo embellecer y guardar",
      openWindow: "Abriendo ventana...",
      dialog: "Diálogo recibido",
      goodMessages: [
        "¡Sí!",
        "¡Wuju!",
        "¡OMG!",
        "¡YUUUUPPPIII!",
        "¡Felicidades!",
        "¡Bien hecho!",
        "¡Estoy tan feliz!",
        "¡Genial!",
        "¡Estoy tan feliz por ti",
        "Por ahora...",
        "¿Tal vez eres inteligente?",
        "Codificar es lo tuyo",
        "Eres bueno en esto"
      ],
      badMessages: [
        "No como se esperaba, ¡no entres en pánico!",
        "No como se esperaba, ¡sigue intentando!",
        "¡Lo conseguirás la próxima vez!",
        "¡Nunca te rindas!",
        "Sin dolor no hay ganancia.",
        "No es correcto, amigo.",
        "Concéntrate en la fuerza dentro de ti."
      ]
    }
  };
  const getStatus = function(status = "initializing", language = "us") {
    const goodIcons = ["🤩", "🙂", "😃", "😎", "🤓", "😍", "🤗", "👌🏽", "✅"];
    const badIcons = [
      "🤮",
      "🤢",
      "🤐",
      "🤬",
      "😡",
      "😵",
      "🤷🏽‍♂️",
      "🤷🏻‍♀️",
      "😬",
      "😭",
      "😤",
      "🤭",
      "🤒",
      "💩",
      "🧟‍♂️"
    ];
    const getGoodIcon = () => goodIcons[Math.floor(Math.random() * goodIcons.length)];
    const getBadIcon = () => badIcons[Math.floor(Math.random() * badIcons.length)];
    const good = (lang = "us") => {
      const goodMessages = messages[lang].goodMessages;
      return `${getGoodIcon()} ${goodMessages[Math.floor(Math.random() * goodMessages.length)]}`;
    };
    const bad = (lang = "us") => {
      const badMessage = messages[lang].badMessages;
      return `${badMessage[Math.floor(Math.random() * badMessage.length)]}`;
    };
    switch (status) {
      case "initializing":
        return ["🚀", messages[language].initializing];
      case "compiling":
        return ["💼", messages[language].compiling];
      case "testing":
        return ["👀", messages[language].testing];
      case "pending":
        return ["👩‍💻", messages[language].pending];
      case "connecting":
        return ["📳", messages[language].connecting];
      case "saving":
        return ["💾", messages[language].saving];
      case "ready":
        return ["🐶", messages[language].ready];
      case "compiler-error":
        return [getBadIcon(), messages[language].compilerError];
      case "compiler-warning":
        return ["⚠️", messages[language].compilerWarning];
      case "compiler-success":
        return [getGoodIcon(), messages[language].compilerSuccess];
      case "testing-error":
        return [
          getBadIcon(),
          `${bad(language)} ${messages[language].testingError}`
        ];
      case "quiz-success":
        return [getGoodIcon(), good(language)];
      case "quiz-error":
        return [getBadIcon(), bad(language)];
      case "testing-success":
        return [getGoodIcon(), messages[language].testingSuccess];
      case "internal-error":
        return ["🔥💻", messages[language].internalError];
      case "prettifying":
        return ["✨", messages[language].prettifying];
      case "prettify-success":
        return ["🌟", messages[language].prettifySuccess];
      case "completed":
        return ["🎉", messages[language].completed];
      case "prettify-error":
        return ["⚠️", messages[language].prettifyError];
      case "open_window":
        return ["👀", messages[language].openWindow];
      case "dialog":
        return ["💬", messages[language].dialog];
      default:
        throw new Error("Invalid status: " + status);
    }
  };
  const actions = [
    "build",
    "prettify",
    "test",
    "run",
    "input",
    "open",
    "preview",
    "reset",
    "reload",
    "open_window",
    "generate",
    "ai_interaction",
    "open_terminal"
  ];
  const scopes = {};
  const Socket = {
    socket: null,
    start: function(host, onDisconnect = null, onConnect = null) {
      this.socket = lookup.connect(host, {
        reconnectionAttempts: 5
      });
      if (this.socket) {
        this.socket.on("connect", () => onConnect && onConnect());
        console.log("Connected to host " + host);
        this.socket.on("disconnect", () => onDisconnect && onDisconnect());
      } else {
        console.error(`Failed to connect to host: ${host}`);
      }
    },
    createScope: function(scopeName) {
      if (scopes[scopeName]) {
        return scopes[scopeName];
      }
      const scope = {
        socket: this.socket,
        name: scopeName,
        previewWindow: null,
        actionCallBacks: {
          clean: function(data, s2) {
            s2.logs = [];
          }
        },
        statusCallBacks: {},
        updatedCallback: null,
        status: {
          code: "connecting",
          message: getStatus("connecting")
        },
        logs: [],
        on: function(action, callBack) {
          this.actionCallBacks[action] = callBack;
        },
        onStatus: function(status, callBack) {
          this.statusCallBacks[status] = callBack;
        },
        openWindow: function(data) {
          this.emit("open_window", data);
        },
        emit: function(action, data) {
          if (actions.indexOf(action) < 0)
            throw new Error(
              'Invalid action "' + action + '" for socket connection'
            );
          else
            this.socket.emit(this.name, { action, data });
        },
        whenUpdated: function(callBack) {
          this.updatedCallback = callBack;
        }
      };
      this.socket.on(scopeName, (data) => {
        if (data.logs) {
          scope.logs = scope.logs.concat(data.logs);
        }
        if (data.status) {
          scope.status = {
            code: data.status,
            message: data.data ? data.data.message || getStatus(data.status) : getStatus(data.status),
            gif: data.data ? data.data.gif : null,
            video: data.data ? data.data.video : null
          };
        }
        if (typeof scope.actionCallBacks[data.action] === "function") {
          scope.actionCallBacks[data.action](data, scope);
        }
        if (typeof scope.statusCallBacks[data.status] === "function")
          scope.statusCallBacks[data.status](data, scope);
        if (scope.updatedCallback)
          scope.updatedCallback(scope, data);
      });
      scopes[scopeName] = scope;
      return scope;
    }
  };
  const compileHTML = (tabs) => {
    let jsCode = "";
    let cssCode = "";
    let htmlCode = "";
    tabs.forEach((tab) => {
      if (tab.name.endsWith(".js")) {
        jsCode += `<script>${tab.content}<\/script>`;
      }
      if (tab.name.endsWith(".css")) {
        cssCode += `<style>${tab.content}</style>`;
      }
      if (tab.name.endsWith(".html")) {
        htmlCode += tab.content;
      }
    });
    const finalHTML = htmlCode + jsCode + cssCode;
    return finalHTML;
  };
  const compileReactHTML = (tabs) => {
    let jsCode = "";
    let htmlCode = `
    <div id="myDiv"></div>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin><\/script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin><\/script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"><\/script>
  `;
    tabs.forEach((tab) => {
      if (tab.name.endsWith(".js") || tab.name.endsWith(".jsx")) {
        const filteredContent = tab.content.split("\n").filter((line) => !line.trim().startsWith("import")).join("\n");
        jsCode += `<script type="text/babel">${filteredContent}<\/script>`;
      }
      if (tab.name.endsWith(".html")) {
        htmlCode += tab.content;
      }
    });
    const finalHTML = htmlCode + jsCode;
    return finalHTML;
  };
  var frontMatter$1 = { exports: {} };
  var jsYaml$1 = {};
  var loader$2 = {};
  var common$6 = {};
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject$4(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray$1(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend$1(target, source) {
    var index2, length2, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index2 = 0, length2 = sourceKeys.length; index2 < length2; index2 += 1) {
        key = sourceKeys[index2];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  common$6.isNothing = isNothing;
  common$6.isObject = isObject$4;
  common$6.toArray = toArray$1;
  common$6.repeat = repeat;
  common$6.isNegativeZero = isNegativeZero;
  common$6.extend = extend$1;
  function YAMLException$4(reason, mark2) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark2;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException$4.prototype = Object.create(Error.prototype);
  YAMLException$4.prototype.constructor = YAMLException$4;
  YAMLException$4.prototype.toString = function toString2(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) {
      result += " " + this.mark.toString();
    }
    return result;
  };
  var exception = YAMLException$4;
  var common$5 = common$6;
  function Mark$1(name2, buffer, position, line, column) {
    this.name = name2;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }
  Mark$1.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer)
      return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while (start > 0 && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > maxLength / 2 - 1) {
        head = " ... ";
        start += 5;
        break;
      }
    }
    tail = "";
    end = this.position;
    while (end < this.buffer.length && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > maxLength / 2 - 1) {
        tail = " ... ";
        end -= 5;
        break;
      }
    }
    snippet = this.buffer.slice(start, end);
    return common$5.repeat(" ", indent) + head + snippet + tail + "\n" + common$5.repeat(" ", indent + this.position - start + head.length) + "^";
  };
  Mark$1.prototype.toString = function toString2(compact) {
    var snippet, where = "";
    if (this.name) {
      where += 'in "' + this.name + '" ';
    }
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
      snippet = this.getSnippet();
      if (snippet) {
        where += ":\n" + snippet;
      }
    }
    return where;
  };
  var mark = Mark$1;
  var YAMLException$3 = exception;
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    if (map2 !== null) {
      Object.keys(map2).forEach(function(style) {
        map2[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type$h(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name2) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
        throw new YAMLException$3('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  var type = Type$h;
  var common$4 = common$6;
  var YAMLException$2 = exception;
  var Type$g = type;
  function compileList(schema2, name2, result) {
    var exclude = [];
    schema2.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name2, result);
    });
    schema2[name2].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });
      result.push(currentType);
    });
    return result.filter(function(type2, index2) {
      return exclude.indexOf(index2) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index2, length2;
    function collectType(type2) {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
    for (index2 = 0, length2 = arguments.length; index2 < length2; index2 += 1) {
      arguments[index2].forEach(collectType);
    }
    return result;
  }
  function Schema$5(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type2) {
      if (type2.loadKind && type2.loadKind !== "scalar") {
        throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
    });
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  Schema$5.DEFAULT = null;
  Schema$5.create = function createSchema() {
    var schemas, types;
    switch (arguments.length) {
      case 1:
        schemas = Schema$5.DEFAULT;
        types = arguments[0];
        break;
      case 2:
        schemas = arguments[0];
        types = arguments[1];
        break;
      default:
        throw new YAMLException$2("Wrong number of arguments for Schema.create function");
    }
    schemas = common$4.toArray(schemas);
    types = common$4.toArray(types);
    if (!schemas.every(function(schema2) {
      return schema2 instanceof Schema$5;
    })) {
      throw new YAMLException$2("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    }
    if (!types.every(function(type2) {
      return type2 instanceof Type$g;
    })) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    return new Schema$5({
      include: schemas,
      explicit: types
    });
  };
  var schema = Schema$5;
  var Type$f = type;
  var str = new Type$f("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
  var Type$e = type;
  var seq = new Type$e("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
  var Type$d = type;
  var map = new Type$d("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
  var Schema$4 = schema;
  var failsafe = new Schema$4({
    explicit: [
      str,
      seq,
      map
    ]
  });
  var Type$c = type;
  function resolveYamlNull(data) {
    if (data === null)
      return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  var _null = new Type$c("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  });
  var Type$b = type;
  function resolveYamlBoolean(data) {
    if (data === null)
      return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean$1(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  var bool = new Type$b("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean$1,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  var common$3 = common$6;
  var Type$a = type;
  function isHexCode(c2) {
    return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
  }
  function isOctCode(c2) {
    return 48 <= c2 && c2 <= 55;
  }
  function isDecCode(c2) {
    return 48 <= c2 && c2 <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null)
      return false;
    var max = data.length, index2 = 0, hasDigits = false, ch2;
    if (!max)
      return false;
    ch2 = data[index2];
    if (ch2 === "-" || ch2 === "+") {
      ch2 = data[++index2];
    }
    if (ch2 === "0") {
      if (index2 + 1 === max)
        return true;
      ch2 = data[++index2];
      if (ch2 === "b") {
        index2++;
        for (; index2 < max; index2++) {
          ch2 = data[index2];
          if (ch2 === "_")
            continue;
          if (ch2 !== "0" && ch2 !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch2 !== "_";
      }
      if (ch2 === "x") {
        index2++;
        for (; index2 < max; index2++) {
          ch2 = data[index2];
          if (ch2 === "_")
            continue;
          if (!isHexCode(data.charCodeAt(index2)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch2 !== "_";
      }
      for (; index2 < max; index2++) {
        ch2 = data[index2];
        if (ch2 === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch2 !== "_";
    }
    if (ch2 === "_")
      return false;
    for (; index2 < max; index2++) {
      ch2 = data[index2];
      if (ch2 === "_")
        continue;
      if (ch2 === ":")
        break;
      if (!isDecCode(data.charCodeAt(index2))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch2 === "_")
      return false;
    if (ch2 !== ":")
      return true;
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index2));
  }
  function constructYamlInteger(data) {
    var value2 = data, sign = 1, ch2, base2, digits = [];
    if (value2.indexOf("_") !== -1) {
      value2 = value2.replace(/_/g, "");
    }
    ch2 = value2[0];
    if (ch2 === "-" || ch2 === "+") {
      if (ch2 === "-")
        sign = -1;
      value2 = value2.slice(1);
      ch2 = value2[0];
    }
    if (value2 === "0")
      return 0;
    if (ch2 === "0") {
      if (value2[1] === "b")
        return sign * parseInt(value2.slice(2), 2);
      if (value2[1] === "x")
        return sign * parseInt(value2, 16);
      return sign * parseInt(value2, 8);
    }
    if (value2.indexOf(":") !== -1) {
      value2.split(":").forEach(function(v2) {
        digits.unshift(parseInt(v2, 10));
      });
      value2 = 0;
      base2 = 1;
      digits.forEach(function(d2) {
        value2 += d2 * base2;
        base2 *= 60;
      });
      return sign * value2;
    }
    return sign * parseInt(value2, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$3.isNegativeZero(object));
  }
  var int$1 = new Type$a("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  var common$2 = common$6;
  var Type$9 = type;
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value2, sign, base2, digits;
    value2 = data.replace(/_/g, "").toLowerCase();
    sign = value2[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value2[0]) >= 0) {
      value2 = value2.slice(1);
    }
    if (value2 === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value2 === ".nan") {
      return NaN;
    } else if (value2.indexOf(":") >= 0) {
      value2.split(":").forEach(function(v2) {
        digits.unshift(parseFloat(v2, 10));
      });
      value2 = 0;
      base2 = 1;
      digits.forEach(function(d2) {
        value2 += d2 * base2;
        base2 *= 60;
      });
      return sign * value2;
    }
    return sign * parseFloat(value2, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common$2.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$2.isNegativeZero(object));
  }
  var float = new Type$9("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  var Schema$3 = schema;
  var json = new Schema$3({
    include: [
      failsafe
    ],
    implicit: [
      _null,
      bool,
      int$1,
      float
    ]
  });
  var Schema$2 = schema;
  var core = new Schema$2({
    include: [
      json
    ]
  });
  var Type$8 = type;
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null)
      match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null)
      throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-")
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var timestamp = new Type$8("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  var Type$7 = type;
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  var merge$2 = new Type$7("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var NodeBuffer;
  try {
    var _require$1 = commonjsRequire;
    NodeBuffer = _require$1("buffer").Buffer;
  } catch (__) {
  }
  var Type$6 = type;
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null)
      return false;
    var code2, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      code2 = map2.indexOf(data.charAt(idx));
      if (code2 > 64)
        continue;
      if (code2 < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map2.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    if (NodeBuffer) {
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }
    return result;
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    } else if (tail === 2) {
      result += map2[bits >> 10 & 63];
      result += map2[bits >> 4 & 63];
      result += map2[bits << 2 & 63];
      result += map2[64];
    } else if (tail === 1) {
      result += map2[bits >> 2 & 63];
      result += map2[bits << 4 & 63];
      result += map2[64];
      result += map2[64];
    }
    return result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  var binary = new Type$6("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
  var Type$5 = type;
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2 = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null)
      return true;
    var objectKeys = [], index2, length2, pair, pairKey, pairHasKey, object = data;
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      pair = object[index2];
      pairHasKey = false;
      if (_toString$2.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys.indexOf(pairKey) === -1)
        objectKeys.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  var omap = new Type$5("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  var Type$4 = type;
  var _toString$1 = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null)
      return true;
    var index2, length2, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      pair = object[index2];
      if (_toString$1.call(pair) !== "[object Object]")
        return false;
      keys = Object.keys(pair);
      if (keys.length !== 1)
        return false;
      result[index2] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null)
      return [];
    var index2, length2, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      pair = object[index2];
      keys = Object.keys(pair);
      result[index2] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  var pairs = new Type$4("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  var Type$3 = type;
  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null)
      return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  var set = new Type$3("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  var Schema$1 = schema;
  var default_safe = new Schema$1({
    include: [
      core
    ],
    implicit: [
      timestamp,
      merge$2
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });
  var Type$2 = type;
  function resolveJavascriptUndefined() {
    return true;
  }
  function constructJavascriptUndefined() {
    return void 0;
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined$1(object) {
    return typeof object === "undefined";
  }
  var _undefined = new Type$2("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined$1,
    represent: representJavascriptUndefined
  });
  var Type$1 = type;
  function resolveJavascriptRegExp(data) {
    if (data === null)
      return false;
    if (data.length === 0)
      return false;
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp2[0] === "/") {
      if (tail)
        modifiers = tail[1];
      if (modifiers.length > 3)
        return false;
      if (regexp2[regexp2.length - modifiers.length - 1] !== "/")
        return false;
    }
    return true;
  }
  function constructJavascriptRegExp(data) {
    var regexp2 = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp2[0] === "/") {
      if (tail)
        modifiers = tail[1];
      regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1);
    }
    return new RegExp(regexp2, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = "/" + object.source + "/";
    if (object.global)
      result += "g";
    if (object.multiline)
      result += "m";
    if (object.ignoreCase)
      result += "i";
    return result;
  }
  function isRegExp$1(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  var regexp = new Type$1("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp$1,
    represent: representJavascriptRegExp
  });
  var esprima;
  try {
    var _require = commonjsRequire;
    esprima = _require("esprima");
  } catch (_2) {
    if (typeof window !== "undefined")
      esprima = window.esprima;
  }
  var Type = type;
  function resolveJavascriptFunction(data) {
    if (data === null)
      return false;
    try {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  function constructJavascriptFunction(data) {
    var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
      throw new Error("Failed to resolve function");
    }
    ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    if (ast.body[0].expression.body.type === "BlockStatement") {
      return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    return new Function(params, "return " + source.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction$3(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  }
  var _function = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction$3,
    represent: representJavascriptFunction
  });
  var Schema = schema;
  var default_full = Schema.DEFAULT = new Schema({
    include: [
      default_safe
    ],
    explicit: [
      _undefined,
      regexp,
      _function
    ]
  });
  var common$1 = common$6;
  var YAMLException$1 = exception;
  var Mark = mark;
  var DEFAULT_SAFE_SCHEMA$1 = default_safe;
  var DEFAULT_FULL_SCHEMA$1 = default_full;
  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c2) {
    return c2 === 10 || c2 === 13;
  }
  function is_WHITE_SPACE(c2) {
    return c2 === 9 || c2 === 32;
  }
  function is_WS_OR_EOL(c2) {
    return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
  }
  function is_FLOW_INDICATOR(c2) {
    return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
  }
  function fromHexCode(c2) {
    var lc2;
    if (48 <= c2 && c2 <= 57) {
      return c2 - 48;
    }
    lc2 = c2 | 32;
    if (97 <= lc2 && lc2 <= 102) {
      return lc2 - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c2) {
    if (c2 === 120) {
      return 2;
    }
    if (c2 === 117) {
      return 4;
    }
    if (c2 === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c2) {
    if (48 <= c2 && c2 <= 57) {
      return c2 - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c2) {
    return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? " " : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c2) {
    if (c2 <= 65535) {
      return String.fromCharCode(c2);
    }
    return String.fromCharCode(
      (c2 - 65536 >> 10) + 55296,
      (c2 - 65536 & 1023) + 56320
    );
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i$1 = 0; i$1 < 256; i$1++) {
    simpleEscapeCheck[i$1] = simpleEscapeSequence(i$1) ? 1 : 0;
    simpleEscapeMap[i$1] = simpleEscapeSequence(i$1);
  }
  function State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA$1;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException$1(
      message,
      new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
    );
  }
  function throwError$2(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name2, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError$2(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError$2(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError$2(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError$2(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name2, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError$2(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError$2(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError$2(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError$2(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError$2(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError$2(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index2, quantity;
    if (!common$1.isObject(source)) {
      throwError$2(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
      key = sourceKeys[index2];
      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index2, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
        if (Array.isArray(keyNode[index2])) {
          throwError$2(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
          keyNode[index2] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
          mergeMappings(state, _result, valueNode[index2], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError$2(state, "duplicated mapping key");
      }
      _result[keyNode] = valueNode;
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === 10) {
      state.position++;
    } else if (ch2 === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError$2(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch2 = state.input.charCodeAt(state.position);
    while (ch2 !== 0) {
      while (is_WHITE_SPACE(ch2)) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch2 === 35) {
        do {
          ch2 = state.input.charCodeAt(++state.position);
        } while (ch2 !== 10 && ch2 !== 13 && ch2 !== 0);
      }
      if (is_EOL(ch2)) {
        readLineBreak(state);
        ch2 = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch2 === 32) {
          state.lineIndent++;
          ch2 = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch2;
    ch2 = state.input.charCodeAt(_position);
    if ((ch2 === 45 || ch2 === 46) && ch2 === state.input.charCodeAt(_position + 1) && ch2 === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch2 = state.input.charCodeAt(_position);
      if (ch2 === 0 || is_WS_OR_EOL(ch2)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common$1.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch2) || is_FLOW_INDICATOR(ch2) || ch2 === 35 || ch2 === 38 || ch2 === 42 || ch2 === 33 || ch2 === 124 || ch2 === 62 || ch2 === 39 || ch2 === 34 || ch2 === 37 || ch2 === 64 || ch2 === 96) {
      return false;
    }
    if (ch2 === 63 || ch2 === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch2 !== 0) {
      if (ch2 === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch2 === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch2)) {
        break;
      } else if (is_EOL(ch2)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch2 = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch2)) {
        captureEnd = state.position + 1;
      }
      ch2 = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch2, captureStart, captureEnd;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
      if (ch2 === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch2 = state.input.charCodeAt(++state.position);
        if (ch2 === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch2)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError$2(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError$2(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
      if (ch2 === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch2 === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch2 = state.input.charCodeAt(++state.position);
        if (is_EOL(ch2)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch2 < 256 && simpleEscapeCheck[ch2]) {
          state.result += simpleEscapeMap[ch2];
          state.position++;
        } else if ((tmp = escapedHexLen(ch2)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch2 = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch2)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError$2(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError$2(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch2)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError$2(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError$2(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch2 === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch2 = state.input.charCodeAt(++state.position);
    while (ch2 !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch2 = state.input.charCodeAt(state.position);
      if (ch2 === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError$2(state, "missed comma between flow collection entries");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch2 === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch2 = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch2 === 58) {
        isPair = true;
        ch2 = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch2 = state.input.charCodeAt(state.position);
      if (ch2 === 44) {
        readNext = true;
        ch2 = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError$2(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 === 124) {
      folding = false;
    } else if (ch2 === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch2 !== 0) {
      ch2 = state.input.charCodeAt(++state.position);
      if (ch2 === 43 || ch2 === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch2 === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError$2(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch2)) >= 0) {
        if (tmp === 0) {
          throwError$2(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError$2(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch2)) {
      do {
        ch2 = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch2));
      if (ch2 === 35) {
        do {
          ch2 = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch2) && ch2 !== 0);
      }
    }
    while (ch2 !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch2 = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch2 === 32) {
        state.lineIndent++;
        ch2 = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch2)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch2)) {
          atMoreIndented = true;
          state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common$1.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common$1.repeat("\n", emptyLines);
        }
      } else {
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch2) && ch2 !== 0) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch2;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch2 = state.input.charCodeAt(state.position);
    while (ch2 !== 0) {
      if (ch2 !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch2 = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch2 = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch2 !== 0) {
        throwError$2(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch2;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch2 = state.input.charCodeAt(state.position);
    while (ch2 !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      _pos = state.position;
      if ((ch2 === 63 || ch2 === 58) && is_WS_OR_EOL(following)) {
        if (ch2 === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError$2(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch2 = following;
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        if (state.line === _line) {
          ch2 = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch2)) {
            ch2 = state.input.charCodeAt(++state.position);
          }
          if (ch2 === 58) {
            ch2 = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch2)) {
              throwError$2(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError$2(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError$2(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else {
        break;
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch2 = state.input.charCodeAt(state.position);
      }
      if (state.lineIndent > nodeIndent && ch2 !== 0) {
        throwError$2(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 33)
      return false;
    if (state.tag !== null) {
      throwError$2(state, "duplication of a tag property");
    }
    ch2 = state.input.charCodeAt(++state.position);
    if (ch2 === 60) {
      isVerbatim = true;
      ch2 = state.input.charCodeAt(++state.position);
    } else if (ch2 === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch2 = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch2 = state.input.charCodeAt(++state.position);
      } while (ch2 !== 0 && ch2 !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch2 = state.input.charCodeAt(++state.position);
      } else {
        throwError$2(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
        if (ch2 === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError$2(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError$2(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch2 = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError$2(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError$2(state, "tag name cannot contain such characters: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError$2(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 38)
      return false;
    if (state.anchor !== null) {
      throwError$2(state, "duplication of an anchor property");
    }
    ch2 = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError$2(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch2;
    ch2 = state.input.charCodeAt(state.position);
    if (ch2 !== 42)
      return false;
    ch2 = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch2 !== 0 && !is_WS_OR_EOL(ch2) && !is_FLOW_INDICATOR(ch2)) {
      ch2 = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError$2(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError$2(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError$2(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag !== null && state.tag !== "!") {
      if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError$2(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type2 = state.implicitTypes[typeIndex];
          if (type2.resolve(state.result)) {
            state.result = type2.construct(state.result);
            state.tag = type2.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type2 = state.typeMap[state.kind || "fallback"][state.tag];
        if (state.result !== null && type2.kind !== state.kind) {
          throwError$2(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
        }
        if (!type2.resolve(state.result)) {
          throwError$2(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type2.construct(state.result);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError$2(state, "unknown tag !<" + state.tag + ">");
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch2;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while ((ch2 = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch2 = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch2 !== 37) {
        break;
      }
      hasDirectives = true;
      ch2 = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
        ch2 = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError$2(state, "directive name must not be less than one character in length");
      }
      while (ch2 !== 0) {
        while (is_WHITE_SPACE(ch2)) {
          ch2 = state.input.charCodeAt(++state.position);
        }
        if (ch2 === 35) {
          do {
            ch2 = state.input.charCodeAt(++state.position);
          } while (ch2 !== 0 && !is_EOL(ch2));
          break;
        }
        if (is_EOL(ch2))
          break;
        _position = state.position;
        while (ch2 !== 0 && !is_WS_OR_EOL(ch2)) {
          ch2 = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch2 !== 0)
        readLineBreak(state);
      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError$2(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError$2(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state.position = nullpos;
      throwError$2(state, "null byte is not allowed in input");
    }
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
      return documents;
    }
    for (var index2 = 0, length2 = documents.length; index2 < length2; index2 += 1) {
      iterator(documents[index2]);
    }
  }
  function load(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException$1("expected a single document in the stream, but found more");
  }
  function safeLoadAll(input, iterator, options) {
    if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
      options = iterator;
      iterator = null;
    }
    return loadAll(input, iterator, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options));
  }
  function safeLoad(input, options) {
    return load(input, common$1.extend({ schema: DEFAULT_SAFE_SCHEMA$1 }, options));
  }
  loader$2.loadAll = loadAll;
  loader$2.load = load;
  loader$2.safeLoadAll = safeLoadAll;
  loader$2.safeLoad = safeLoad;
  var dumper$1 = {};
  var common = common$6;
  var YAMLException = exception;
  var DEFAULT_FULL_SCHEMA = default_full;
  var DEFAULT_SAFE_SCHEMA = default_safe;
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function compileStyleMap(schema2, map2) {
    var result, keys, index2, length2, tag, style, type2;
    if (map2 === null)
      return {};
    result = {};
    keys = Object.keys(map2);
    for (index2 = 0, length2 = keys.length; index2 < length2; index2 += 1) {
      tag = keys[index2];
      style = String(map2[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length2;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length2 = 2;
    } else if (character <= 65535) {
      handle = "u";
      length2 = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length2 = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length2 - string.length) + string;
  }
  function State(options) {
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length2 = string.length;
    while (position < length2) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length2;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n")
        result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str2) {
    var index2, length2, type2;
    for (index2 = 0, length2 = state.implicitTypes.length; index2 < length2; index2 += 1) {
      type2 = state.implicitTypes[index2];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c2) {
    return c2 === CHAR_SPACE || c2 === CHAR_TAB;
  }
  function isPrintable(c2) {
    return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
  }
  function isNsChar(c2) {
    return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c2, prev2) {
    return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON && (c2 !== CHAR_SHARP || prev2 && isNsChar(prev2));
  }
  function isPlainSafeFirst(c2) {
    return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i2;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) {
      for (i2 = 0; i2 < string.length; i2++) {
        char = string.charCodeAt(i2);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i2 > 0 ? string.charCodeAt(i2 - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
    } else {
      for (i2 = 0; i2 < string.length; i2++) {
        char = string.charCodeAt(i2);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i2;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        prev_char = i2 > 0 ? string.charCodeAt(i2 - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = function() {
      if (string.length === 0) {
        return "''";
      }
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
        return "'" + string + "'";
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ")
      return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for (var i2 = 0; i2 < string.length; i2++) {
      char = string.charCodeAt(i2);
      if (char >= 55296 && char <= 56319) {
        nextChar = string.charCodeAt(i2 + 1);
        if (nextChar >= 56320 && nextChar <= 57343) {
          result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
          i2++;
          continue;
        }
      }
      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char) ? string[i2] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index2, length2;
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      if (writeNode(state, level, object[index2], false, false)) {
        if (index2 !== 0)
          _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index2, length2;
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      if (writeNode(state, level + 1, object[index2], true, true)) {
        if (!compact || index2 !== 0) {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length2, objectKey, objectValue, pairBuffer;
    for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
      pairBuffer = "";
      if (index2 !== 0)
        pairBuffer += ", ";
      if (state.condenseFlow)
        pairBuffer += '"';
      objectKey = objectKeyList[index2];
      objectValue = object[objectKey];
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length2, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
      pairBuffer = "";
      if (!compact || index2 !== 0) {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index2];
      objectValue = object[objectKey];
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index2, length2, type2, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index2 = 0, length2 = typeList.length; index2 < length2; index2 += 1) {
      type2 = typeList[index2];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        state.tag = explicit ? type2.tag : "?";
        if (type2.represent) {
          style = state.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block2, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type2 = _toString.call(state.dump);
    if (block2) {
      block2 = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block2 && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        if (block2 && state.dump.length !== 0) {
          writeBlockSequence(state, arrayLevel, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, arrayLevel, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid)
          return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type2);
      }
      if (state.tag !== null && state.tag !== "?") {
        state.dump = "!<" + state.tag + "> " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index2, length2;
    inspectNode(object, objects, duplicatesIndexes);
    for (index2 = 0, length2 = duplicatesIndexes.length; index2 < length2; index2 += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index2]]);
    }
    state.usedDuplicates = new Array(length2);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index2, length2;
    if (object !== null && typeof object === "object") {
      index2 = objects.indexOf(object);
      if (index2 !== -1) {
        if (duplicatesIndexes.indexOf(index2) === -1) {
          duplicatesIndexes.push(index2);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
            inspectNode(object[index2], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
            inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs)
      getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true))
      return state.dump + "\n";
    return "";
  }
  function safeDump(input, options) {
    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
  dumper$1.dump = dump;
  dumper$1.safeDump = safeDump;
  var loader$1 = loader$2;
  var dumper = dumper$1;
  function deprecated(name2) {
    return function() {
      throw new Error("Function " + name2 + " is deprecated and cannot be used.");
    };
  }
  jsYaml$1.Type = type;
  jsYaml$1.Schema = schema;
  jsYaml$1.FAILSAFE_SCHEMA = failsafe;
  jsYaml$1.JSON_SCHEMA = json;
  jsYaml$1.CORE_SCHEMA = core;
  jsYaml$1.DEFAULT_SAFE_SCHEMA = default_safe;
  jsYaml$1.DEFAULT_FULL_SCHEMA = default_full;
  jsYaml$1.load = loader$1.load;
  jsYaml$1.loadAll = loader$1.loadAll;
  jsYaml$1.safeLoad = loader$1.safeLoad;
  jsYaml$1.safeLoadAll = loader$1.safeLoadAll;
  jsYaml$1.dump = dumper.dump;
  jsYaml$1.safeDump = dumper.safeDump;
  jsYaml$1.YAMLException = exception;
  jsYaml$1.MINIMAL_SCHEMA = failsafe;
  jsYaml$1.SAFE_SCHEMA = default_safe;
  jsYaml$1.DEFAULT_SCHEMA = default_full;
  jsYaml$1.scan = deprecated("scan");
  jsYaml$1.parse = deprecated("parse");
  jsYaml$1.compose = deprecated("compose");
  jsYaml$1.addConstructor = deprecated("addConstructor");
  var yaml = jsYaml$1;
  var jsYaml = yaml;
  var parser = jsYaml;
  var optionalByteOrderMark = "\\ufeff?";
  var platform$2 = typeof process !== "undefined" ? process.platform : "";
  var pattern = "^(" + optionalByteOrderMark + "(= yaml =|---)$([\\s\\S]*?)^(?:\\2|\\.\\.\\.)\\s*$" + (platform$2 === "win32" ? "\\r?" : "") + "(?:\\n)?)";
  var regex = new RegExp(pattern, "m");
  frontMatter$1.exports = extractor;
  frontMatter$1.exports.test = test$1;
  function extractor(string, options) {
    string = string || "";
    var defaultOptions2 = { allowUnsafe: false };
    options = options instanceof Object ? { ...defaultOptions2, ...options } : defaultOptions2;
    options.allowUnsafe = Boolean(options.allowUnsafe);
    var lines = string.split(/(\r?\n)/);
    if (lines[0] && /= yaml =|---/.test(lines[0])) {
      return parse(string, options.allowUnsafe);
    } else {
      return {
        attributes: {},
        body: string,
        bodyBegin: 1
      };
    }
  }
  function computeLocation(match, body) {
    var line = 1;
    var pos = body.indexOf("\n");
    var offset = match.index + match[0].length;
    while (pos !== -1) {
      if (pos >= offset) {
        return line;
      }
      line++;
      pos = body.indexOf("\n", pos + 1);
    }
    return line;
  }
  function parse(string, allowUnsafe) {
    var match = regex.exec(string);
    if (!match) {
      return {
        attributes: {},
        body: string,
        bodyBegin: 1
      };
    }
    var loader2 = allowUnsafe ? parser.load : parser.safeLoad;
    var yaml2 = match[match.length - 1].replace(/^\s+|\s+$/g, "");
    var attributes = loader2(yaml2) || {};
    var body = string.replace(match[0], "");
    var line = computeLocation(match, string);
    return {
      attributes,
      body,
      bodyBegin: line,
      frontmatter: yaml2
    };
  }
  function test$1(string) {
    string = string || "";
    return regex.test(string);
  }
  var frontMatterExports = frontMatter$1.exports;
  const frontMatter = /* @__PURE__ */ getDefaultExportFromCjs(frontMatterExports);
  const LocalStorage = {
    get: (key, asJson = true) => {
      const value2 = localStorage.getItem(key);
      if (!value2) {
        return null;
      }
      const parsed = asJson ? JSON.parse(value2) : value2;
      return parsed;
    },
    set: (key, value2) => {
      localStorage.setItem(key, JSON.stringify(value2));
    },
    remove: (key) => {
      localStorage.removeItem(key);
    },
    clear: () => {
      localStorage.clear();
    },
    getEditorTabs: (slug) => {
      return LocalStorage.get(`editorTabs_${slug}`) || [];
    },
    setEditorTabs: (slug, tabs) => {
      LocalStorage.set(`editorTabs_${slug}`, tabs);
    }
  };
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  const native = {
    randomUUID
  };
  function v4(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
      return native.randomUUID();
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  const BREATHECODE_HOST = "https://breathecode.herokuapp.com";
  const FetchManager = {
    ENVIRONMENT: "",
    HOST: "",
    init: (environment, host) => {
      FetchManager.ENVIRONMENT = environment;
      FetchManager.HOST = host;
    },
    getExercises: async () => {
      const configUrl = FetchManager.ENVIRONMENT === "localhost" ? "config" : "config.json";
      const url2 = FetchManager.ENVIRONMENT === "localhost" ? `${FetchManager.HOST}/${configUrl}` : "/config.json";
      const res = await fetch(url2);
      const config2 = await res.json();
      return config2;
    },
    getReadme: async (slug, language) => {
      const url2 = FetchManager.ENVIRONMENT === "localhost" ? `${FetchManager.HOST}/exercise/${slug}/readme?lang=${language}` : `/exercises/${slug}/README.${language === "us" ? "" : "es."}md`;
      const response = await fetch(url2);
      if (FetchManager.ENVIRONMENT === "localhost") {
        const json2 = await response.json();
        return json2;
      }
      const mdContent = await response.text();
      const matter = frontMatter(mdContent);
      return matter;
    },
    getFileContent: async (slug, file, opts = { cached: false }) => {
      let edited = false;
      const url2 = FetchManager.ENVIRONMENT === "localhost" ? `${FetchManager.HOST}/exercise/${slug}/file/${file}` : `/exercises/${slug}/${file}`;
      const response = await fetch(url2);
      if (FetchManager.ENVIRONMENT === "localStorage" && opts.cached) {
        const cachedEditorTabs = LocalStorage.get(`editorTabs_${slug}`);
        if (cachedEditorTabs) {
          const cached = cachedEditorTabs.find((t2) => {
            return t2.name === file;
          });
          if (cached) {
            edited = true;
            return { fileContent: cached.content, edited };
          }
        }
      }
      const fileContent = await response.text();
      return { fileContent, edited };
    },
    getExerciseInfo: async (slug) => {
      const methods = {
        localhost: async () => {
          const respose = await getExercise(slug);
          const exercise = await respose.json();
          return exercise;
        },
        localStorage: async () => {
          const respose = await fetch("/config.json");
          const config2 = await respose.json();
          const exercise = config2.exercises.find((e2) => e2.slug === slug);
          return exercise;
        }
      };
      return await methods[FetchManager.ENVIRONMENT]();
    },
    saveFileContent: async (slug, filename, content) => {
      const methods = {
        localhost: async () => {
          try {
            const url2 = `${FetchManager.HOST}/exercise/${slug}/file/${filename}`;
            await fetch(url2, {
              method: "PUT",
              body: content
            });
          } catch (e2) {
            console.log("Error saving file content in CLI");
            console.log(e2);
          }
        },
        localStorage: async () => {
        }
      };
      return await methods[FetchManager.ENVIRONMENT]();
    },
    checkLoggedStatus: async () => {
      const methods = {
        localStorage: async () => {
          const session = LocalStorage.get("session");
          if (!session)
            throw Error("The user is not logged in");
          const user = await validateUser(session.token);
          if (!user) {
            LocalStorage.remove("session");
            throw Error("The token is invalid or inactive!");
          }
          const loggedFormat = {
            payload: { ...session },
            rigoToken: session.rigobot.key
          };
          return loggedFormat;
        },
        localhost: async () => {
          const res = await fetch(`${FetchManager.HOST}/check/rigo/status`);
          if (res.status === 400) {
            throw Error("The user is not logged in");
          }
          const json2 = await res.json();
          const user = await validateUser(json2.payload.token);
          if (user === null) {
            FetchManager.logout();
            throw Error("The user session is expired!");
          }
          return json2;
        }
      };
      return methods[FetchManager.ENVIRONMENT]();
    },
    setTabHash: async (tabHash) => {
      const methods = {
        localhost: async () => {
          const body = {
            hash: tabHash
          };
          const res = await fetch(`${FetchManager.HOST}/set-tab-hash`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(body)
          });
          if (res.status === 400) {
            console.log("ERROR");
            console.log(res);
            throw Error("Impossible to set tab hash");
          }
          await res.json();
          return true;
        },
        localStorage: async () => {
          LocalStorage.set("TAB_HASH", tabHash);
          return true;
        }
      };
      return methods[FetchManager.ENVIRONMENT]();
    },
    getTabHash: async () => {
      const methods = {
        localhost: async () => {
          const res = await fetch(`${FetchManager.HOST}/check/rigo/status`);
          if (res.status === 400) {
            const tabHash = v4();
            await FetchManager.setTabHash(tabHash);
            return tabHash;
          }
          const json2 = await res.json();
          if ("tabHash" in json2.payload) {
            return json2.payload.tabHash;
          } else {
            const tabHash = v4();
            await FetchManager.setTabHash(tabHash);
            return tabHash;
          }
        },
        localStorage: async () => {
          let tabHash = LocalStorage.get("TAB_HASH");
          if (!tabHash) {
            tabHash = v4();
            await FetchManager.setTabHash(tabHash);
          }
          return tabHash;
        }
      };
      return methods[FetchManager.ENVIRONMENT]();
    },
    getSessionKey: async () => {
      const methods = {
        localhost: async () => {
          const res = await fetch(`${FetchManager.HOST}/check/rigo/status`);
          if (res.status === 400) {
            throw Error("The user is not logged in");
          }
          const json2 = await res.json();
          if ("sessionKey" in json2.payload) {
            return json2.payload.sessionKey;
          } else {
            return null;
          }
        },
        localStorage: async () => {
          let sessionKey = LocalStorage.get("LEARNPACK_SESSION_KEY");
          if (!sessionKey) {
            return null;
          }
          return sessionKey;
        }
      };
      return methods[FetchManager.ENVIRONMENT]();
    },
    setSessionKey: async (sessionKey) => {
      const methods = {
        localhost: async () => {
          const body = {
            sessionKey
          };
          const res = await fetch(`${FetchManager.HOST}/set-session-key`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(body)
          });
          if (res.status === 400) {
            console.log("ERROR");
            console.log(res);
            throw Error("Impossible to set session key");
          }
          await res.json();
          return true;
        },
        localStorage: async () => {
          LocalStorage.set("LEARNPACK_SESSION_KEY", sessionKey);
        }
      };
      return methods[FetchManager.ENVIRONMENT]();
    },
    login: async (loginInfo) => {
      const methods = {
        localhost: async () => {
          return await loginLocalhost(loginInfo, FetchManager.HOST);
        },
        localStorage: async () => {
          return await loginLocalStorage(loginInfo);
        }
      };
      return methods[FetchManager.ENVIRONMENT]();
    },
    loginWithToken: async (breathecodeToken) => {
      const user = await validateUser(breathecodeToken);
      if (!user) {
        throw Error("Unable to login with provided credentials");
      }
      const rigoUrl = `${RIGOBOT_HOST}/v1/auth/me/token?breathecode_token=${breathecodeToken}`;
      const rigoResp = await fetch(rigoUrl);
      if (!rigoResp.ok) {
        throw Error("Unable to obtain Rigobot token");
      }
      const rigobotJson = await rigoResp.json();
      const returns = { ...user, rigobot: { ...rigobotJson } };
      LocalStorage.set("session", returns);
      const loggedFormat = {
        payload: { ...returns },
        rigoToken: returns.rigobot.key
      };
      if (FetchManager.ENVIRONMENT === "localhost") {
        const tabHash = await FetchManager.getTabHash();
        await setSessionInCLI({
          ...loggedFormat.payload,
          token: breathecodeToken,
          tabHash
        });
      }
      return loggedFormat;
    },
    logout: async () => {
      const methods = {
        localhost: async () => {
          await logoutCLI(FetchManager.HOST);
        },
        localStorage: async () => {
          LocalStorage.remove("session");
          const params = getParamsObject();
          if (params.token) {
            delete params.token;
          }
          setWindowHash(params);
          window.location.reload();
        }
      };
      methods[FetchManager.ENVIRONMENT]();
    }
  };
  const validateUser = async (breathecodeToken) => {
    const config2 = {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Token ${breathecodeToken}`
      }
    };
    const res = await fetch(`${BREATHECODE_HOST}/v1/auth/user/me`, config2);
    if (!res.ok) {
      return null;
    }
    const json2 = await res.json();
    if ("roles" in json2) {
      delete json2.roles;
    }
    if ("permissions" in json2) {
      delete json2.permissions;
    }
    if ("settings" in json2) {
      delete json2.settings;
    }
    return json2;
  };
  const logoutCLI = async (host) => {
    const config2 = {
      method: "post",
      body: JSON.stringify({}),
      headers: {
        "Content-Type": "application/json"
      }
    };
    const res = await fetch(host + "/logout", config2);
    if (!res.ok) {
      console.log("Error trying to logout", res.statusText);
    }
  };
  const loginLocalhost = async (loginInfo, host) => {
    const config2 = {
      method: "post",
      body: JSON.stringify(loginInfo),
      headers: {
        "Content-Type": "application/json"
      }
    };
    const res = await fetch(host + "/login", config2);
    const json2 = await res.json();
    return json2;
  };
  const loginLocalStorage = async (loginInfo) => {
    const url2 = `${BREATHECODE_HOST}/v1/auth/login/`;
    const res = await fetch(url2, {
      body: JSON.stringify(loginInfo),
      method: "post",
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (!res.ok) {
      throw Error("Unable to login with provided credentials");
    }
    const json2 = await res.json();
    const rigoUrl = `${RIGOBOT_HOST}/v1/auth/me/token?breathecode_token=${json2.token}`;
    const rigoResp = await fetch(rigoUrl);
    const rigobotJson = await rigoResp.json();
    const returns = { ...json2, rigobot: { ...rigobotJson } };
    LocalStorage.set("session", returns);
    return returns;
  };
  const setSessionInCLI = async (payload) => {
    const body = {
      payload: { ...payload }
    };
    const res = await fetch(`${FetchManager.HOST}/set-session`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if (res.status === 400) {
      console.log("ERROR");
      console.log(res);
      throw Error("Impossible to set tab hash");
    }
    await res.json();
    return true;
  };
  function generateUUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
      var r2 = Math.random() * 16 | 0, v2 = c2 == "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  }
  const inputByLang = {
    js: "prompt(",
    py: "input(",
    java: "Scanner(System.in).nextLine()",
    cs: "Console.ReadLine()",
    rb: "gets",
    php: "$_POST['input']",
    go: "bufio.NewReader(os.Stdin).ReadString('\\n')",
    swift: "readLine()"
  };
  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function searchInputsForFile(filename, fileContent) {
    try {
      const extension = filename.split(".").pop();
      if (!extension)
        return null;
      const input = inputByLang[extension];
      if (!input)
        return null;
      let regex2;
      if (extension === "js" || extension === "py" || extension === "swift") {
        const escapedInput = escapeRegExp(input);
        regex2 = new RegExp(`${escapedInput}\\s*\\s*("(.*?)"|'(.*?)')`, "g");
      }
      const matches = [];
      let match;
      while ((match = regex2 == null ? void 0 : regex2.exec(fileContent)) !== null) {
        if (match) {
          matches.push(match[1] || match[2]);
        }
      }
      const fixedMatches = matches.map((match2) => match2.replace(/['"]/g, ""));
      return fixedMatches.length > 0 ? fixedMatches : null;
    } catch (error2) {
      console.error("Something went wrong:", error2);
      return null;
    }
  }
  let HOST$1 = getHost();
  function removeTripleBackticks(input) {
    if (input.startsWith("```json") && input.endsWith("```")) {
      return input.slice(7, -3);
    }
    return input;
  }
  const localStorageEventEmitter = {
    events: {},
    statusEvents: {},
    emit: (event, data) => {
      if (localStorageEventEmitter.events[event]) {
        localStorageEventEmitter.events[event].forEach(
          (callback) => callback(data)
        );
      }
    },
    emitStatus: (status, data) => {
      if (localStorageEventEmitter.statusEvents[status]) {
        localStorageEventEmitter.statusEvents[status](data);
      }
    },
    on: (event, callback) => {
      if (!localStorageEventEmitter.events[event]) {
        localStorageEventEmitter.events[event] = [];
      }
      localStorageEventEmitter.events[event].push(callback);
    },
    onStatus: (status, callback) => {
      localStorageEventEmitter.statusEvents[status] = callback;
    },
    openWindow: (data) => {
      if (data && data.url) {
        if (data.options.redirect) {
          window.location.href = data.url;
        } else {
          window.open(data.url, "__blank");
        }
      } else {
        console.error("No URL provided in data");
      }
    }
  };
  localStorageEventEmitter.on("build", async (data) => {
    try {
      const cachedEditorTabs = LocalStorage.get(`editorTabs_${data.exerciseSlug}`) || data.editorTabs;
      let content = "";
      let extensions = [];
      const inputsObject = {};
      const userRequiredInputs = [];
      cachedEditorTabs.forEach((tab) => {
        extensions.push(tab.name.split(".").pop());
        const inputs2 = searchInputsForFile(tab.name, tab.content);
        if (inputs2) {
          userRequiredInputs.push(...inputs2);
        }
        const contentToAdd = `
      \`\`\`FILE NAME: ${tab.name}
      ${tab.content} 
      \`\`\` 
`;
        content += contentToAdd;
      });
      if (userRequiredInputs.length > 0 && data.submittedInputs.length === 0) {
        localStorageEventEmitter.emit("ask", {
          inputs: userRequiredInputs,
          nextAction: "build"
        });
        return;
      }
      if (data.submittedInputs.length > 0) {
        data.submittedInputs.forEach((input, index2) => {
          inputsObject[`${userRequiredInputs[index2]}`] = input;
        });
      }
      if (extensions.includes("html")) {
        const compiled = compileHTML(cachedEditorTabs);
        localStorage.setItem("htmlString", compiled);
        const outputTab = {
          id: generateUUID(),
          name: "terminal",
          content: compiled,
          isActive: false,
          isHTML: true
        };
        data.updateEditorTabs(outputTab);
        localStorageEventEmitter.emitStatus("compiler-success", {
          htmlString: compiled
        });
        return;
      }
      if (extensions.includes("jsx")) {
        const compiled = compileReactHTML(cachedEditorTabs);
        localStorage.setItem("htmlString", compiled);
        const outputTab = {
          id: generateUUID(),
          name: "terminal",
          content: compiled,
          isActive: false,
          isHTML: true
        };
        data.updateEditorTabs(outputTab);
        localStorageEventEmitter.emitStatus("compiler-success", {
          htmlString: compiled
        });
        return;
      }
      const inputs = {
        code: content,
        inputs: JSON.stringify(inputsObject)
      };
      const dataRigobotReturns = await buildRigo(data.token, inputs);
      const json2 = JSON.parse(removeTripleBackticks(dataRigobotReturns));
      if (json2.exitCode > 0) {
        localStorageEventEmitter.emitStatus("compiler-error", json2);
      } else {
        localStorageEventEmitter.emitStatus("compiler-success", json2);
      }
      let logs = [json2];
      if (logs !== null) {
        let terminalContent = "";
        logs.forEach((log2) => {
          terminalContent += log2.stdout + "\n";
          terminalContent += log2.stderr + "\n\n";
          if (log2.testResults) {
            terminalContent += log2.testResults + "\n\n";
          }
        });
        const terminalTab = {
          id: "terminal",
          content: terminalContent,
          name: "terminal",
          isActive: false,
          from: "build"
        };
        data.updateEditorTabs(terminalTab);
      }
    } catch (e2) {
      console.table({
        "Something unexpected happened in the build event": e2
      });
      await FetchManager.logout();
    }
  });
  localStorageEventEmitter.on("reset", async (data) => {
    LocalStorage.remove(`editorTabs_${data.exerciseSlug}`);
    data.updateEditorTabs();
  });
  localStorageEventEmitter.on("open", async (data) => {
    const { fileContent } = await FetchManager.getFileContent(
      data.exerciseSlug,
      data.solutionFileName
    );
    const solutionTab = {
      id: generateUUID(),
      name: data.solutionFileName,
      content: fileContent,
      isActive: true
    };
    data.updateEditorTabs(solutionTab);
  });
  localStorageEventEmitter.on("test", async (data) => {
    try {
      const exe = await FetchManager.getExerciseInfo(data.exerciseSlug);
      let testContent = "";
      const inputsObject = {};
      const userRequiredInputs = [];
      for (const f2 of exe.files) {
        if (f2.name.includes("solution") || f2.name.includes("README"))
          continue;
        const { fileContent } = await FetchManager.getFileContent(
          data.exerciseSlug,
          f2.name,
          { cached: true }
        );
        const inputs2 = searchInputsForFile(f2.name, fileContent);
        if (inputs2) {
          userRequiredInputs.push(...inputs2);
        }
        testContent += `
\`\`\`<FILE name="${f2.name}" file_context="${!f2.hidden ? "THIS FILE IS CODE FROM THE USER, THIS  AND THE OTHER USER FILES WILL BE TESTED BY YOU" : "THIS FILE IS A TEST FILE, YOU MUST MIMICK THE EXECUTION OF THIS TEST FILE AGAINST THE USER CODE"}">  
${fileContent}
</FILE>
\`\`\`
      `;
      }
      if (userRequiredInputs.length > 0 && data.submittedInputs.length === 0) {
        localStorageEventEmitter.emit("ask", {
          inputs: userRequiredInputs,
          nextAction: "test"
        });
        return;
      }
      if (data.submittedInputs.length > 0) {
        data.submittedInputs.forEach((input, index2) => {
          inputsObject[`${userRequiredInputs[index2]}`] = input;
        });
      }
      const inputs = {
        code: testContent,
        inputs: JSON.stringify(inputsObject),
        userLanguage: data.language
      };
      console.log(inputs, "INPUTS SENT TO RIGOBOT");
      const starting_at = (/* @__PURE__ */ new Date()).getTime();
      const json2 = await testRigo(data.token, inputs);
      json2.ended_at = (/* @__PURE__ */ new Date()).getTime();
      json2.source_code = JSON.stringify(inputs);
      json2.starting_at = starting_at;
      let terminalContent = "";
      terminalContent += json2.stdout + "\n";
      terminalContent += json2.stderr + "\n\n";
      if (json2.testResults) {
        terminalContent += json2.testResults + "\n\n";
      }
      if (json2.message) {
        const separator = "# Rigo Feedback \n\n";
        terminalContent += separator + json2.message + "\n\n";
      }
      if (json2.reasoning) {
        console.log("AI reasoning", json2.reasoning);
      }
      const terminalTab = {
        id: generateUUID(),
        content: terminalContent,
        name: "terminal",
        isActive: false,
        from: "test"
      };
      data.updateEditorTabs(terminalTab);
      json2.stdout = terminalContent;
      if (json2.exitCode === 0) {
        localStorageEventEmitter.emitStatus("testing-success", {
          result: json2,
          logs: [JSON.stringify(json2)]
        });
      } else {
        localStorageEventEmitter.emitStatus("testing-error", {
          ...json2.stdout,
          logs: [JSON.stringify(json2)]
        });
      }
    } catch (e2) {
      _t.error("ERROR TRYING TO TEST");
      return;
    }
  });
  const EventProxy = {
    getEmitter: (environment) => {
      const emitters = {
        localhost: () => {
          Socket.start(HOST$1, disconnected, onConnectCli);
          return Socket.createScope("compiler");
        },
        localStorage: () => {
          return localStorageEventEmitter;
        }
      };
      return emitters[environment]();
    }
  };
  const buildRigo = async (token, inputs) => {
    const result = await fetch(`${RIGOBOT_HOST}/v1/prompting/completion/57/`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Token " + token
      },
      body: JSON.stringify({
        inputs,
        include_purpose_objective: false,
        execute_async: false
      })
    });
    const json2 = await result.json();
    return json2.answer;
  };
  const testRigo = async (token, inputs) => {
    const result = await fetch(`${RIGOBOT_HOST}/v1/prompting/completion/93/`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Token " + token
      },
      body: JSON.stringify({
        inputs,
        include_purpose_objective: false,
        execute_async: false
      })
    });
    const json2 = await result.json();
    console.log(json2, "Test completed successfully");
    return json2.parsed;
  };
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const kindOf = ((cache2) => (thing) => {
    const str2 = toString.call(thing);
    return cache2[str2] || (cache2[str2] = str2.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type2) => {
    type2 = type2.toLowerCase();
    return (thing) => kindOf(thing) === type2;
  };
  const typeOfTest = (type2) => (thing) => typeof thing === type2;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString$1 = typeOfTest("string");
  const isFunction$2 = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject$3 = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject$3(val) && isFunction$2(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i2;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys[i2];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i2 = keys.length;
    let _key;
    while (i2-- > 0) {
      _key = keys[i2];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge$1() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge$1(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge$1({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
      arguments[i2] && forEach(arguments[i2], assignValue);
    }
    return result;
  }
  const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key) => {
      if (thisArg && isFunction$2(val)) {
        a2[key] = bind(val, thisArg);
      } else {
        a2[key] = val;
      }
    }, { allOwnKeys });
    return a2;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i2;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop = props[i2];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str2, searchString, position) => {
    str2 = String(str2);
    if (position === void 0 || position > str2.length) {
      position = str2.length;
    }
    position -= searchString.length;
    const lastIndex = str2.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  const toArray = (thing) => {
    if (!thing)
      return null;
    if (isArray(thing))
      return thing;
    let i2 = thing.length;
    if (!isNumber(i2))
      return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  const isTypedArray = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str2) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str2)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str2) => {
    return str2.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name2) => {
      let ret;
      if ((ret = reducer(descriptor, name2, obj)) !== false) {
        reducedDescriptors[name2] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name2) => {
      if (isFunction$2(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
        return false;
      }
      const value2 = obj[name2];
      if (!isFunction$2(value2))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name2 + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter2) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value2) => {
        obj[value2] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
    return obj;
  };
  const noop$1 = () => {
  };
  const toFiniteNumber = (value2, defaultValue) => {
    return value2 != null && Number.isFinite(value2 = +value2) ? value2 : defaultValue;
  };
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
    let str2 = "";
    const { length: length2 } = alphabet2;
    while (size--) {
      str2 += alphabet2[Math.random() * length2 | 0];
    }
    return str2;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction$2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i2) => {
      if (isObject$3(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i2] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value2, key) => {
            const reducedValue = visit(value2, i2 + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject$3(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);
  const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb2) => {
        callbacks.push(cb2);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb2) => setTimeout(cb2);
  })(
    typeof setImmediate === "function",
    isFunction$2(_global.postMessage)
  );
  const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  const utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString$1,
    isNumber,
    isBoolean,
    isObject: isObject$3,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction$2,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge: merge$1,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty: hasOwnProperty$1,
    hasOwnProp: hasOwnProperty$1,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop$1,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap
  };
  function AxiosError(message, code2, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code2 && (this.code = code2);
    config2 && (this.config = config2);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$1.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code2) => {
    descriptors[code2] = { value: code2 };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error2, code2, config2, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$1.toFlatObject(error2, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error2.message, code2, config2, request, response);
    axiosError.cause = error2;
    axiosError.name = error2.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path)
      return key;
    return path.concat(key).map(function each(token, i2) {
      token = removeBrackets(token);
      return !dots && i2 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$1.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
    if (!utils$1.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value2) {
      if (value2 === null)
        return "";
      if (utils$1.isDate(value2)) {
        return value2.toISOString();
      }
      if (!useBlob && utils$1.isBlob(value2)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$1.isArrayBuffer(value2) || utils$1.isTypedArray(value2)) {
        return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
      }
      return value2;
    }
    function defaultVisitor(value2, key, path) {
      let arr = value2;
      if (value2 && !path && typeof value2 === "object") {
        if (utils$1.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value2 = JSON.stringify(value2);
        } else if (utils$1.isArray(value2) && isFlatArray(value2) || (utils$1.isFileList(value2) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value2))) {
          key = removeBrackets(key);
          arr.forEach(function each(el2, index2) {
            !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
              convertValue(el2)
            );
          });
          return false;
        }
      }
      if (isVisitable(value2)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value2));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value2, path) {
      if (utils$1.isUndefined(value2))
        return;
      if (stack.indexOf(value2) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value2);
      utils$1.forEach(value2, function each(el2, key) {
        const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
          formData,
          el2,
          utils$1.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el2, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils$1.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str2) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name2, value2) {
    this._pairs.push([name2, value2]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value2) {
      return encoder.call(this, value2, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url2, params, options) {
    if (!params) {
      return url2;
    }
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    }
  }
  const InterceptorManager$1 = InterceptorManager;
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  const _navigator = typeof navigator === "object" && navigator || void 0;
  const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  const hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const origin = hasBrowserEnv && window.location.href || "http://localhost";
  const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin
  }, Symbol.toStringTag, { value: "Module" }));
  const platform = {
    ...utils,
    ...platform$1
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value2, key, path, helpers2) {
        if (platform.isNode && utils$1.isBuffer(value2)) {
          this.append(key, value2.toString("base64"));
          return false;
        }
        return helpers2.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  function parsePropPath(name2) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i2;
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value2, target, index2) {
      let name2 = path[index2++];
      if (name2 === "__proto__")
        return true;
      const isNumericKey = Number.isFinite(+name2);
      const isLast = index2 >= path.length;
      name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
      if (isLast) {
        if (utils$1.hasOwnProp(target, name2)) {
          target[name2] = [target[name2], value2];
        } else {
          target[name2] = value2;
        }
        return !isNumericKey;
      }
      if (!target[name2] || !utils$1.isObject(target[name2])) {
        target[name2] = [];
      }
      const result = buildPath(path, value2, target[name2], index2);
      if (result && utils$1.isArray(target[name2])) {
        target[name2] = arrayToObject(target[name2]);
      }
      return !isNumericKey;
    }
    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};
      utils$1.forEachEntry(formData, (name2, value2) => {
        buildPath(parsePropPath(name2), value2, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser2, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$1.isObject(data);
      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils$1.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e2;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  const defaults$1 = defaults;
  const ignoreDuplicateOf = utils$1.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
      i2 = line.indexOf(":");
      key = line.substring(0, i2).trim().toLowerCase();
      val = line.substring(i2 + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header2) {
    return header2 && String(header2).trim().toLowerCase();
  }
  function normalizeValue(value2) {
    if (value2 === false || value2 == null) {
      return value2;
    }
    return utils$1.isArray(value2) ? value2.map(normalizeValue) : String(value2);
  }
  function parseTokens(str2) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str2)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
  function matchHeaderValue(context, value2, header2, filter, isHeaderNameFilter) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value2, header2);
    }
    if (isHeaderNameFilter) {
      value2 = header2;
    }
    if (!utils$1.isString(value2))
      return;
    if (utils$1.isString(filter)) {
      return value2.indexOf(filter) !== -1;
    }
    if (utils$1.isRegExp(filter)) {
      return filter.test(value2);
    }
  }
  function formatHeader(header2) {
    return header2.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str2) => {
      return char.toUpperCase() + str2;
    });
  }
  function buildAccessors(obj, header2) {
    const accessorName = utils$1.toCamelCase(" " + header2);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header2, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header2, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$1.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$1.isPlainObject(header2) || header2 instanceof this.constructor) {
        setHeaders(header2, valueOrRewrite);
      } else if (utils$1.isString(header2) && (header2 = header2.trim()) && !isValidHeaderName(header2)) {
        setHeaders(parseHeaders(header2), valueOrRewrite);
      } else if (utils$1.isHeaders(header2)) {
        for (const [key, value2] of header2.entries()) {
          setHeader(value2, key, rewrite);
        }
      } else {
        header2 != null && setHeader(valueOrRewrite, header2, rewrite);
      }
      return this;
    }
    get(header2, parser2) {
      header2 = normalizeHeader(header2);
      if (header2) {
        const key = utils$1.findKey(this, header2);
        if (key) {
          const value2 = this[key];
          if (!parser2) {
            return value2;
          }
          if (parser2 === true) {
            return parseTokens(value2);
          }
          if (utils$1.isFunction(parser2)) {
            return parser2.call(this, value2, key);
          }
          if (utils$1.isRegExp(parser2)) {
            return parser2.exec(value2);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header2, matcher) {
      header2 = normalizeHeader(header2);
      if (header2) {
        const key = utils$1.findKey(this, header2);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header2, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils$1.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$1.isArray(header2)) {
        header2.forEach(deleteHeader);
      } else {
        deleteHeader(header2);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i2 = keys.length;
      let deleted = false;
      while (i2--) {
        const key = keys[i2];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils$1.forEach(this, (value2, header2) => {
        const key = utils$1.findKey(headers, header2);
        if (key) {
          self2[key] = normalizeValue(value2);
          delete self2[header2];
          return;
        }
        const normalized = format2 ? formatHeader(header2) : String(header2).trim();
        if (normalized !== header2) {
          delete self2[header2];
        }
        self2[normalized] = normalizeValue(value2);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$1.forEach(this, (value2, header2) => {
        value2 != null && value2 !== false && (obj[header2] = asStrings && utils$1.isArray(value2) ? value2.join(", ") : value2);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header2, value2]) => header2 + ": " + value2).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header2) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$1.isArray(header2) ? header2.forEach(defineAccessor) : defineAccessor(header2);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value: value2 }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value2,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1.freezeMethods(AxiosHeaders);
  const AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config2 = this || defaults$1;
    const context = response || config2;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value2) {
    return !!(value2 && value2.__CANCEL__);
  }
  function CanceledError(message, config2, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  utils$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  function parseProtocol(url2) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match && match[1] || "";
  }
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i2 = tail;
      let bytesCount = 0;
      while (i2 !== head) {
        bytesCount += bytes[i2++];
        i2 = i2 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function throttle(fn, freq) {
    let timestamp2 = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp2 = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn.apply(null, args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp2;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return throttle((e2) => {
      const loaded = e2.loaded;
      const total = e2.lengthComputable ? e2.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e2,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  const progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
  const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      const msie = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url2) {
        let href = url2;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  const cookies = platform.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name2, value2, expires, path, domain, secure) {
        const cookie = [name2 + "=" + encodeURIComponent(value2)];
        utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils$1.isString(path) && cookie.push("path=" + path);
        utils$1.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({ caseless }, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a2, b2, caseless) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(a2, b2, caseless);
      } else if (!utils$1.isUndefined(a2)) {
        return getMergedValue(void 0, a2, caseless);
      }
    }
    function valueFromConfig2(a2, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a2, b2) {
      if (!utils$1.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils$1.isUndefined(a2)) {
        return getMergedValue(void 0, a2);
      }
    }
    function mergeDirectKeys(a2, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a2, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a2);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
    };
    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
    });
    return config3;
  }
  const resolveConfig = (config2) => {
    const newConfig = mergeConfig({}, config2);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config2.params, config2.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type2, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig(config2);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config2,
          request
        };
        settle(function _resolve(value2) {
          resolve(value2);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config2,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol2 = parseProtocol(_config.url);
      if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config2));
        return;
      }
      request.send(requestData || null);
    });
  };
  const composeSignals = (signals, timeout) => {
    const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length2) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils$1.asap(unsubscribe);
      return signal;
    }
  };
  const composeSignals$1 = composeSignals;
  const streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };
  const readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  const readStream = async function* (stream) {
    if (stream[Symbol.asyncIterator]) {
      yield* stream;
      return;
    }
    const reader = stream.getReader();
    try {
      for (; ; ) {
        const { done, value: value2 } = await reader.read();
        if (done) {
          break;
        }
        yield value2;
      }
    } finally {
      await reader.cancel();
    }
  };
  const trackStream = (stream, chunkSize, onProgress, onFinish) => {
    const iterator = readBytes(stream, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e2) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e2);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value: value2 } = await iterator.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value2.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value2));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder()) : async (str2) => new Uint8Array(await new Response(str2).arrayBuffer()));
  const test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e2) {
      return false;
    }
  };
  const supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const DEFAULT_CHUNK_SIZE = 64 * 1024;
  const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
      !resolvers[type2] && (resolvers[type2] = utils$1.isFunction(res[type2]) ? (res2) => res2[type2]() : (_2, config2) => {
        throw new AxiosError(`Response type '${type2}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
      });
    });
  })(new Response());
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length2 = utils$1.toFiniteNumber(headers.getContentLength());
    return length2 == null ? getBodyLength(body) : length2;
  };
  const fetchAdapter = isFetchSupported && (async (config2) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config2);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url2, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config: config2,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError.from(err, err && err.code, config2, request);
    }
  });
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1.forEach(knownAdapters, (fn, value2) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value: value2 });
      } catch (e2) {
      }
      Object.defineProperty(fn, "adapterName", { value: value2 });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length: length2 } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i2 = 0; i2 < length2; i2++) {
        nameOrAdapter = adapters2[i2];
        let id2;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id2}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id2 || "#" + i2] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s2,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError(null, config2);
    }
  }
  function dispatchRequest(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = AxiosHeaders$1.from(config2.headers);
    config2.data = transformData.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config2);
      response.data = transformData.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const VERSION = "1.7.7";
  const validators$3 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i2) => {
    validators$3[type2] = function validator2(thing) {
      return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
    };
  });
  const deprecatedWarnings = {};
  validators$3.transitional = function transitional(validator2, version2, message) {
    function formatMessage2(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value2, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage2(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage2(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value2, opt, opts) : true;
    };
  };
  function assertOptions(options, schema2, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i2 = keys.length;
    while (i2-- > 0) {
      const opt = keys[i2];
      const validator2 = schema2[opt];
      if (validator2) {
        const value2 = options[opt];
        const result = value2 === void 0 || validator2(value2, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$3
  };
  const validators$2 = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config2) {
      try {
        return await this._request(configOrUrl, config2);
      } catch (err) {
        if (err instanceof Error) {
          let dummy;
          Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e2) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      const { transitional, paramsSerializer, headers } = config2;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators$2.transitional(validators$2.boolean),
          forcedJSONParsing: validators$2.transitional(validators$2.boolean),
          clarifyTimeoutError: validators$2.transitional(validators$2.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config2.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators$2.function,
            serialize: validators$2.function
          }, true);
        }
      }
      config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config2.method]
      );
      headers && utils$1.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config2);
        while (i2 < len) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config2;
      i2 = 0;
      while (i2 < len) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error2) {
          onRejected.call(this, error2);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error2) {
        return Promise.reject(error2);
      }
      i2 = 0;
      len = responseInterceptorChain.length;
      while (i2 < len) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      return buildURL(fullPath, config2.params, config2.paramsSerializer);
    }
  }
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url2, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        url: url2,
        data: (config2 || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url2, data, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: url2,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  const Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners)
          return;
        let i2 = token._listeners.length;
        while (i2-- > 0) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config2, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config2, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token,
        cancel
      };
    }
  }
  const CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$1.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value2]) => {
    HttpStatusCode[value2] = key;
  });
  const HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance2 = bind(Axios$1.prototype.request, context);
    utils$1.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
    utils$1.extend(instance2, context, null, { allOwnKeys: true });
    instance2.create = function create2(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance2;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const axios$1 = axios;
  const getSession = async (token, slug) => {
    const url2 = `${RIGOBOT_HOST}/v1/learnpack/session/?slug=${slug}`;
    try {
      const response = await axios$1.get(url2, {
        headers: {
          Authorization: `Token ${token}`
          // "Content-Type": "application/json", // Not needed for GET requests
        }
      });
      return response.data;
    } catch (error2) {
      console.error("Error fetching session:", error2);
      throw error2;
    }
  };
  const updateSession = async (token, tab_hash, package_slug, config_json, session_key) => {
    const url2 = `${RIGOBOT_HOST}/v1/learnpack/session/${session_key}/`;
    const body = {
      tab_hash,
      config_json,
      package_slug
    };
    try {
      const response = await axios$1.put(url2, body, {
        headers: {
          Authorization: `Token ${token}`,
          "Content-Type": "application/json"
        }
      });
      console.log("Session updated!");
      return response.data;
    } catch (error2) {
      console.error("Error updating session:", error2);
      throw error2;
    }
  };
  const createSession = async (token, tab_hash, package_slug, config_json) => {
    const url2 = `${RIGOBOT_HOST}/v1/learnpack/session/`;
    const body = {
      tab_hash,
      config_json,
      package_slug
    };
    try {
      const response = await axios$1.post(url2, body, {
        headers: {
          Authorization: `Token ${token}`,
          "Content-Type": "application/json"
        }
      });
      return response.data;
    } catch (error2) {
      console.error("Error creating session:", error2);
      throw error2;
    }
  };
  const sendBatchTelemetry = async function(url2, body, token) {
    if (!url2 || !token) {
      console.error("URL and token are required");
      return;
    }
    token = token.trim();
    console.log("Sending batch telemetry", url2, body, token);
    const headers = {
      "Content-Type": "application/json",
      Authorization: `Token ${token}`
    };
    try {
      const response = await axios$1.post(url2, body, {
        headers
      });
      console.log(response);
      return response.data;
    } catch (error2) {
      console.error("Error while sending batch telemetry", error2);
      _t.error("Error while sending telemetry");
      if (axios$1.isAxiosError(error2) && error2.response) {
        console.error("Response data:", error2.response.data);
        console.error("Response status:", error2.response.status);
        console.error("Response headers:", error2.response.headers);
      }
      throw error2;
    }
  };
  const sendStreamTelemetry = async function(url2, body, token) {
    if (!url2 || !token) {
      return;
    }
    fetch(
      url2,
      {
        method: "POST",
        body: JSON.stringify(body)
      }
      // false
    ).then((response) => {
      return response;
    }).catch((error2) => {
      console.log("Error while sending stream Telemetry", error2);
    });
  };
  function createUUID() {
    return Math.random().toString(36).slice(2, 10) + Math.random().toString(36).slice(2, 10);
  }
  function stringToBase64(input) {
    return Buffer.from(input).toString("base64");
  }
  const TelemetryManager = {
    current: null,
    urls: {},
    telemetryKey: "",
    userToken: "",
    salute: (message) => {
      console.log(message);
    },
    start: function(agent, steps, tutorialSlug, storageKey) {
      this.telemetryKey = storageKey;
      if (!this.current) {
        this.retrieve().then((prevTelemetry) => {
          if (prevTelemetry) {
            this.current = prevTelemetry;
            this.finishWorkoutSession();
          } else {
            this.current = {
              telemetry_id: createUUID(),
              slug: tutorialSlug,
              agent,
              tutorial_started_at: Date.now(),
              steps,
              workout_session: [
                {
                  started_at: Date.now()
                }
              ]
            };
          }
          this.save();
          this.submit();
        }).catch((error2) => {
          console.log("ERROR: There was a problem starting the Telemetry");
          console.error(error2);
          throw new Error(
            "There was a problem starting, reload LearnPack\nRun\n$ learnpack start"
          );
        });
      }
    },
    setStudent: function(student) {
      if (!this.current) {
        return;
      }
      this.current.user_id = student.user_id;
      this.save();
      this.submit();
    },
    finishWorkoutSession: function() {
      var _a2, _b;
      if (!this.current) {
        return;
      }
      const lastSession = (_a2 = this.current) == null ? void 0 : _a2.workout_session[this.current.workout_session.length - 1];
      if (lastSession && !lastSession.ended_at && ((_b = this.current) == null ? void 0 : _b.last_interaction_at)) {
        lastSession.ended_at = this.current.last_interaction_at;
        this.current.workout_session.push({
          started_at: Date.now()
        });
      }
    },
    registerStepEvent: function(stepPosition, event, data) {
      console.log(`Registering Event ${event}`);
      if (!this.current) {
        console.error(`Telemetry has not been started, ${event} NOT REGISTERED`);
        return;
      }
      const step = this.current.steps[stepPosition];
      if (!step) {
        console.error(`No step ${stepPosition} found ${event} NOT REGISTERED`);
        return;
      }
      if (data.source_code) {
        data.source_code = stringToBase64(data.source_code);
      }
      if (data.stdout) {
        data.stdout = stringToBase64(data.stdout);
      }
      if (data.stderr) {
        data.stderr = stringToBase64(data.stderr);
      }
      if (Object.prototype.hasOwnProperty.call(data, "exitCode")) {
        data.exit_code = data.exitCode;
        data.exitCode = void 0;
      }
      switch (event) {
        case "compile":
          if (!step.compilations) {
            step.compilations = [];
          }
          step.compilations.push(data);
          this.current.steps[stepPosition] = step;
          break;
        case "test":
          if (!step.tests) {
            step.tests = [];
          }
          step.tests.push(data);
          if (data.exit_code === 0) {
            step.completed_at = Date.now();
          }
          this.current.steps[stepPosition] = step;
          break;
        case "ai_interaction":
          if (!step.ai_interactions) {
            step.ai_interactions = [];
          }
          step.ai_interactions.push(data);
          break;
        case "open_step": {
          const now = Date.now();
          if (!step.opened_at) {
            step.opened_at = now;
            this.current.steps[stepPosition] = step;
          }
          if (this.prevStep || this.prevStep === 0) {
            const prevStep = this.current.steps[this.prevStep];
            if (!prevStep.is_testeable && !prevStep.completed_at) {
              prevStep.completed_at = now;
              this.current.steps[this.prevStep] = prevStep;
            }
          }
          this.prevStep = stepPosition;
          this.submit();
          break;
        }
        default:
          throw new Error(`Event type ${event} is not supported`);
      }
      this.current.last_interaction_at = Date.now();
      this.streamEvent(stepPosition, event, data);
      this.save();
    },
    retrieve: function() {
      const saved = LocalStorage.get(this.telemetryKey);
      if (saved) {
        return Promise.resolve(saved);
      } else {
        return Promise.resolve(null);
      }
    },
    submit: async function() {
      console.log(this.current, this.userToken);
      if (!this.current || !this.userToken) {
        _t.error("Telemetry and user token are required to send telemetry");
        return Promise.resolve();
      }
      const url2 = this.urls.batch;
      if (!url2) {
        return;
      }
      const body = this.current;
      try {
        await sendBatchTelemetry(url2, body, this.userToken);
      } catch (error2) {
      }
    },
    save: function() {
      LocalStorage.set(this.telemetryKey, this.current);
    },
    streamEvent: async function(stepPosition, event, data) {
      if (!this.current)
        return;
      const url2 = this.urls.streaming;
      if (!url2) {
        return;
      }
      const stepSlug = this.current.steps[stepPosition].slug;
      const body = {
        slug: stepSlug,
        telemetry_id: this.current.telemetry_id,
        user_id: this.current.user_id,
        step_position: stepPosition,
        event,
        data
      };
      sendStreamTelemetry(url2, body, this.userToken);
    }
  };
  class MissingRigobotAccountError extends Error {
    constructor(message) {
      super(message);
      this.name = "MissingRigobotAccountError";
    }
  }
  const HOST = getHost();
  const FASTAPI_HOST = "https://ai.4geeks.com";
  const chatSocket = lookup(`${FASTAPI_HOST}`);
  chatSocket.on("connect", () => {
    console.log("connected to chat socket in ", FASTAPI_HOST);
  });
  const defaultParams = getParamsObject();
  FetchManager.init(ENVIRONMENT, HOST);
  const useStore = create$1((set2, get2) => ({
    language: defaultParams.language || "us",
    languageMap: {
      us: "en",
      es: "sp"
    },
    learnpackPurposeId: defaultParams.purpose || 26,
    exercises: [],
    currentContent: "",
    targetButtonForFeedback: "feedback",
    dialogData: {
      message: "",
      format: "md"
    },
    chatSocket,
    currentExercisePosition: defaultParams.currentExercise || 0,
    chatInitialMessage: "Hello! I'm **Rigobot**, your friendly **AI Mentor**! \n\n I can help you if you feel stuck, ask me anything about this exercise!",
    conversationIdsCache: {},
    lessonTitle: "",
    rigoContext: "",
    user_id: null,
    hasSolution: false,
    shouldBeTested: false,
    status: "",
    showFeedback: false,
    token: "",
    bc_token: "",
    buildbuttonText: {
      text: "Run",
      className: ""
    },
    theme: "light",
    isIframe: false,
    tabHash: "",
    sessionKey: "",
    lastState: "",
    isRigoOpened: false,
    editorTabs: [],
    feedbackbuttonProps: {
      text: "execute-my-code",
      className: ""
    },
    configObject: {
      config: {
        intro: "",
        grading: "",
        slug: "",
        editor: {
          agent: ""
        },
        title: {},
        warnings: {}
      },
      exercises: []
    },
    terminalShouldShow: false,
    videoTutorial: "",
    allowedActions: [],
    compilerSocket: EventProxy.getEmitter(ENVIRONMENT),
    showVideoTutorial: false,
    exerciseMessages: {},
    host: HOST,
    openedModals: {
      chat: true,
      login: false,
      video: false,
      reset: false,
      session: false
    },
    activeTab: 0,
    lastTestResult: {
      // @ts-ignore
      status: "",
      logs: ""
    },
    // @ts-ignore
    environment: "localhost",
    // setters
    start: () => {
      const {
        fetchExercises,
        fetchReadme,
        checkParams,
        checkLoggedStatus,
        setListeners,
        figureEnvironment
        // startTelemetry,
      } = get2();
      figureEnvironment().then(
        () => fetchExercises().then(() => {
          return checkParams({ justReturn: false });
        }).then((params) => {
          if (!params.currentExercise) {
            fetchReadme();
          }
        }).then(() => {
          checkLoggedStatus({ startConversation: true });
        }).then(() => {
          setListeners();
        })
      );
    },
    setListeners: () => {
      const {
        compilerSocket,
        setTestResult,
        toastFromStatus,
        setFeedbackButtonProps,
        setOpenedModals,
        // lastStartedAt,
        setBuildButtonPrompt,
        registerTelemetryEvent
      } = get2();
      const debounceTestingSuccess = debounce((data) => {
        console.log(data, "DATA IN DEBOUCE TEST SUCCESFF");
        const stdout = removeSpecialCharacters(data.logs[0]);
        registerTelemetryEvent("test", data);
        setTestResult("successful", stdout);
        set2({ lastState: "success", terminalShouldShow: true });
        toastFromStatus("testing-success");
        if (get2().targetButtonForFeedback === "feedback") {
          setFeedbackButtonProps("Succeded", "bg-success text-white");
        } else {
          setBuildButtonPrompt("Succeded", "bg-success text-white");
        }
      }, 100);
      const debounceError = debounce((data) => {
        const stdout = removeSpecialCharacters(data.logs[0]);
        setTestResult("failed", stdout);
        set2({ lastState: "error", terminalShouldShow: true });
        toastFromStatus("testing-error");
        registerTelemetryEvent("test", data);
        if (get2().targetButtonForFeedback === "feedback") {
          setFeedbackButtonProps("Try again", "bg-fail text-white");
        } else {
          setBuildButtonPrompt("Try again", "bg-fail text-white");
        }
      }, 100);
      let compilerErrorHandler = debounce((data) => {
        set2({ lastState: "error", terminalShouldShow: true });
        if (data.recommendations) {
          _t.error(data.recommendations);
        }
        setBuildButtonPrompt("Try again", "bg-fail");
        const [icon, message] = getStatus("compiler-error");
        _t.error(message, { icon });
        registerTelemetryEvent("compile", data);
      }, 100);
      let compilerSuccessHandler = debounce((data) => {
        set2({ lastState: "success", terminalShouldShow: true });
        const [icon, message] = getStatus("compiler-success");
        _t.success(message, { icon });
        setBuildButtonPrompt("Run", "bg-success");
        registerTelemetryEvent("compile", data);
      }, 100);
      compilerSocket.onStatus("testing-success", debounceTestingSuccess);
      compilerSocket.onStatus("testing-error", debounceError);
      compilerSocket.onStatus("compiler-error", compilerErrorHandler);
      compilerSocket.onStatus("compiler-success", compilerSuccessHandler);
      compilerSocket.onStatus("open_window", () => {
        toastFromStatus("open_window");
      });
      compilerSocket.on("dialog", (data) => {
        set2({ dialogData: data.data });
        setOpenedModals({ dialog: true });
      });
    },
    figureEnvironment: async () => {
      const env = await getEnvironment();
      set2({ compilerSocket: EventProxy.getEmitter(env) });
      FetchManager.init(env, HOST);
      return { message: "Environment figured out!" };
    },
    handleEnvironmentChange: (event) => {
      set2({ environment: event.detail.environment });
    },
    getCurrentExercise: () => {
      const { exercises, currentExercisePosition } = get2();
      if (!exercises || exercises.length === 0) {
        return {};
      }
      return exercises[currentExercisePosition];
    },
    setExerciseMessages: (messages2, position) => {
      set2({
        exerciseMessages: { ...get2().exerciseMessages, [position]: messages2 }
      });
    },
    setShowVideoTutorial: (show) => {
      set2({ showVideoTutorial: show });
    },
    // TODO: This is not being used implement or delete
    setAllowedActions: (actions2) => {
      set2({ allowedActions: actions2 });
    },
    // functions
    setBuildButtonPrompt: (t2, c2 = "") => {
      set2({ buildbuttonText: { text: t2, className: c2 } });
    },
    setFeedbackButtonProps: (t2, c2 = "") => {
      set2({ feedbackbuttonProps: { text: t2, className: c2 } });
    },
    setOpenedModals: (modals2) => {
      const { openedModals } = get2();
      set2({ openedModals: { ...openedModals, ...modals2 } });
    },
    setToken: (newToken) => {
      set2({ token: newToken });
    },
    setTerminalShouldShow: (shouldShow) => {
      set2({ terminalShouldShow: shouldShow });
    },
    checkLoggedStatus: async (opts) => {
      const {
        startConversation,
        currentExercisePosition,
        setOpenedModals,
        checkParams,
        getOrCreateActiveSession,
        startTelemetry
      } = get2();
      const params = checkParams({ justReturn: true });
      try {
        if (params.token) {
          const json2 = await FetchManager.loginWithToken(params.token);
          set2({ token: json2.rigoToken });
          set2({ bc_token: params.token });
        } else {
          const json2 = await FetchManager.checkLoggedStatus();
          set2({ token: json2.rigoToken });
          set2({ bc_token: json2.payload.token });
        }
        if (opts && opts.startConversation) {
          startConversation(Number(currentExercisePosition));
        }
        getOrCreateActiveSession();
        await startTelemetry();
      } catch (err) {
        console.log("ERROR WHILE TRYING TO CHECK LOGGED STATUS", err);
        set2({ token: "" });
        setOpenedModals({ login: true });
      }
    },
    getContextFilesContent: async () => {
      const { getCurrentExercise, currentContent, configObject, language } = get2();
      let context = "";
      const getExtractor = (mode2 = "isolated") => {
        const modeToExtractor = {
          isolated: (file) => {
            return !file.hidden && !file.name.toLowerCase().includes("readme") && !file.name.toLowerCase().includes("pycache");
          },
          incremental: (file) => {
            return file && !file.name.toLowerCase().includes("readme") || !file.name.toLowerCase().includes("pycache");
          }
        };
        return modeToExtractor[mode2];
      };
      const currentExercise = getCurrentExercise();
      const slug = currentExercise.slug;
      let mode = configObject.config.grading;
      if (!["incremental", "isolated"].includes(mode))
        mode = "incremental";
      const extractor2 = getExtractor(mode);
      const contextFiles = currentExercise.files.filter(extractor2);
      const filePromises = contextFiles.map(async (file) => {
        const { fileContent } = await FetchManager.getFileContent(
          slug,
          file.name,
          {
            cached: true
          }
        );
        return `
< File name: ${file.name} 

  Content: 
\`${fileContent}\`
>
      `;
      });
      return Promise.all(filePromises).then((filesContext) => {
        context += filesContext.join("\n");
        context += `
<
This is the current exercise instructions:
${currentContent}
>

<MANDATORY FOR AI: The user's set up the application in "${language}" language, give your feedback in "${language}" language, please.>

      `;
        return context;
      });
    },
    fetchExercises: async () => {
      const { user_id, setOpenedModals } = get2();
      try {
        const config2 = await FetchManager.getExercises();
        if (!config2)
          return;
        if (config2.config.warnings.agent) {
          set2({
            dialogData: { message: config2.config.warnings.agent, format: "md" }
          });
          setOpenedModals({ dialog: true });
        }
        if (config2.config.warnings.extension) {
          set2({
            dialogData: {
              message: config2.config.warnings.extension,
              format: "md"
            }
          });
          setOpenedModals({ dialog: true });
        }
        const slug = config2.config.slug;
        TagManager.dataLayer({
          dataLayer: {
            event: "start_exercise",
            slug,
            user_id
          }
        });
        set2({ exercises: config2.exercises });
        set2({ lessonTitle: config2.config.title.us });
        set2({ configObject: config2 });
      } catch (err) {
      }
    },
    checkParams: ({ justReturn }) => {
      const { setLanguage, setPosition, language } = get2();
      let paramsObject = getParamsObject();
      if (justReturn) {
        return paramsObject;
      }
      const paramsActions = {
        language: (value2) => {
          if (!(language === value2)) {
            setLanguage(value2, false);
          }
        },
        currentExercise: (value2) => {
          setPosition(Number(value2));
        },
        iframe: (value2) => {
          if (value2.toLowerCase() === "true") {
            set2({ isIframe: true });
          }
          if (value2.toLowerCase() === "false") {
            set2({ isIframe: false });
          }
        },
        theme: (value2) => {
          if (["light", "dark"].includes(value2.toLowerCase().trim())) {
            set2({ theme: value2 });
          }
        }
      };
      const entries = Object.entries(paramsObject);
      for (let [key, value2] of entries) {
        if (key in paramsActions) {
          paramsActions[key](value2);
        }
      }
      return paramsObject;
    },
    fetchSingleExerciseInfo: async (index2) => {
      var _a2;
      const { exercises } = get2();
      if (exercises.length <= 0) {
        return;
      }
      const slug = (_a2 = exercises[index2]) == null ? void 0 : _a2.slug;
      if (!slug) {
        return;
      }
      const exercise = await FetchManager.getExerciseInfo(slug);
      let isTesteable = exercise.graded;
      let isBuildable;
      let hasSolution = false;
      if (exercise.entry)
        isBuildable = true;
      if (!exercise.language)
        isBuildable = false;
      const solutionFiles = exercise.files.filter(
        (file) => file.name.includes("solution.hide")
      );
      if (solutionFiles.length > 0) {
        hasSolution = true;
        let solution = await FetchManager.getFileContent(
          slug,
          solutionFiles[0].name
        );
        set2({ currentSolution: solution.fileContent });
      }
      set2({
        isTesteable,
        isBuildable,
        hasSolution
      });
      return exercise;
    },
    setPosition: (newPosition) => {
      const {
        startConversation,
        fetchReadme,
        token,
        setBuildButtonPrompt,
        setFeedbackButtonProps,
        checkParams,
        registerTelemetryEvent
      } = get2();
      let params = checkParams({ justReturn: true });
      setWindowHash({ ...params, currentExercise: String(newPosition) });
      set2({ currentExercisePosition: newPosition });
      if (token) {
        startConversation(newPosition);
      }
      setBuildButtonPrompt("execute-my-code", "");
      setFeedbackButtonProps("test-my-code", "");
      set2({ lastState: "" });
      registerTelemetryEvent("open_step", {});
      fetchReadme();
    },
    startConversation: async (exercisePosition) => {
      const { token, learnpackPurposeId, conversationIdsCache } = get2();
      let conversationId = null;
      let initialData = null;
      if (!token) {
        return;
      }
      try {
        conversationId = conversationIdsCache[exercisePosition];
        if (!conversationId) {
          throw new Error("ConversationID not found in cache");
        }
      } catch (err) {
        initialData = await startChat(learnpackPurposeId, token);
        conversationId = initialData.conversation_id;
      }
      if (initialData && initialData.salute) {
        set2({ chatInitialMessage: initialData.salute });
      }
      set2({
        conversationIdsCache: {
          ...conversationIdsCache,
          [exercisePosition]: conversationId
        }
      });
      chatSocket.emit("start", {
        token,
        purpose: learnpackPurposeId,
        conversationId
      });
    },
    // @ts-ignore
    loginToRigo: async (loginInfo) => {
      const {
        setToken,
        startConversation,
        currentExercisePosition,
        setOpenedModals,
        getOrCreateActiveSession
      } = get2();
      try {
        const json2 = await FetchManager.login(loginInfo);
        set2({ bc_token: json2.token, user_id: json2.user_id });
        if (json2.rigobot == null) {
          throw new MissingRigobotAccountError(
            "No rigobot user found, did you already accept Rigobot's invitation?"
          );
        }
        setToken(json2.rigobot.key);
        _t.success("Successfully logged in");
      } catch (error2) {
        if (error2 instanceof MissingRigobotAccountError) {
          setOpenedModals({ login: false, rigobotInvite: true });
          return false;
        } else {
          const errorMessage = `It appears that something was wrong with your 4Geeks credentials, please try again`;
          _t.error(errorMessage);
          return false;
        }
      }
      startConversation(currentExercisePosition);
      setOpenedModals({ login: false });
      getOrCreateActiveSession();
      return true;
    },
    checkRigobotInvitation: async () => {
      const { bc_token, setToken, openLink } = get2();
      const rigoAcceptedUrl = `${RIGOBOT_HOST}/v1/auth/me/token?breathecode_token=${bc_token}`;
      const res = await fetch(rigoAcceptedUrl);
      if (res.status != 200) {
        _t.error("You have not accepted Rigobot's invitation yet!");
        openLink(
          "https://rigobot.herokuapp.com/invite?referer=4geeks&token=" + bc_token,
          { redirect: false }
        );
        return;
      }
      const data = await res.json();
      setToken(data.key);
      const payload = { token: data.key };
      const config2 = {
        method: "post",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      };
      await fetch(`${HOST}/set-rigobot-token`, config2);
    },
    openLink: (url2, opts = { redirect: false }) => {
      const { compilerSocket, getCurrentExercise } = get2();
      const options = { ...opts };
      const data = {
        url: url2,
        exerciseSlug: getCurrentExercise().slug,
        options
      };
      compilerSocket.openWindow(data);
    },
    updateEditorTabs: (newTab = null) => {
      const { getCurrentExercise, editorTabs } = get2();
      const exercise = getCurrentExercise();
      const notHidden = exercise.files.filter((f2) => !f2.hidden);
      let editorTabsCopy = [...editorTabs];
      if (newTab) {
        const tabExists = editorTabsCopy.some((tab) => tab.name === newTab.name);
        if (tabExists) {
          const tabIndex = editorTabsCopy.findIndex(
            // @ts-ignore
            (t2) => t2.name === newTab.name
          );
          editorTabsCopy[tabIndex] = {
            // @ts-ignore
            ...newTab,
            // @ts-ignore
            isActive: newTab.name === "terminal" ? false : true
          };
        } else {
          if (newTab.name === "terminal") {
            editorTabsCopy.push({
              // @ts-ignore
              ...newTab,
              isActive: false
            });
          } else {
            editorTabsCopy = editorTabsCopy.map((tab) => ({
              ...tab,
              isActive: false
            }));
            editorTabsCopy.push({
              // @ts-ignore
              ...newTab,
              isActive: true
            });
          }
        }
      }
      const updateTabs = async () => {
        for (const [index2, element] of notHidden.entries()) {
          let content = "";
          const { fileContent, edited } = await FetchManager.getFileContent(
            exercise.slug,
            element.name,
            { cached: true }
          );
          content = fileContent;
          if ("content" in element && element.content !== content) {
            await FetchManager.saveFileContent(
              exercise.slug,
              element.name,
              content
            );
          }
          const tabExists = editorTabsCopy.some(
            (tab2) => tab2.name === element.name
          );
          const tab = {
            id: index2,
            content,
            name: element.name,
            isActive: index2 === 0 && !newTab,
            modified: edited
          };
          if (!tabExists) {
            editorTabsCopy = [...editorTabsCopy, tab];
          } else {
            const tabIndex = editorTabsCopy.findIndex(
              (t2) => t2.name === element.name
            );
            editorTabsCopy[tabIndex] = tab;
          }
        }
        const someActive = editorTabsCopy.some((tab) => tab.isActive);
        if (!someActive && editorTabsCopy.length > 0) {
          editorTabsCopy[0].isActive = true;
        }
        set2({ editorTabs: [...editorTabsCopy] });
      };
      updateTabs();
    },
    cleanTerminal: () => {
      const { editorTabs } = get2();
      const newTabs = editorTabs.filter((t2) => t2.name !== "terminal");
      set2({ editorTabs: [...newTabs] });
    },
    fetchReadme: async () => {
      var _a2;
      const {
        language,
        exercises,
        currentExercisePosition,
        fetchSingleExerciseInfo,
        configObject,
        updateEditorTabs
      } = get2();
      const slug = (_a2 = exercises[currentExercisePosition]) == null ? void 0 : _a2.slug;
      if (!slug) {
        return;
      }
      const exercise = await FetchManager.getReadme(slug, language);
      if (!exercise)
        return;
      if (exercise.attributes.tutorial) {
        set2({ videoTutorial: exercise.attributes.tutorial });
      } else if (exercise.attributes.intro) {
        set2({
          videoTutorial: exercise.attributes.intro,
          showVideoTutorial: true
        });
      } else {
        set2({ videoTutorial: "", showVideoTutorial: false });
      }
      let readme = replaceSlot(exercise.body, "{{publicUrl}}", HOST);
      if (typeof configObject.config.variables === "object") {
        for (let v2 in configObject.config.variables) {
          readme = replaceSlot(
            readme,
            `{{${v2}}}`,
            // @ts-ignore
            configObject.config.variables[v2]
          );
        }
      }
      set2({ currentContent: readme });
      set2({ editorTabs: [] });
      fetchSingleExerciseInfo(currentExercisePosition);
      updateEditorTabs();
    },
    toggleSidebar: () => {
      changeSidebarVisibility();
    },
    setLanguage: (language, fetchExercise = true) => {
      const { fetchReadme, checkParams } = get2();
      set2({ language });
      let params = checkParams({ justReturn: true });
      setWindowHash({ ...params, language });
      if (fetchExercise) {
        fetchReadme();
      }
    },
    openTerminal: () => {
      const { compilerSocket, getCurrentExercise } = get2();
      const data = {
        exerciseSlug: getCurrentExercise().slug
      };
      compilerSocket.emit("open_terminal", data);
    },
    handleNext: () => {
      const { currentExercisePosition, handlePositionChange } = get2();
      handlePositionChange(Number(currentExercisePosition) + 1);
    },
    handlePositionChange: async (desiredPosition) => {
      const {
        configObject,
        currentExercisePosition,
        exercises,
        setPosition,
        isTesteable,
        runExerciseTests
      } = get2();
      const gradingMode = configObject.config.grading;
      const lastExercise = exercises.length - 1;
      if (desiredPosition > lastExercise || desiredPosition < 0) {
        _t.error("The exercise you are looking for does not exist!");
        return;
      }
      if (desiredPosition == currentExercisePosition) {
        return;
      }
      let letPass = true;
      if (desiredPosition > Number(currentExercisePosition)) {
        letPass = !isTesteable || gradingMode === "isolated" || gradingMode === "incremental" && // @ts-ignore
        exercises[currentExercisePosition].done;
      }
      if (!letPass) {
        runExerciseTests({
          toast: true,
          setFeedbackButton: true,
          feedbackButtonText: "Running...",
          targetButton: "feedback"
        });
        return;
      }
      setPosition(Number(desiredPosition));
    },
    toastFromStatus: (status) => {
      const { language } = get2();
      const [icon, message] = getStatus(status, language);
      let duration = 1500;
      if (status === "testing-error") {
        duration = 3e3;
      }
      _t.success(message, { icon, duration });
    },
    setTestResult: (status, logs) => {
      console.log(logs);
      const { exercises, currentExercisePosition, updateDBSession } = get2();
      const copy2 = [...exercises];
      copy2[Number(currentExercisePosition)].done = status === "successful";
      set2({ exercises: copy2 });
      updateDBSession();
    },
    setShouldBeTested: (value2) => {
      set2({ shouldBeTested: value2 });
    },
    build: (buildText, submittedInputs = []) => {
      const {
        setBuildButtonPrompt,
        compilerSocket,
        getCurrentExercise,
        editorTabs,
        token,
        updateEditorTabs,
        setOpenedModals
      } = get2();
      if (!Boolean(token)) {
        setOpenedModals({ mustLogin: true });
        return;
      }
      setBuildButtonPrompt(buildText, "");
      const [icon, message] = getStatus("compiling");
      _t.success(message, { icon });
      const data = {
        exerciseSlug: getCurrentExercise().slug,
        token,
        updateEditorTabs,
        editorTabs,
        submittedInputs
      };
      compilerSocket.emit("build", data);
      set2({ lastStartedAt: /* @__PURE__ */ new Date() });
    },
    setEditorTabs: (tabs) => {
      set2({ editorTabs: tabs });
    },
    runExerciseTests: (opts, submittedInputs = []) => {
      const {
        compilerSocket,
        getCurrentExercise,
        setFeedbackButtonProps,
        toastFromStatus,
        token,
        updateEditorTabs,
        setOpenedModals,
        editorTabs,
        language
      } = get2();
      if (!Boolean(token)) {
        setOpenedModals({ mustLogin: true });
        return;
      }
      const data = {
        exerciseSlug: getCurrentExercise().slug,
        token,
        updateEditorTabs,
        editorTabs,
        submittedInputs,
        language
      };
      compilerSocket.emit("test", data);
      set2({ shouldBeTested: false });
      if (opts == null ? void 0 : opts.targetButton) {
        set2({ targetButtonForFeedback: opts.targetButton });
      }
      if (opts && opts.setFeedbackButton && opts.targetButton === "feedback" && opts.feedbackButtonText) {
        setFeedbackButtonProps(opts.feedbackButtonText, "palpitate");
      }
      if (opts && opts.toast)
        toastFromStatus("testing");
    },
    registerAIInteraction: (stepPosition, interaction) => {
      const { compilerSocket, getCurrentExercise, user_id } = get2();
      TagManager.dataLayer({
        dataLayer: {
          event: "ai_interaction",
          interaction,
          slug: getCurrentExercise().slug,
          user_id
        }
      });
      const telemetryData = {
        exerciseSlug: getCurrentExercise().slug,
        stepPosition,
        event: "ai_interaction",
        eventData: interaction
      };
      compilerSocket.emit("ai_interaction", telemetryData);
    },
    // Leave this empty for development purposes
    displayTestButton: DEV_MODE,
    getOrCreateActiveSession: async () => {
      const { token, configObject, setOpenedModals, updateEditorTabs, tabHash } = get2();
      let storedTabHash = tabHash;
      if (!token)
        return;
      if (!storedTabHash) {
        storedTabHash = await FetchManager.getTabHash();
        set2({ tabHash: storedTabHash });
      }
      try {
        const session = await getSession(token, configObject.config.slug);
        if (!session.tab_hash) {
          await updateSession(
            token,
            storedTabHash,
            configObject.config.slug,
            configObject,
            session.key
          );
          set2({ sessionKey: session.key });
        }
        if (session.tab_hash && session.tab_hash !== storedTabHash) {
          setOpenedModals({ session: true });
        } else {
          set2({
            configObject: session.config_json,
            exercises: session.config_json.exercises
          });
          set2({ sessionKey: session.key });
          await FetchManager.setSessionKey(session.key);
          updateEditorTabs();
        }
      } catch (e2) {
        console.log("Error trying to get session");
      }
    },
    updateDBSession: async () => {
      const { configObject, exercises, token, tabHash, sessionKey } = get2();
      const configCopy = { ...configObject, exercises };
      let cachedSessionKey = "";
      if (!sessionKey) {
        cachedSessionKey = await FetchManager.getSessionKey();
      }
      await updateSession(
        token,
        tabHash,
        configObject.config.slug,
        configCopy,
        sessionKey || cachedSessionKey
      );
    },
    updateFileContent: async (exerciseSlug, tab, updateTabs = false) => {
      const { exercises, updateEditorTabs } = get2();
      let newExercises = exercises.map((e2) => {
        if (e2.slug === exerciseSlug) {
          return {
            ...e2,
            files: e2.files.map((f2) => {
              return f2.name === tab.name ? {
                ...f2,
                content: tab.content,
                modified: true
              } : f2;
            })
          };
        } else {
          return e2;
        }
      });
      await FetchManager.saveFileContent(exerciseSlug, tab.name, tab.content);
      set2({ exercises: newExercises });
      if (updateTabs) {
        updateEditorTabs();
      }
    },
    resetExercise: ({ exerciseSlug }) => {
      const { updateEditorTabs, exercises, compilerSocket, updateDBSession } = get2();
      let newExercises = exercises.map((e2) => {
        if (e2.slug === exerciseSlug) {
          return {
            ...e2,
            files: e2.files.map((f2) => {
              delete f2.content;
              delete f2.modified;
              return f2;
            })
          };
        } else {
          return e2;
        }
      });
      set2({ exercises: newExercises, lastState: "" });
      updateDBSession();
      const data = {
        exerciseSlug,
        updateEditorTabs
      };
      compilerSocket.emit("reset", data);
    },
    sessionActions: async ({ action = "new" }) => {
      const { configObject, token, updateEditorTabs, tabHash } = get2();
      let storedTabHash = tabHash;
      if (!storedTabHash) {
        storedTabHash = await FetchManager.getTabHash();
      }
      if (action === "new") {
        const session = await createSession(
          token,
          tabHash,
          configObject.config.slug,
          configObject
        );
        await FetchManager.setSessionKey(session.key);
        set2({
          sessionKey: session.key
        });
      }
      if (action === "continue") {
        const session = await getSession(token, configObject.config.slug);
        await updateSession(
          token,
          tabHash,
          configObject.config.slug,
          null,
          session.key
        );
        set2({
          configObject: session.config_json,
          exercises: session.config_json.exercises,
          sessionKey: session.key
        });
        await FetchManager.setSessionKey(session.key);
        updateEditorTabs();
      }
    },
    refreshDataFromAnotherTab: ({ newToken, newTabHash, newBCToken }) => {
      const { token, bc_token, tabHash, getOrCreateActiveSession } = get2();
      if (!(token === newToken)) {
        set2({ token: newToken });
      }
      if (!(bc_token === newBCToken)) {
        set2({ bc_token: newBCToken });
      }
      if (!(tabHash === newTabHash)) {
        set2({ tabHash: newTabHash });
      }
      getOrCreateActiveSession();
    },
    toggleTheme: () => {
      const { theme, checkParams } = get2();
      let params = checkParams({ justReturn: true });
      if (theme === "dark") {
        setWindowHash({ ...params, theme: "light" });
        set2({ theme: "light" });
      } else {
        setWindowHash({ ...params, theme: "dark" });
        set2({ theme: "dark" });
      }
    },
    toggleRigo: () => {
      const { token, isRigoOpened, setOpenedModals } = get2();
      if (!token) {
        setOpenedModals({ mustLogin: true });
        return;
      }
      set2({ isRigoOpened: !isRigoOpened });
    },
    registerTelemetryEvent: (event, data) => {
      const { currentExercisePosition } = get2();
      TelemetryManager.registerStepEvent(
        Number(currentExercisePosition),
        event,
        data
      );
    },
    startTelemetry: async () => {
      var _a2, _b;
      const { configObject, bc_token } = get2();
      console.log(" starting telemetry", configObject, bc_token);
      if (!bc_token || !configObject) {
        console.log("No token or config found");
        return;
      }
      if (configObject.exercises && configObject.exercises.length > 0) {
        const steps = configObject.exercises.map((e2, index2) => ({
          slug: e2.slug,
          position: e2.position || index2,
          files: e2.files,
          ai_interactions: [],
          compilations: [],
          tests: [],
          is_testeable: e2.graded || false
        }));
        const agent = ((_a2 = configObject.config) == null ? void 0 : _a2.editor.agent) || "";
        const tutorialSlug = ((_b = configObject.config) == null ? void 0 : _b.slug) || "";
        const STORAGE_KEY = "TELEMETRY";
        if (!configObject.config.telemetry) {
          console.error("No telemetry urls found in config");
          return;
        }
        TelemetryManager.urls = configObject.config.telemetry;
        TelemetryManager.userToken = bc_token;
        TelemetryManager.start(agent, steps, tutorialSlug, STORAGE_KEY);
      }
    },
    setRigoContext: (context) => {
      set2({ rigoContext: context });
    },
    test: async () => {
      FetchManager.logout();
    }
  }));
  const styles$6 = "";
  const svgs = {
    buildIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "15",
        height: "13",
        viewBox: "0 0 8 6",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_544_516)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M2.10358 4.59753L0.8353 3.2226L2.10358 1.84767",
                stroke: "white",
                strokeWidth: "0.505448",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M5.90039 4.59753L7.16867 3.2226L5.90039 1.84767",
                stroke: "white",
                strokeWidth: "0.505448",
                strokeLinecap: "round",
                strokeLinejoin: "round"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M2.94233 5.68985L5.06477 0.755509",
                stroke: "white",
                strokeWidth: "0.505448",
                strokeLinecap: "round"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_544_516", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "rect",
            {
              width: "7.17446",
              height: "5",
              fill: "white",
              transform: "translate(0.421326 0.72229)"
            }
          ) }) })
        ]
      }
    ),
    dropdownButton: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "24",
        height: "16",
        viewBox: "0 0 24 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            opacity: "0.8",
            d: "M8 15.7979H24V13.1649H8V15.7979ZM0 0V2.63299H24V0H0ZM8 9.21546H24V6.58247H8V9.21546Z",
            fill: "var(--read-font-color)"
          }
        )
      }
    ),
    nextArrowButton: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "30",
        height: "30",
        viewBox: "0 0 21 21",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "10.5", cy: "10.5", r: "10.5", fill: "var(--bg-color)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5.66634 10.8882L13.7797 10.8882L10.053 14.0602L10.9997 14.8603L16.333 10.3208L10.9997 5.7813L10.0597 6.58139L13.7797 9.75335L5.66634 9.75335V10.8882Z",
              fill: "var(--read-font-color)"
            }
          )
        ]
      }
    ),
    prevArrowButton: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "30",
        height: "30",
        viewBox: "0 0 21 21",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "10.5", cy: "10.5", r: "10.5", fill: "var(--bg-color)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M16.3332 10.4556H8.21984L11.9465 7.28365L10.9998 6.48356L5.6665 11.023L10.9998 15.5625L11.9398 14.7624L8.21984 11.5905H16.3332V10.4556Z",
              fill: "var(--read-font-color)"
            }
          )
        ]
      }
    ),
    closeIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "30px",
        height: "30px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              cx: "12",
              cy: "12",
              r: "10",
              stroke: "var(--read-font-color)",
              strokeWidth: "1.5"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.5 9.50002L9.5 14.5M9.49998 9.5L14.5 14.5",
              stroke: "var(--read-font-color)",
              strokeWidth: "1.5",
              strokeLinecap: "round"
            }
          )
        ]
      }
    ),
    nextIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        fill: "#000000",
        height: "800px",
        width: "800px",
        version: "1.1",
        id: "Layer_1",
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        viewBox: "0 0 512 512",
        xmlSpace: "preserve",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M256,0C114.618,0,0,114.618,0,256s114.618,256,256,256s256-114.618,256-256S397.382,0,256,0z M256,469.333\r\n				c-117.818,0-213.333-95.515-213.333-213.333S138.182,42.667,256,42.667S469.333,138.182,469.333,256S373.818,469.333,256,469.333\r\n				z"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M228.418,134.248c-8.331-8.331-21.839-8.331-30.17,0c-8.331,8.331-8.331,21.839,0,30.17L289.83,256l-91.582,91.582\r\n				c-8.331,8.331-8.331,21.839,0,30.17c8.331,8.331,21.839,8.331,30.17,0l106.667-106.667c8.331-8.331,8.331-21.839,0-30.17\r\n				L228.418,134.248z"
            }
          )
        ] }) }) })
      }
    ),
    previusIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        fill: "#000000",
        height: "800px",
        width: "800px",
        version: "1.1",
        id: "Layer_1",
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        viewBox: "0 0 512 512",
        xmlSpace: "preserve",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M256,0C114.618,0,0,114.618,0,256s114.618,256,256,256s256-114.618,256-256S397.382,0,256,0z M256,469.333\r\n				c-117.818,0-213.333-95.515-213.333-213.333S138.182,42.667,256,42.667S469.333,138.182,469.333,256S373.818,469.333,256,469.333\r\n				z"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M313.752,134.248c-8.331-8.331-21.839-8.331-30.17,0L176.915,240.915c-8.331,8.331-8.331,21.839,0,30.17l106.667,106.667\r\n				c8.331,8.331,21.839,8.331,30.17,0c8.331-8.331,8.331-21.839,0-30.17L222.17,256l91.582-91.582\r\n				C322.083,156.087,322.083,142.58,313.752,134.248z"
            }
          )
        ] }) }) })
      }
    ),
    fourGeeksIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "17",
        height: "17",
        viewBox: "0 0 19 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M15.9386 12.2931L16.0404 11.3769H17.011C17.6957 11.3769 18.2605 10.7787 18.2605 10.0981V6.59072C18.4781 6.53077 18.9132 6.37039 18.9132 6.04409V5.71079C18.9132 5.44303 18.5729 5.14458 18.3289 5.14458H18.0123C17.7892 4.85449 17.4238 4.70947 17.011 4.70947H16.3444C16.0892 4.20185 15.7001 3.72908 15.2454 3.37765C15.3445 3.33582 15.4379 3.28701 15.5258 3.2368C16.1087 2.90629 16.4559 2.47397 16.5592 1.95658C16.7363 1.05709 16.1031 0.234288 16.0766 0.200818L15.919 0L15.8312 0.238472C15.8284 0.246839 15.4895 1.1296 14.2442 1.1296C14.1549 1.1296 14.0628 1.12542 13.968 1.11566C13.0825 1.03198 12.4716 0.836743 11.8246 0.630348C10.8512 0.320752 9.84426 0 7.80679 0C6.73579 0 5.79585 0.225921 5.01209 0.673579C4.38314 1.03198 3.85599 1.53263 3.44459 2.16019C2.81006 3.12802 2.65247 4.09307 2.62458 4.2911C2.53394 4.42498 2.45166 4.56444 2.38193 4.70947H1.7739C1.3611 4.70947 0.997117 4.85449 0.772594 5.14458H0.458814C0.188267 5.14458 0 5.46113 0 5.71079V6.04409C0 6.38575 0.435106 6.53777 0.652661 6.59351V10.0967C0.652661 10.43 0.747492 10.7536 0.952492 10.9864C1.16726 11.2305 1.44896 11.3769 1.77669 11.3769H2.68874L2.70547 11.5415L2.71941 11.667H2.72081L2.79054 12.2987C2.90489 13.1718 3.32466 13.8746 4.00103 14.3516C4.61464 14.7824 5.41929 15.0014 6.32717 15.0014H12.3992C13.2693 15.0014 14.0991 14.7532 14.7364 14.2846C15.417 13.7826 15.8312 13.1006 15.9386 12.2931ZM7.97139 10.0967C7.97139 10.2348 7.67015 10.4342 7.47629 10.4342H1.77669C1.75158 10.4342 1.73345 10.4286 1.72648 10.423C1.6944 10.391 1.68046 10.2459 1.68046 10.1511C1.68046 10.1343 1.66651 10.1162 1.66651 10.0981V5.9325C1.66651 5.91439 1.68046 5.89765 1.68046 5.88091C1.68046 5.79027 1.68604 5.63684 1.71532 5.60757C1.71951 5.60199 1.74461 5.57967 1.77529 5.57967H7.25595C7.71336 5.57967 7.96997 5.99108 7.96997 6.15147V10.0967H7.97139ZM11.3114 10.4342C11.1064 10.4342 11.0869 10.1316 11.0869 10.0967V6.15147C11.0869 5.76932 11.2249 5.57967 11.5303 5.57967H17.011C17.2132 5.57967 17.5367 5.80422 17.5367 5.9325V10.0967C17.5367 10.2278 17.209 10.4342 17.011 10.4342H11.3114Z",
            fill: "var(--color-active)"
          }
        )
      }
    ),
    questionIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "26",
        height: "26",
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M7.5 0C3.36 0 0 3.36 0 7.5C0 11.64 3.36 15 7.5 15C11.64 15 15 11.64 15 7.5C15 3.36 11.64 0 7.5 0ZM8.25 12.75H6.75V11.25H8.25V12.75ZM9.8025 6.9375L9.1275 7.6275C8.5875 8.175 8.25 8.625 8.25 9.75H6.75V9.375C6.75 8.55 7.0875 7.8 7.6275 7.2525L8.5575 6.3075C8.835 6.0375 9 5.6625 9 5.25C9 4.425 8.325 3.75 7.5 3.75C6.675 3.75 6 4.425 6 5.25H4.5C4.5 3.5925 5.8425 2.25 7.5 2.25C9.1575 2.25 10.5 3.5925 10.5 5.25C10.5 5.91 10.23 6.51 9.8025 6.9375Z",
            fill: "var(--color-active)"
          }
        )
      }
    ),
    bugIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "26",
        height: "26",
        viewBox: "0 0 15 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M15 10.2V8.53333H12.4417C12.4 8.20833 12.3417 7.89167 12.2583 7.58333L14.4083 6.34167L13.575 4.9L11.6 6.03333C11.3667 5.63333 11.0833 5.275 10.775 4.95833C10.8083 4.76667 10.8333 4.575 10.8333 4.36667C10.8333 3.7 10.6333 3.075 10.2917 2.55L11.6667 1.175L10.4917 0L9.05833 1.43333C7.65833 0.691667 6.475 1.15833 5.95 1.43333L4.50833 0L3.33333 1.175L4.70833 2.55C4.36667 3.075 4.16667 3.7 4.16667 4.36667C4.16667 4.575 4.19167 4.76667 4.225 4.96667C3.91667 5.28333 3.63333 5.64167 3.4 6.03333L1.425 4.89167L0.591667 6.33333L2.74167 7.575C2.65833 7.88333 2.6 8.2 2.55833 8.525H0V10.1917H2.55833C2.6 10.5167 2.65833 10.8333 2.74167 11.1417L0.591667 12.3833L1.425 13.825L3.4 12.7C4.3 14.2083 5.8 15.2 7.5 15.2C9.2 15.2 10.7 14.2083 11.6 12.7L13.575 13.8417L14.4083 12.4L12.2583 11.1583C12.3417 10.85 12.4 10.5333 12.4417 10.2083H15V10.2ZM8.33333 11.8667H6.66667V6.86667H8.33333V11.8667Z",
            fill: "#616E7C"
          }
        )
      }
    ),
    userIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "28",
        height: "28",
        viewBox: "0 0 17 17",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M13.7157 13.8895C12.8809 11.8287 10.8602 10.375 8.5 10.375C6.13977 10.375 4.11906 11.8287 3.28433 13.8895M13.7157 13.8895C15.1243 12.526 16 10.6153 16 8.5C16 4.35786 12.6421 1 8.5 1C4.35786 1 1 4.35786 1 8.5C1 10.6153 1.87569 12.526 3.28433 13.8895M13.7157 13.8895C12.3659 15.196 10.5269 16 8.5 16C6.47315 16 4.63408 15.196 3.28433 13.8895M11 6C11 7.38071 9.88071 8.5 8.5 8.5C7.11929 8.5 6 7.38071 6 6C6 4.61929 7.11929 3.5 8.5 3.5C9.88071 3.5 11 4.61929 11 6Z",
            stroke: "#616E7C",
            strokeWidth: "1.2",
            strokeLinejoin: "round"
          }
        )
      }
    ),
    videoIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "16px",
        height: "16px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M19.5617 7C19.7904 5.69523 18.7863 4.5 17.4617 4.5H6.53788C5.21323 4.5 4.20922 5.69523 4.43784 7",
              stroke: "var(--color-active)",
              strokeWidth: "1.5"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M17.4999 4.5C17.5283 4.24092 17.5425 4.11135 17.5427 4.00435C17.545 2.98072 16.7739 2.12064 15.7561 2.01142C15.6497 2 15.5194 2 15.2588 2H8.74099C8.48035 2 8.35002 2 8.24362 2.01142C7.22584 2.12064 6.45481 2.98072 6.45704 4.00434C6.45727 4.11135 6.47146 4.2409 6.49983 4.5",
              stroke: "var(--color-active)",
              strokeWidth: "1.5"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M14.5812 13.6159C15.1396 13.9621 15.1396 14.8582 14.5812 15.2044L11.2096 17.2945C10.6669 17.6309 10 17.1931 10 16.5003L10 12.32C10 11.6273 10.6669 11.1894 11.2096 11.5258L14.5812 13.6159Z",
              stroke: "var(--color-active)",
              strokeWidth: "1.5"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2.38351 13.793C1.93748 10.6294 1.71447 9.04765 2.66232 8.02383C3.61017 7 5.29758 7 8.67239 7H15.3276C18.7024 7 20.3898 7 21.3377 8.02383C22.2855 9.04765 22.0625 10.6294 21.6165 13.793L21.1935 16.793C20.8437 19.2739 20.6689 20.5143 19.7717 21.2572C18.8745 22 17.5512 22 14.9046 22H9.09536C6.44881 22 5.12553 22 4.22834 21.2572C3.33115 20.5143 3.15626 19.2739 2.80648 16.793L2.38351 13.793Z",
              stroke: "var(--color-active)",
              strokeWidth: "1.5"
            }
          )
        ]
      }
    ),
    bulbIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "22",
        height: "22",
        viewBox: "0 0 21 21",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              cx: "10.5",
              cy: "10.4999",
              r: "10.5",
              transform: "rotate(-180 10.5 10.4999)",
              fill: "var(--color-active)"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fillRule: "evenodd",
              clipRule: "evenodd",
              d: "M10.4652 6.27779C12.6206 6.27779 14.3679 7.74623 14.3679 9.55763C14.3679 10.7275 13.6391 11.7544 12.5422 12.3349L12.2414 13.4904C12.174 13.75 11.9005 13.935 11.5843 13.935H9.34607C9.02989 13.935 8.75639 13.75 8.68895 13.4904L8.38889 12.3353C7.29163 11.7548 6.5625 10.7278 6.5625 9.55763C6.5625 7.74623 8.3098 6.27779 10.4652 6.27779Z",
              fill: "var(--color-active)"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fillRule: "evenodd",
              clipRule: "evenodd",
              d: "M9.51832 8.26292C9.45916 8.52634 9.12193 10.0102 9.05265 10.3128C8.98337 10.6153 9.28031 10.8866 9.57185 10.8866C9.86338 10.8866 9.90192 10.8866 10.0216 10.8866C10.1412 10.8866 10.3194 10.9572 10.2523 11.2145C10.1853 11.4717 10.1159 11.7364 10.0478 11.9863C9.97961 12.2363 10.3212 12.3371 10.4693 12.1422C10.6174 11.9474 11.7232 10.4599 11.8505 10.2599C11.9778 10.0599 11.7693 9.75055 11.4556 9.75055C11.1418 9.75055 11.012 9.75055 10.8474 9.75055C10.6829 9.75055 10.6598 9.65181 10.7195 9.4484C10.7792 9.24499 10.851 8.97892 10.9621 8.58898C11.0731 8.19904 10.6256 7.98723 10.3899 7.98723C10.1541 7.98723 9.90053 7.98723 9.83064 7.98723C9.76074 7.98723 9.57749 7.99949 9.51832 8.26292Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.47 14.2134H9.45766C9.22836 14.2134 9.04248 14.3696 9.04248 14.5623C9.04248 14.755 9.22836 14.9112 9.45766 14.9112H11.47C11.6993 14.9112 11.8852 14.755 11.8852 14.5623C11.8852 14.3696 11.6993 14.2134 11.47 14.2134Z",
              fill: "var(--color-active)"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.3002 15.1896H9.62807C9.39877 15.1896 9.21289 15.3458 9.21289 15.5385C9.21289 15.7312 9.39877 15.8874 9.62807 15.8874H11.3002C11.5295 15.8874 11.7154 15.7312 11.7154 15.5385C11.7154 15.3458 11.5295 15.1896 11.3002 15.1896Z",
              fill: "var(--color-active)"
            }
          )
        ]
      }
    ),
    checkIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "22",
        height: "22",
        viewBox: "0 0 12 12",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "6", cy: "6", r: "6", fill: "#21B761" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4.54235 7.81183L2.64582 5.91529L2 6.55657L4.54235 9.09892L10 3.64127L9.35873 3L4.54235 7.81183Z",
              fill: "white"
            }
          )
        ]
      }
    ),
    upFingerIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "60",
        height: "61",
        viewBox: "0 0 60 61",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fillRule: "evenodd",
              clipRule: "evenodd",
              d: "M30 57.1609C44.4774 57.1609 56.2136 45.4246 56.2136 30.9473C56.2136 16.4699 44.4774 4.73367 30 4.73367C15.5226 4.73367 3.78641 16.4699 3.78641 30.9473C3.78641 45.4246 15.5226 57.1609 30 57.1609ZM30 60.9473C46.5685 60.9473 60 47.5158 60 30.9473C60 14.3787 46.5685 0.947266 30 0.947266C13.4315 0.947266 0 14.3787 0 30.9473C0 47.5158 13.4315 60.9473 30 60.9473Z",
              fill: "#25BF6C"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M44.6194 27.7538C44.1733 27.2183 43.6152 26.7872 42.9843 26.491C42.3534 26.1948 41.6651 26.0406 40.9681 26.0394H33.7291L34.6181 23.7695C34.9878 22.7756 35.111 21.7069 34.9769 20.6549C34.8429 19.603 34.4556 18.5993 33.8484 17.7299C33.2412 16.8605 32.4321 16.1513 31.4906 15.6633C30.549 15.1753 29.5031 14.9229 28.4426 14.9278C28.1372 14.9284 27.8385 15.0171 27.5823 15.1832C27.3261 15.3494 27.1232 15.5859 26.998 15.8644L22.4736 26.0394H18.7429C17.4798 26.0394 16.2684 26.5412 15.3753 27.4342C14.4821 28.3273 13.9803 29.5386 13.9803 30.8016V41.9132C13.9803 43.1762 14.4821 44.3874 15.3753 45.2805C16.2684 46.1736 17.4798 46.6753 18.7429 46.6753H38.952C40.0661 46.6749 41.1449 46.284 42.0005 45.5705C42.8562 44.8571 43.4346 43.8662 43.6352 42.7704L45.6513 31.6587C45.776 30.972 45.7482 30.2663 45.5699 29.5915C45.3916 28.9167 45.0671 28.2893 44.6194 27.7538ZM21.9179 43.5006H18.7429C18.3219 43.5006 17.9181 43.3333 17.6204 43.0356C17.3226 42.7379 17.1554 42.3342 17.1554 41.9132V30.8016C17.1554 30.3806 17.3226 29.9768 17.6204 29.6791C17.9181 29.3814 18.3219 29.2142 18.7429 29.2142H21.9179V43.5006ZM42.5556 31.0873L40.5395 42.1989C40.4719 42.5687 40.2752 42.9025 39.9845 43.1409C39.6938 43.3792 39.3279 43.5067 38.952 43.5006H25.093V27.9602L29.411 18.2454C29.8555 18.375 30.2683 18.5953 30.6233 18.8924C30.9784 19.1895 31.268 19.557 31.4738 19.9717C31.6797 20.3863 31.7973 20.8392 31.8194 21.3016C31.8414 21.764 31.7673 22.226 31.6018 22.6583L30.7604 24.9283C30.5811 25.4081 30.5206 25.9241 30.584 26.4324C30.6474 26.9406 30.8328 27.426 31.1245 27.847C31.4161 28.2681 31.8053 28.6124 32.2589 28.8504C32.7124 29.0885 33.2168 29.2133 33.7291 29.2142H40.9681C41.2014 29.2138 41.4318 29.2648 41.6431 29.3636C41.8543 29.4623 42.0413 29.6064 42.1905 29.7856C42.3434 29.9623 42.4555 30.1706 42.5186 30.3957C42.5817 30.6207 42.5944 30.8568 42.5556 31.0873Z",
              fill: "#25BF6C"
            }
          )
        ]
      }
    ),
    downFingerIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "60",
        height: "61",
        viewBox: "0 0 60 61",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fillRule: "evenodd",
              clipRule: "evenodd",
              d: "M30 4.73367C15.5226 4.73367 3.7864 16.4699 3.7864 30.9473C3.7864 45.4246 15.5226 57.1609 30 57.1609C44.4774 57.1609 56.2136 45.4246 56.2136 30.9473C56.2136 16.4699 44.4774 4.73367 30 4.73367ZM30 0.947264C13.4314 0.947266 -7.88585e-06 14.3787 -6.43738e-06 30.9473C-4.98891e-06 47.5158 13.4315 60.9473 30 60.9473C46.5685 60.9473 60 47.5158 60 30.9473C60 14.3787 46.5685 0.947263 30 0.947264Z",
              fill: "#EB5757"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.3806 34.1407C15.8267 34.6762 16.3848 35.1073 17.0157 35.4035C17.6466 35.6998 18.3349 35.8539 19.0319 35.8551L26.2709 35.8551L25.3819 38.125C25.0122 39.1189 24.889 40.1877 25.0231 41.2396C25.1571 42.2915 25.5444 43.2952 26.1516 44.1646C26.7588 45.034 27.5679 45.7432 28.5094 46.2312C29.451 46.7193 30.4969 46.9717 31.5574 46.9667C31.8628 46.9661 32.1615 46.8774 32.4177 46.7113C32.6739 46.5452 32.8768 46.3087 33.002 46.0302L37.5264 35.8551L41.2571 35.8551C42.5202 35.8551 43.7316 35.3534 44.6247 34.4603C45.5179 33.5672 46.0197 32.356 46.0197 31.093L46.0197 19.9814C46.0197 18.7184 45.5179 17.5071 44.6247 16.614C43.7316 15.7209 42.5202 15.2192 41.2571 15.2192L21.048 15.2192C19.9339 15.2196 18.8551 15.6105 17.9995 16.324C17.1438 17.0375 16.5654 18.0283 16.3648 19.1242L14.3487 30.2358C14.224 30.9225 14.2518 31.6283 14.4301 32.3031C14.6084 32.9779 14.9329 33.6052 15.3806 34.1407ZM38.0821 18.394L41.2571 18.394C41.6781 18.394 42.0819 18.5612 42.3796 18.8589C42.6774 19.1566 42.8446 19.5604 42.8446 19.9814L42.8446 31.093C42.8446 31.514 42.6774 31.9177 42.3796 32.2154C42.0819 32.5131 41.6781 32.6804 41.2571 32.6804L38.0821 32.6804L38.0821 18.394ZM17.4444 30.8072L19.4605 19.6956C19.5281 19.3258 19.7248 18.992 20.0155 18.7537C20.3062 18.5153 20.6721 18.3878 21.048 18.394L34.907 18.394L34.907 33.9344L30.589 43.6491C30.1445 43.5195 29.7317 43.2992 29.3767 43.0021C29.0216 42.705 28.732 42.3375 28.5262 41.9229C28.3203 41.5082 28.2027 41.0554 28.1806 40.5929C28.1586 40.1305 28.2327 39.6686 28.3982 39.2362L29.2396 36.9663C29.4189 36.4865 29.4794 35.9704 29.416 35.4622C29.3526 34.9539 29.1672 34.4686 28.8755 34.0475C28.5839 33.6264 28.1947 33.2822 27.7411 33.0441C27.2876 32.8061 26.7832 32.6812 26.2709 32.6804L19.0319 32.6804C18.7986 32.6807 18.5682 32.6297 18.3569 32.531C18.1457 32.4322 17.9587 32.2881 17.8095 32.1089C17.6566 31.9322 17.5445 31.7239 17.4814 31.4989C17.4183 31.2739 17.4056 31.0377 17.4444 30.8072Z",
              fill: "#EB5757"
            }
          )
        ]
      }
    ),
    brainIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "14",
        height: "15",
        viewBox: "0 0 14 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M2.20721 2.88103C2.21706 1.63347 2.75193 0.740647 3.90426 0.280591C4.98221 -0.149995 5.90811 0.158346 7.0063 1.26073C7.83158 0.227655 8.87835 -0.187105 10.1417 0.304604C11.2732 0.745013 11.7846 1.65476 11.7912 2.87175C11.8623 2.89412 11.9366 2.9225 12.0138 2.9416C13.7786 3.38365 14.5618 5.3865 13.556 6.90092C13.4636 7.04008 13.4455 7.12849 13.5456 7.27912C14.5651 8.81154 13.7885 10.8024 12.0028 11.2532C11.9328 11.2706 11.8644 11.2946 11.7939 11.3159C11.7813 12.5924 11.2262 13.5278 10.0039 13.9382C8.78975 14.3459 7.79329 13.9224 7.00356 12.9231C6.16078 13.9726 5.10088 14.3901 3.82003 13.8711C2.70435 13.4192 2.20995 12.51 2.20831 11.3148C2.12846 11.2925 2.0508 11.2685 1.97205 11.2483C0.22414 10.8046 -0.555745 8.80609 0.435792 7.30204C0.521656 7.17161 0.570877 7.08538 0.46259 6.92384C-0.569965 5.37559 0.204451 3.39293 2.00978 2.93615C2.07103 2.92086 2.13174 2.90176 2.20667 2.88103H2.20721ZM6.58846 7.1023C6.58846 6.4747 6.5901 5.84765 6.58846 5.22005C6.58518 4.32013 6.61307 3.41858 6.56495 2.52084C6.51463 1.58163 5.66912 0.888542 4.71368 0.932201C3.80144 0.974222 3.05601 1.74644 3.03632 2.66164C3.03249 2.83355 3.08007 2.91595 3.26383 2.95961C3.71558 3.06658 4.10935 3.2936 4.43147 3.63032C4.59172 3.79786 4.59883 3.99487 4.4539 4.17333C4.31553 4.3436 4.13013 4.36652 3.93817 4.26174C3.86761 4.22299 3.81074 4.16078 3.74784 4.10839C3.01226 3.4988 1.95072 3.55938 1.30154 4.24919C0.652366 4.93845 0.661663 5.99991 1.32342 6.693C1.6439 7.02862 1.63679 7.15687 1.31412 7.5116C0.848704 8.0235 0.698306 8.61781 0.912145 9.28033C1.30865 10.5099 2.78967 10.8946 3.80089 10.0378C4.04426 9.83153 4.28381 9.82007 4.44952 10.0073C4.61414 10.1928 4.59664 10.4695 4.33905 10.6425C3.99668 10.8722 3.62479 11.0654 3.24633 11.2319C3.09156 11.3001 3.03577 11.3601 3.03687 11.5189C3.04507 12.4401 3.80527 13.2255 4.72954 13.2615C5.77795 13.3019 6.5819 12.5089 6.58682 11.412C6.59393 9.9756 6.58846 8.53868 6.58846 7.1023ZM7.42632 6.66025C7.48648 6.67226 7.51273 6.68208 7.53898 6.68263C8.07659 6.68481 8.6142 6.67935 9.1518 6.69027C9.31806 6.69354 9.40775 6.6417 9.49143 6.49271C9.7884 5.96717 10.39 5.74669 10.9467 5.9366C11.4707 6.11506 11.8054 6.60295 11.7797 7.15087C11.7551 7.68678 11.3815 8.15284 10.8713 8.28545C10.3397 8.42353 9.79551 8.19923 9.49963 7.73044C9.44658 7.6464 9.36181 7.52197 9.28908 7.51979C8.67326 7.50287 8.0569 7.50996 7.43015 7.50996V9.41568C7.64727 9.41568 7.84634 9.40421 8.04323 9.41895C8.22097 9.43205 8.31559 9.3682 8.40473 9.21048C8.69623 8.69639 9.28907 8.47974 9.83926 8.66038C10.3637 8.83228 10.705 9.31853 10.6859 9.86591C10.6673 10.4024 10.3014 10.869 9.78949 11.0098C9.26118 11.1549 8.70881 10.9356 8.41184 10.4706C8.35715 10.3854 8.28277 10.2588 8.2073 10.2507C7.95025 10.2228 7.68883 10.2403 7.41429 10.2403C7.41429 10.7123 7.39624 11.1397 7.41812 11.5648C7.47171 12.6028 8.35715 13.363 9.36728 13.2571C10.4031 13.148 11.1097 12.1962 10.9309 11.1506C10.8478 10.666 10.9577 10.5317 11.4532 10.5033C12.2194 10.4591 12.7707 10.0837 13.0507 9.37693C13.3318 8.66692 13.1688 8.02023 12.6427 7.46794C12.3725 7.1847 12.372 7.01007 12.6421 6.72738C13.1688 6.17509 13.3329 5.52839 13.0512 4.81894C12.7668 4.10075 12.2052 3.72746 11.4269 3.69035C10.9724 3.66852 10.8434 3.51026 10.926 3.07258C11.1086 2.10117 10.5262 1.19361 9.58331 0.97968C8.64428 0.766842 7.68446 1.31258 7.48648 2.25561C7.37272 2.79535 7.41484 3.36782 7.3853 3.95886C7.64782 3.95886 7.84689 3.9474 8.04377 3.96213C8.22152 3.97523 8.31613 3.91138 8.40528 3.75366C8.69678 3.23957 9.28962 3.02292 9.83981 3.20356C10.3643 3.37601 10.7056 3.86171 10.6864 4.40909C10.6678 4.94555 10.3019 5.41215 9.79004 5.55295C9.26173 5.69812 8.70936 5.47873 8.41294 5.01376C8.35824 4.92863 8.28387 4.80202 8.20839 4.79383C7.95135 4.766 7.68993 4.78346 7.42577 4.78346V6.66189L7.42632 6.66025ZM9.86387 4.37798C9.86934 4.15696 9.70417 3.97796 9.48432 3.96595C9.25189 3.9534 9.0632 4.12694 9.05774 4.35834C9.05227 4.57936 9.21798 4.75836 9.43729 4.77037C9.66917 4.78292 9.8584 4.60883 9.86387 4.37798ZM10.9577 7.10939C10.9642 6.88837 10.8007 6.70828 10.5809 6.69518C10.349 6.68099 10.1587 6.85399 10.1515 7.08429C10.145 7.30531 10.3085 7.48541 10.5284 7.4985C10.7602 7.51269 10.9506 7.33969 10.9577 7.10939ZM9.86387 9.83808C9.87043 9.61705 9.70691 9.43696 9.48705 9.42386C9.25517 9.40967 9.06485 9.58267 9.05774 9.81297C9.05117 10.034 9.21524 10.2141 9.4351 10.2272C9.66699 10.2414 9.85731 10.0689 9.86442 9.83808H9.86387Z",
            fill: "var(--color-active)"
          }
        )
      }
    ),
    toolIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "30",
        height: "31",
        viewBox: "0 0 30 31",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M15.312 9.3402C13.9866 8.019 12.0018 7.7495 10.406 8.52513L12.7997 10.9112C13.0568 11.1675 13.0568 11.5816 12.7997 11.838L11.7512 12.8831C11.494 13.1461 11.0786 13.1461 10.8214 12.8831L8.42781 10.4971C7.65631 12.0944 7.92666 14.0597 9.25207 15.3809C10.4786 16.6035 12.2721 16.9256 13.7954 16.3538L19.0442 21.586C19.7234 22.263 20.818 22.263 21.4906 21.586C22.1698 20.9089 22.1698 19.8178 21.4906 19.1473L16.2681 13.9348C16.8748 12.3967 16.5583 10.5825 15.312 9.3402Z",
            stroke: "#02A9EA"
          }
        )
      }
    ),
    testIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "14",
        height: "15",
        viewBox: "0 0 14 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.6956 12.3322C12.048 12.6711 12.3558 12.9407 12.6281 13.2439C12.7213 13.3474 12.7929 13.5666 12.7469 13.6789C12.7016 13.7891 12.4969 13.8886 12.3597 13.8913C11.4199 13.9095 10.4801 13.9041 9.53967 13.8994C9.1984 13.8974 9.09733 13.7871 9.09602 13.4281C9.09274 12.4761 9.08486 11.5241 9.10521 10.5728C9.10849 10.4248 9.21743 10.2164 9.33622 10.1546C9.43204 10.1048 9.65189 10.1956 9.75427 10.2931C10.0896 10.6111 10.3974 10.9607 10.7466 11.3318C10.9474 11.114 11.1246 10.9378 11.2834 10.7455C13.8902 7.58159 12.4011 2.67161 8.50471 1.57706C8.44171 1.55958 8.3787 1.54009 8.3157 1.52261C7.84318 1.38881 7.61151 1.02979 7.72373 0.604886C7.82808 0.210233 8.21594 0.00719182 8.67206 0.128882C10.6455 0.656656 12.1458 1.82851 13.1335 3.65387C14.6265 6.41241 14.1533 9.83857 11.9948 12.0875C11.9259 12.1588 11.8412 12.2139 11.6956 12.3329V12.3322Z",
              fill: "var(--color-active)"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M2.29384 1.85934C1.94798 1.52519 1.64675 1.26366 1.38489 0.965818C1.28514 0.852196 1.19851 0.622935 1.24642 0.507295C1.29367 0.393 1.51681 0.29753 1.66513 0.294841C2.58261 0.276016 3.50141 0.282737 4.41954 0.286771C4.80216 0.288116 4.89469 0.389639 4.89601 0.793033C4.89797 1.72218 4.90782 2.652 4.88616 3.58116C4.88222 3.73982 4.77656 3.96371 4.65252 4.03027C4.55671 4.08204 4.32373 3.97312 4.21347 3.86824C3.88599 3.55763 3.58869 3.21407 3.2402 2.8416C2.98229 3.13944 2.74471 3.38148 2.54323 3.65242C0.162239 6.8426 1.68088 11.5031 5.45581 12.6031C5.58182 12.64 5.71177 12.6649 5.83318 12.7133C6.17773 12.8511 6.35098 13.1887 6.2742 13.551C6.20332 13.8845 5.89749 14.1434 5.54573 14.0855C5.1828 14.0257 4.82119 13.9181 4.47795 13.7823C-0.227592 11.9193 -1.5185 5.75747 2.02149 2.07515C2.08252 2.01195 2.15996 1.96489 2.2945 1.86001L2.29384 1.85934Z",
              fill: "var(--color-active)"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5.98737 8.35901C6.10222 8.2474 6.19082 8.16672 6.27417 8.08067C7.28025 7.05134 8.28501 6.02067 9.29044 4.99067C9.36788 4.91134 9.44204 4.82797 9.52867 4.76006C9.83056 4.52341 10.2243 4.55904 10.4763 4.84007C10.7238 5.11505 10.7375 5.4929 10.4868 5.78468C10.2847 6.02 10.0596 6.23447 9.84369 6.45633C8.76148 7.56567 7.67927 8.67634 6.59509 9.78366C6.18491 10.2025 5.82133 10.1992 5.40722 9.77761C4.81 9.16916 4.21409 8.56003 3.62082 7.94755C3.2592 7.57441 3.22705 7.16631 3.525 6.85233C3.83214 6.52827 4.23903 6.5592 4.61705 6.94511C5.07251 7.40902 5.52207 7.87897 5.98803 8.35968L5.98737 8.35901Z",
              fill: "var(--color-active)"
            }
          )
        ]
      }
    ),
    feedbackIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "14",
        height: "21",
        viewBox: "0 0 14 21",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M7 0.923828C3.14173 0.923828 -0.00190822 4.06492 8.69065e-07 7.92383C0.0012736 10.0047 0.955819 11.9488 2.54546 13.2718V15.5602C2.54546 16.607 3.40773 17.4693 4.45455 17.4693H9.54545C10.5923 17.4693 11.4545 16.607 11.4545 15.5602V13.2744C13.0448 11.9507 13.9994 10.0054 14 7.92383C14.0019 4.06492 10.8583 0.923828 7 0.923828ZM7 2.19656C7.75249 2.19521 8.49785 2.34244 9.19332 2.62979C9.88879 2.91713 10.5207 3.33895 11.0528 3.87104C11.5849 4.40314 12.0067 5.03504 12.294 5.73051C12.5814 6.42598 12.7286 7.17133 12.7273 7.92383C12.7256 8.77988 12.5316 9.62461 12.1596 10.3956C11.7877 11.1666 11.2473 11.8442 10.5783 12.3784H7C6.13964 12.3663 6.13964 13.6626 7 13.6511H10.1818V15.5602C10.1818 15.9236 9.90882 16.1966 9.54545 16.1966H4.45455C4.09118 16.1966 3.81818 15.9236 3.81818 15.5602V13.6511H4.45455C5.31491 13.6632 5.31491 12.3669 4.45455 12.3784H3.42555C2.75573 11.8447 2.21447 11.1673 1.84182 10.3963C1.46918 9.62521 1.27468 8.78022 1.27273 7.92383C1.27139 7.17133 1.41861 6.42598 1.70596 5.73051C1.99331 5.03504 2.41512 4.40314 2.94722 3.87104C3.47931 3.33895 4.11121 2.91713 4.80668 2.62979C5.50215 2.34244 6.24751 2.19521 7 2.19656ZM6.97009 4.73565C6.85628 4.74118 6.74605 4.77717 6.6509 4.83986C6.55575 4.90254 6.47918 4.98962 6.42918 5.09201L5.15645 7.63937C5.10784 7.73666 5.08497 7.84478 5.09002 7.95342C5.09508 8.06205 5.12789 8.16758 5.18533 8.25993C5.24277 8.35228 5.32292 8.42837 5.41813 8.48093C5.51334 8.5335 5.62043 8.56079 5.72918 8.56019H7.24245L6.42982 10.1848C6.36167 10.3351 6.35445 10.506 6.40967 10.6615C6.46488 10.817 6.57823 10.945 6.7259 11.0187C6.87356 11.0924 7.04404 11.1059 7.20149 11.0565C7.35893 11.0071 7.49109 10.8986 7.57018 10.7537L8.84418 8.20701C8.89285 8.10963 8.91572 8.00139 8.9106 7.89265C8.90549 7.7839 8.87256 7.67829 8.81498 7.5859C8.75739 7.49352 8.67706 7.41745 8.58168 7.36498C8.48629 7.3125 8.37904 7.28538 8.27018 7.28619H6.75818L7.57082 5.66155C7.62189 5.56199 7.64581 5.45072 7.64016 5.33896C7.6345 5.2272 7.59948 5.11891 7.53862 5.02501C7.47776 4.9311 7.39321 4.85491 7.29351 4.8041C7.19381 4.7533 7.08247 4.72969 6.97073 4.73565H6.97009ZM5.66618 18.7433C5.66533 18.7437 5.66448 18.7441 5.66364 18.7446C5.49914 18.7591 5.34668 18.8368 5.23835 18.9615C5.13003 19.0861 5.07429 19.2479 5.08287 19.4128C5.09144 19.5778 5.16366 19.7329 5.28433 19.8456C5.405 19.9584 5.5647 20.0199 5.72982 20.0173H8.27018C8.43896 20.0173 8.60082 19.9502 8.72016 19.8309C8.8395 19.7116 8.90655 19.5497 8.90655 19.3809C8.90655 19.2121 8.8395 19.0503 8.72016 18.9309C8.60082 18.8116 8.43896 18.7446 8.27018 18.7446H5.72982C5.70864 18.7431 5.6874 18.7426 5.66618 18.7433Z",
            fill: "var(--color-active)"
          }
        )
      }
    ),
    resetIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "15",
        height: "16",
        viewBox: "0 0 15 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("mask", { id: "path-1-inside-1_828_425", fill: "white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.4437 7.42417C12.9699 7.42417 12.6541 7.74 12.6541 8.21376C12.6541 11.2932 10.2064 13.7409 7.12698 13.7409H6.57427C6.41635 13.7409 6.33739 13.7409 6.17947 13.6619C6.02156 13.6619 5.9426 13.583 5.78468 13.583C5.70572 13.583 5.62676 13.504 5.5478 13.504C4.99509 13.3461 4.44238 13.0303 3.96862 12.7144C3.88967 12.6355 3.81071 12.6355 3.81071 12.5565C3.73175 12.4775 3.65279 12.3986 3.57383 12.3986C3.41591 12.3196 3.25799 12.1617 3.17903 12.0827L3.02112 11.9248L4.44238 11.688C4.83717 11.609 5.15301 11.2142 5.07405 10.7404C4.99509 10.3456 4.6003 10.0298 4.12654 10.1088L1.5209 10.5825L0.889226 10.7404C0.65235 10.7404 0.494432 10.8984 0.415473 11.0563C0.336514 11.2142 0.257555 11.4511 0.257555 11.609L0.889226 14.9253C0.968185 15.3201 1.28402 15.5569 1.67882 15.5569H1.83673C2.23153 15.478 2.54736 15.0832 2.4684 14.6094L2.23153 13.2671C2.38945 13.425 2.62632 13.583 2.78424 13.7409H2.8632C2.94216 13.8198 3.02112 13.8988 3.10008 13.8988C3.25799 14.0567 3.41591 14.1357 3.65279 14.2146C3.81071 14.5305 4.04758 14.6094 4.28446 14.7673H4.36342C4.44238 14.8463 4.6003 14.8463 4.75821 14.9253C5.07405 15.0042 5.38988 15.0832 5.62676 15.1621C5.78468 15.1621 5.9426 15.2411 6.10052 15.2411H7.04802C10.996 15.2411 14.1543 12.0827 14.1543 8.1348C14.2333 7.74 13.8385 7.42417 13.4437 7.42417ZM0.889226 9.00335C1.36298 9.00335 1.67882 8.68751 1.67882 8.21376C1.67882 5.13436 4.12654 2.68663 7.20594 2.68663H7.75865C7.91657 2.68663 7.99553 2.68663 8.15345 2.76559C8.31136 2.76559 8.39032 2.84455 8.54824 2.84455C8.6272 2.84455 8.70616 2.92351 8.78512 2.92351C9.33783 3.08143 9.89054 3.31831 10.3643 3.7131C10.4433 3.79206 10.5222 3.79206 10.6012 3.87102C10.6801 3.94998 10.7591 3.94998 10.838 4.02893C10.917 4.10789 10.996 4.26581 11.1539 4.34477L11.3118 4.50269L9.89054 4.73957C9.49575 4.81852 9.17991 5.21332 9.25887 5.68707C9.33783 6.08187 9.65367 6.31874 10.0485 6.31874H10.2064L13.5227 5.68707C13.9174 5.60811 14.2333 5.21332 14.1543 4.73957L13.5227 1.50225C13.4437 1.10746 13.0489 0.79162 12.5751 0.870579C12.1804 0.949538 11.8645 1.34433 11.9435 1.81809L12.1804 3.16039C12.0224 3.00247 11.7856 2.76559 11.6276 2.68663H11.5487C11.4697 2.60767 11.3908 2.52872 11.3118 2.52872C11.1539 2.3708 10.996 2.29184 10.7591 2.13392C10.5222 1.976 10.2853 1.89704 10.0485 1.73913H9.9695C9.89054 1.66017 9.73263 1.66017 9.57471 1.58121C9.25887 1.50225 8.94304 1.42329 8.70616 1.34433C8.54824 1.34433 8.39032 1.26537 8.23241 1.26537H7.2849C3.33695 1.26537 0.178596 4.42373 0.178596 8.37168C0.099637 8.68751 0.415473 9.00335 0.889226 9.00335Z" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M6.17947 13.6619L6.62669 12.7675L6.41554 12.6619H6.17947V13.6619ZM5.5478 13.504L5.27308 14.4655L5.40775 14.504H5.5478V13.504ZM3.96862 12.7144L3.26152 13.4215L3.33153 13.4915L3.41392 13.5465L3.96862 12.7144ZM3.81071 12.5565H4.81071V12.1423L4.51781 11.8494L3.81071 12.5565ZM3.57383 12.3986L3.12662 13.293L3.33776 13.3986H3.57383V12.3986ZM3.17903 12.0827L3.88614 11.3756L3.88614 11.3756L3.17903 12.0827ZM3.02112 11.9248L2.85672 10.9384L0.93996 11.2579L2.31401 12.6319L3.02112 11.9248ZM4.44238 11.688L4.60678 12.6743L4.62268 12.6717L4.63849 12.6685L4.44238 11.688ZM5.07405 10.7404L6.06044 10.576L6.05779 10.5601L6.05463 10.5443L5.07405 10.7404ZM4.12654 10.1088L3.96214 9.12238L3.95489 9.12359L3.94766 9.1249L4.12654 10.1088ZM1.5209 10.5825L1.34201 9.59866L1.30996 9.60448L1.27836 9.61238L1.5209 10.5825ZM0.889226 10.7404V11.7404H1.01233L1.13176 11.7106L0.889226 10.7404ZM0.257555 11.609H-0.742445V11.7034L-0.724784 11.7961L0.257555 11.609ZM0.889226 14.9253L-0.0931537 15.1124L-0.0913544 15.1214L0.889226 14.9253ZM1.83673 15.5569V16.5569H1.93575L2.03285 16.5375L1.83673 15.5569ZM2.4684 14.6094L3.45484 14.445L3.45319 14.4356L2.4684 14.6094ZM2.23153 13.2671L2.93863 12.56L0.695433 10.3168L1.24674 13.4409L2.23153 13.2671ZM2.78424 13.7409L2.07713 14.448L2.37003 14.7409H2.78424V13.7409ZM2.8632 13.7409L3.57031 13.0338L3.27741 12.7409H2.8632V13.7409ZM3.10008 13.8988L3.80718 13.1917L3.51429 12.8988H3.10008V13.8988ZM3.65279 14.2146L4.54722 13.7674L4.36197 13.3969L3.96902 13.266L3.65279 14.2146ZM4.28446 14.7673L3.72976 15.5994L3.98168 15.7673H4.28446V14.7673ZM4.36342 14.7673L5.07053 14.0602L4.77763 13.7673H4.36342V14.7673ZM4.75821 14.9253L4.311 15.8197L4.40918 15.8688L4.51568 15.8954L4.75821 14.9253ZM5.62676 15.1621L5.31053 16.1108L5.46448 16.1621H5.62676V15.1621ZM14.1543 8.1348L13.1737 7.93868L13.1543 8.03578V8.1348H14.1543ZM8.15345 2.76559L7.70623 3.66002L7.91738 3.76559H8.15345V2.76559ZM8.78512 2.92351L9.05984 1.96199L8.92517 1.92351H8.78512V2.92351ZM10.3643 3.7131L11.0714 3.00599L11.0393 2.97392L11.0045 2.94488L10.3643 3.7131ZM11.1539 4.34477L11.861 3.63766L11.7462 3.52292L11.6011 3.45034L11.1539 4.34477ZM11.3118 4.50269L11.4762 5.48908L13.393 5.16962L12.0189 3.79558L11.3118 4.50269ZM9.89054 4.73957L9.72614 3.75317L9.71024 3.75582L9.69443 3.75898L9.89054 4.73957ZM9.25887 5.68707L8.27248 5.85147L8.27513 5.86738L8.27829 5.88319L9.25887 5.68707ZM10.2064 6.31874V7.31874H10.3008L10.3935 7.30108L10.2064 6.31874ZM13.5227 5.68707L13.7098 6.66945L13.7188 6.66765L13.5227 5.68707ZM14.1543 4.73957L15.1407 4.57517L15.1385 4.56158L15.1358 4.54806L14.1543 4.73957ZM13.5227 1.50225L14.5042 1.31074L14.5032 1.30613L13.5227 1.50225ZM12.5751 0.870579L12.4107 -0.115815L12.3948 -0.113164L12.379 -0.110002L12.5751 0.870579ZM11.9435 1.81809L10.957 1.98249L10.9587 1.99187L11.9435 1.81809ZM12.1804 3.16039L11.4732 3.86749L13.7164 6.11069L13.1651 2.9866L12.1804 3.16039ZM11.6276 2.68663L12.0749 1.79221L11.8637 1.68663H11.6276V2.68663ZM11.5487 2.68663L10.8416 3.39374L11.1345 3.68663H11.5487V2.68663ZM11.3118 2.52872L10.6047 3.23582L10.8976 3.52872H11.3118V2.52872ZM10.0485 1.73913L10.6032 0.907076L10.3512 0.739127H10.0485V1.73913ZM9.9695 1.73913L9.26239 2.44623L9.55529 2.73913H9.9695V1.73913ZM9.57471 1.58121L10.0219 0.686782L9.92374 0.63769L9.81724 0.611066L9.57471 1.58121ZM8.70616 1.34433L9.02239 0.395649L8.86844 0.344332H8.70616V1.34433ZM0.178596 8.37168L1.14874 8.61421L1.1786 8.49478V8.37168H0.178596ZM13.4437 6.42417C12.9796 6.42417 12.5151 6.58324 12.1641 6.9342C11.8132 7.28516 11.6541 7.74963 11.6541 8.21376H13.6541C13.6541 8.20413 13.653 8.27381 13.5783 8.34841C13.5037 8.42301 13.4341 8.42417 13.4437 8.42417V6.42417ZM11.6541 8.21376C11.6541 10.7409 9.65409 12.7409 7.12698 12.7409V14.7409C10.7587 14.7409 13.6541 11.8454 13.6541 8.21376H11.6541ZM7.12698 12.7409H6.57427V14.7409H7.12698V12.7409ZM6.57427 12.7409C6.55356 12.7409 6.5396 12.7409 6.52721 12.7408C6.51532 12.7407 6.5093 12.7405 6.5066 12.7404C6.50201 12.7402 6.51683 12.7405 6.54127 12.7446C6.55348 12.7467 6.56632 12.7493 6.57934 12.7526C6.59229 12.7559 6.60352 12.7594 6.61269 12.7626C6.63063 12.7688 6.63676 12.7725 6.62669 12.7675L5.73226 14.5563C5.87623 14.6283 6.03143 14.6872 6.21247 14.7174C6.36872 14.7434 6.51499 14.7409 6.57427 14.7409V12.7409ZM6.17947 12.6619C6.2789 12.6619 6.35713 12.6934 6.29831 12.6738C6.23869 12.6539 6.04202 12.583 5.78468 12.583V14.583C5.68525 14.583 5.60702 14.5515 5.66585 14.5711C5.72546 14.591 5.92213 14.6619 6.17947 14.6619V12.6619ZM5.78468 12.583C5.92875 12.583 6.0342 12.6184 6.07658 12.6343C6.09981 12.643 6.11573 12.6504 6.12028 12.6525C6.12381 12.6542 6.12531 12.655 6.11345 12.6491C6.10557 12.6451 6.08433 12.6344 6.06106 12.6235C6.03677 12.6121 6.00111 12.5961 5.95814 12.58C5.87628 12.5493 5.73135 12.504 5.5478 12.504V14.504C5.40373 14.504 5.29828 14.4686 5.2559 14.4527C5.23267 14.444 5.21675 14.4366 5.2122 14.4345C5.20867 14.4328 5.20717 14.432 5.21903 14.4379C5.22691 14.4419 5.24815 14.4525 5.27142 14.4634C5.29571 14.4748 5.33137 14.4908 5.37434 14.507C5.4562 14.5377 5.60113 14.583 5.78468 14.583V12.583ZM5.82252 12.5425C5.41941 12.4273 4.96909 12.1795 4.52332 11.8824L3.41392 13.5465C3.91566 13.881 4.57077 14.2649 5.27308 14.4655L5.82252 12.5425ZM4.67573 12.0073C4.59562 11.9272 4.51956 11.8716 4.46534 11.8355C4.44026 11.8188 4.41812 11.8051 4.40978 11.8C4.39625 11.7916 4.40474 11.7967 4.41476 11.8034C4.42936 11.8131 4.54319 11.8866 4.64351 12.0299C4.69759 12.1072 4.74239 12.1964 4.77208 12.2954C4.80126 12.3926 4.81071 12.4821 4.81071 12.5565H2.81071C2.81071 12.7615 2.86785 12.9808 3.00504 13.1768C3.12263 13.3448 3.26115 13.438 3.30535 13.4675C3.44482 13.5605 3.31539 13.4754 3.26152 13.4215L4.67573 12.0073ZM4.51781 11.8494C4.49141 11.823 4.39971 11.7285 4.29227 11.6479C4.19534 11.5752 3.93961 11.3986 3.57383 11.3986V13.3986C3.42478 13.3986 3.30719 13.3611 3.23223 13.3283C3.15953 13.2965 3.11174 13.2625 3.09227 13.2479C3.07169 13.2325 3.062 13.2228 3.06754 13.228C3.07347 13.2336 3.08169 13.2417 3.1036 13.2636L4.51781 11.8494ZM4.02104 11.5042C4.03892 11.5131 4.04391 11.5176 4.03537 11.5115C4.02776 11.5061 4.0151 11.4964 3.99761 11.4814C3.96089 11.4499 3.92599 11.4155 3.88614 11.3756L2.47193 12.7899C2.52585 12.8438 2.79739 13.1284 3.12662 13.293L4.02104 11.5042ZM3.88614 11.3756L3.72822 11.2177L2.31401 12.6319L2.47193 12.7899L3.88614 11.3756ZM3.18552 12.9112L4.60678 12.6743L4.27798 10.7016L2.85672 10.9384L3.18552 12.9112ZM4.63849 12.6685C5.54326 12.4876 6.23133 11.6014 6.06044 10.576L4.08766 10.9048C4.08236 10.8731 4.09082 10.8253 4.1189 10.7856C4.14154 10.7535 4.18172 10.7203 4.24626 10.7074L4.63849 12.6685ZM6.05463 10.5443C5.87368 9.63956 4.98747 8.95149 3.96214 9.12238L4.29094 11.0952C4.25918 11.1005 4.21145 11.092 4.17166 11.0639C4.13959 11.0413 4.10638 11.0011 4.09347 10.9366L6.05463 10.5443ZM3.94766 9.1249L1.34201 9.59866L1.69978 11.5664L4.30543 11.0926L3.94766 9.1249ZM1.27836 9.61238L0.646691 9.7703L1.13176 11.7106L1.76343 11.5527L1.27836 9.61238ZM0.889226 9.74044C0.14306 9.74044 -0.298139 10.2474 -0.478954 10.6091L1.3099 11.5035C1.29321 11.5369 1.26009 11.5889 1.19313 11.6391C1.11615 11.6969 1.00766 11.7404 0.889226 11.7404V9.74044ZM-0.478954 10.6091C-0.586213 10.8236 -0.742445 11.2245 -0.742445 11.609H1.25756C1.25756 11.6301 1.25628 11.6447 1.25557 11.6514C1.25482 11.6585 1.25423 11.6613 1.25458 11.6594C1.25542 11.6548 1.25831 11.6414 1.26473 11.62C1.27096 11.5992 1.27885 11.5765 1.28764 11.5542C1.29654 11.5317 1.30453 11.5142 1.3099 11.5035L-0.478954 10.6091ZM-0.724784 11.7961L-0.0931123 15.1124L1.87156 14.7382L1.23989 11.4219L-0.724784 11.7961ZM-0.0913544 15.1214C0.0880102 16.0182 0.843533 16.5569 1.67882 16.5569V14.5569C1.68309 14.5569 1.72856 14.5597 1.7834 14.6028C1.84184 14.6487 1.86491 14.7047 1.86981 14.7291L-0.0913544 15.1214ZM1.67882 16.5569H1.83673V14.5569H1.67882V16.5569ZM2.03285 16.5375C2.93761 16.3566 3.62569 15.4704 3.4548 14.445L1.48201 14.7738C1.47672 14.7421 1.48517 14.6943 1.51326 14.6545C1.5359 14.6225 1.57607 14.5893 1.64062 14.5764L2.03285 16.5375ZM3.45319 14.4356L3.21631 13.0933L1.24674 13.4409L1.48362 14.7832L3.45319 14.4356ZM1.52442 13.9742C1.6502 14.1 1.79571 14.2149 1.88319 14.2849C1.99311 14.3728 2.04499 14.4158 2.07713 14.448L3.49135 13.0338C3.36557 12.908 3.22005 12.7931 3.13258 12.7231C3.02266 12.6352 2.97078 12.5922 2.93863 12.56L1.52442 13.9742ZM2.78424 14.7409H2.8632V12.7409H2.78424V14.7409ZM2.15609 14.448C2.1825 14.4744 2.27419 14.5689 2.38164 14.6494C2.47856 14.7221 2.7343 14.8988 3.10008 14.8988V12.8988C3.24913 12.8988 3.36671 12.9363 3.44168 12.9691C3.51438 13.0009 3.56217 13.0348 3.58164 13.0495C3.60222 13.0649 3.61191 13.0745 3.60636 13.0693C3.60043 13.0638 3.59221 13.0557 3.57031 13.0338L2.15609 14.448ZM2.39297 14.6059C2.70124 14.9142 3.01873 15.0574 3.33656 15.1633L3.96902 13.266C3.87897 13.2359 3.84511 13.2192 3.83246 13.2122C3.82733 13.2093 3.8251 13.2077 3.82361 13.2066C3.82195 13.2053 3.81676 13.2013 3.80718 13.1917L2.39297 14.6059ZM2.75836 14.6618C3.07263 15.2904 3.70025 15.5797 3.72976 15.5994L4.83916 13.9353C4.75339 13.8781 4.66663 13.8275 4.61984 13.7997C4.56324 13.766 4.54113 13.7516 4.52718 13.7415C4.51763 13.7345 4.52318 13.7375 4.53314 13.7487C4.54385 13.7608 4.54826 13.7695 4.54722 13.7674L2.75836 14.6618ZM4.28446 15.7673H4.36342V13.7673H4.28446V15.7673ZM3.65631 15.4745C3.79407 15.6122 3.93941 15.6887 4.03748 15.7313C4.13129 15.7721 4.21854 15.797 4.25648 15.8078C4.36601 15.8391 4.33551 15.8319 4.311 15.8197L5.20543 14.0308C5.10673 13.9815 5.01674 13.9488 4.94801 13.9267C4.91381 13.9156 4.88303 13.9066 4.85944 13.8999C4.84774 13.8966 4.83654 13.8934 4.82788 13.891C4.81849 13.8883 4.81197 13.8865 4.80593 13.8848C4.79344 13.8812 4.79178 13.8806 4.79486 13.8816C4.79816 13.8827 4.81318 13.8877 4.83494 13.8972C4.87626 13.9151 4.97225 13.962 5.07053 14.0602L3.65631 15.4745ZM4.51568 15.8954C4.84488 15.9777 5.11821 16.0467 5.31053 16.1108L5.94299 14.2135C5.66156 14.1196 5.30322 14.0307 5.00075 13.9551L4.51568 15.8954ZM5.62676 16.1621C5.60496 16.1621 5.58804 16.1608 5.57725 16.1596C5.57181 16.159 5.56766 16.1584 5.56498 16.158C5.56363 16.1578 5.56261 16.1576 5.56194 16.1575C5.56127 16.1574 5.56092 16.1574 5.56091 16.1574C5.56091 16.1574 5.56121 16.1574 5.56186 16.1575C5.56251 16.1577 5.56347 16.1579 5.56476 16.1581C5.56739 16.1587 5.5711 16.1595 5.57623 16.1607C5.58758 16.1634 5.60015 16.1665 5.6211 16.1718C5.65546 16.1804 5.72401 16.1978 5.79779 16.2116C5.87475 16.2261 5.97933 16.2411 6.10052 16.2411V14.2411C6.12231 14.2411 6.13924 14.2425 6.15002 14.2436C6.15547 14.2442 6.15962 14.2448 6.16229 14.2452C6.16364 14.2454 6.16467 14.2456 6.16534 14.2457C6.16601 14.2458 6.16636 14.2459 6.16637 14.2459C6.16637 14.2459 6.16606 14.2458 6.16541 14.2457C6.16476 14.2456 6.16381 14.2454 6.16252 14.2451C6.15988 14.2445 6.15618 14.2437 6.15105 14.2425C6.1397 14.2398 6.12713 14.2367 6.10617 14.2315C6.07181 14.2229 6.00326 14.2054 5.92949 14.1916C5.85253 14.1772 5.74794 14.1621 5.62676 14.1621V16.1621ZM6.10052 16.2411H7.04802V14.2411H6.10052V16.2411ZM7.04802 16.2411C11.5483 16.2411 15.1543 12.635 15.1543 8.1348H13.1543C13.1543 11.5305 10.4437 14.2411 7.04802 14.2411V16.2411ZM15.1349 8.33091C15.2562 7.72418 14.9941 7.21156 14.6571 6.89864C14.3332 6.59791 13.8925 6.42417 13.4437 6.42417V8.42417C13.3897 8.42417 13.3437 8.40835 13.2962 8.36423C13.2677 8.33775 13.2259 8.28833 13.1963 8.20982C13.1647 8.12596 13.1555 8.0298 13.1737 7.93868L15.1349 8.33091ZM0.889226 10.0033C1.35335 10.0033 1.81783 9.84427 2.16879 9.49332C2.51974 9.14236 2.67882 8.67788 2.67882 8.21376H0.678815C0.678815 8.22339 0.679971 8.1537 0.754572 8.0791C0.829173 8.0045 0.898855 8.00335 0.889226 8.00335V10.0033ZM2.67882 8.21376C2.67882 5.68665 4.67883 3.68663 7.20594 3.68663V1.68663C3.57426 1.68663 0.678815 4.58208 0.678815 8.21376H2.67882ZM7.20594 3.68663H7.75865V1.68663H7.20594V3.68663ZM7.75865 3.68663C7.77936 3.68663 7.79332 3.68664 7.80571 3.68675C7.8176 3.68685 7.82362 3.68702 7.82632 3.68713C7.83092 3.68731 7.81609 3.68697 7.79165 3.6829C7.77945 3.68086 7.7666 3.6782 7.75359 3.67488C7.74064 3.67158 7.7294 3.6681 7.72024 3.66493C7.70229 3.65872 7.69616 3.65498 7.70623 3.66002L8.60066 1.87117C8.45669 1.79918 8.30149 1.74028 8.12045 1.71011C7.9642 1.68407 7.81793 1.68663 7.75865 1.68663V3.68663ZM8.15345 3.76559C8.05402 3.76559 7.97579 3.73415 8.03462 3.75376C8.09423 3.77363 8.2909 3.84455 8.54824 3.84455V1.84455C8.64767 1.84455 8.72589 1.876 8.66707 1.85639C8.60746 1.83652 8.41079 1.76559 8.15345 1.76559V3.76559ZM8.54824 3.84455C8.40417 3.84455 8.29871 3.80911 8.25634 3.79322C8.2331 3.78451 8.21718 3.77712 8.21264 3.77499C8.2091 3.77334 8.2076 3.77253 8.21947 3.77846C8.22734 3.7824 8.24858 3.79308 8.27185 3.80399C8.29614 3.81537 8.3318 3.83139 8.37477 3.8475C8.45663 3.8782 8.60157 3.92351 8.78512 3.92351V1.92351C8.92919 1.92351 9.03464 1.95895 9.07702 1.97484C9.10026 1.98356 9.11618 1.99094 9.12072 1.99307C9.12426 1.99473 9.12576 1.99554 9.11389 1.9896C9.10602 1.98567 9.08478 1.97499 9.06151 1.96408C9.03722 1.95269 9.00156 1.93667 8.95858 1.92056C8.87673 1.88986 8.73179 1.84455 8.54824 1.84455V3.84455ZM8.5104 3.88503C8.9831 4.02009 9.3934 4.20573 9.72411 4.48132L11.0045 2.94488C10.3877 2.43088 9.69257 2.14277 9.05984 1.96199L8.5104 3.88503ZM9.65719 4.42021C9.82281 4.58582 9.99567 4.66656 10.0355 4.68649C10.0746 4.70604 9.98072 4.66478 9.89407 4.57812L11.3083 3.16391C11.1427 2.99829 10.9698 2.91756 10.9299 2.89763C10.8908 2.87808 10.9847 2.91934 11.0714 3.00599L9.65719 4.42021ZM9.89407 4.57812C10.0597 4.74374 10.2325 4.82448 10.2724 4.84441C10.3115 4.86396 10.2176 4.8227 10.1309 4.73604L11.5452 3.32183C11.3795 3.15621 11.2067 3.07547 11.1668 3.05555C11.1277 3.03599 11.2216 3.07725 11.3083 3.16391L9.89407 4.57812ZM10.1309 4.73604C10.1006 4.70566 10.0856 4.68401 10.1072 4.71194C10.117 4.72457 10.1579 4.77871 10.1981 4.82704C10.2851 4.93134 10.449 5.11038 10.7067 5.2392L11.6011 3.45034C11.7008 3.5002 11.7464 3.5608 11.7346 3.54667C11.7324 3.5441 11.7285 3.53919 11.7208 3.52939C11.717 3.52448 11.713 3.51918 11.7077 3.5123C11.7029 3.50606 11.6963 3.49742 11.6898 3.48904C11.6771 3.47256 11.658 3.44809 11.636 3.42175C11.6141 3.39546 11.5833 3.35998 11.5452 3.32183L10.1309 4.73604ZM10.4468 5.05188L10.6047 5.2098L12.0189 3.79558L11.861 3.63766L10.4468 5.05188ZM11.1474 3.51629L9.72614 3.75317L10.0549 5.72596L11.4762 5.48908L11.1474 3.51629ZM9.69443 3.75898C8.78966 3.93994 8.10159 4.82615 8.27248 5.85147L10.2453 5.52267C10.2506 5.55443 10.2421 5.60217 10.214 5.64195C10.1914 5.67402 10.1512 5.70724 10.0867 5.72015L9.69443 3.75898ZM8.27829 5.88319C8.45766 6.78001 9.21318 7.31874 10.0485 7.31874V5.31874C10.0527 5.31874 10.0982 5.32155 10.153 5.36464C10.2115 5.41056 10.2346 5.46647 10.2395 5.49096L8.27829 5.88319ZM10.0485 7.31874H10.2064V5.31874H10.0485V7.31874ZM10.3935 7.30108L13.7098 6.66941L13.3355 4.70473L10.0193 5.33641L10.3935 7.30108ZM13.7188 6.66765C14.6235 6.4867 15.3116 5.60049 15.1407 4.57517L13.1679 4.90396C13.1626 4.87221 13.1711 4.82447 13.1992 4.78468C13.2218 4.75262 13.262 4.7194 13.3265 4.70649L13.7188 6.66765ZM15.1358 4.54806L14.5041 1.31074L12.5412 1.69376L13.1728 4.93108L15.1358 4.54806ZM14.5032 1.30613C14.3223 0.401368 13.4361 -0.286703 12.4107 -0.115815L12.7395 1.85697C12.7078 1.86227 12.6601 1.85381 12.6203 1.82572C12.5882 1.80309 12.555 1.76291 12.5421 1.69837L14.5032 1.30613ZM12.379 -0.110002C11.4743 0.0709516 10.7862 0.957158 10.9571 1.98248L12.9299 1.65369C12.9352 1.68544 12.9267 1.73318 12.8986 1.77297C12.876 1.80504 12.8358 1.83825 12.7713 1.85116L12.379 -0.110002ZM10.9587 1.99187L11.1956 3.33417L13.1651 2.9866L12.9283 1.6443L10.9587 1.99187ZM12.8875 2.45328C12.8113 2.37716 12.6944 2.25988 12.573 2.15061C12.4717 2.05948 12.2859 1.89774 12.0749 1.79221L11.1804 3.58106C11.1404 3.56105 11.1285 3.54899 11.1517 3.56671C11.1701 3.5807 11.1978 3.60367 11.235 3.63719C11.311 3.70558 11.3914 3.7857 11.4732 3.86749L12.8875 2.45328ZM11.6276 1.68663H11.5487V3.68663H11.6276V1.68663ZM12.2558 1.97953C12.2294 1.95312 12.1377 1.85865 12.0302 1.77807C11.9333 1.70537 11.6776 1.52872 11.3118 1.52872V3.52872C11.1628 3.52872 11.0452 3.49124 10.9702 3.45844C10.8975 3.42664 10.8497 3.39267 10.8302 3.37806C10.8097 3.36263 10.8 3.35299 10.8055 3.35818C10.8114 3.36374 10.8197 3.37183 10.8416 3.39374L12.2558 1.97953ZM12.0189 1.82161C11.7676 1.57034 11.4408 1.38655 11.3138 1.30187L10.2044 2.96597C10.2739 3.0123 10.3365 3.0521 10.3876 3.08453C10.4419 3.11893 10.4776 3.14155 10.5104 3.16337C10.5681 3.20189 10.5889 3.22 10.6047 3.23582L12.0189 1.82161ZM11.3138 1.30187C11.1359 1.18327 10.9631 1.09815 10.851 1.0421C10.7262 0.97971 10.6621 0.946395 10.6032 0.907076L9.49376 2.57118C9.67166 2.68978 9.84446 2.7749 9.95656 2.83095C10.0813 2.89334 10.1454 2.92665 10.2044 2.96597L11.3138 1.30187ZM10.0485 0.739127H9.9695V2.73913H10.0485V0.739127ZM10.6766 1.03202C10.5389 0.894265 10.3935 0.817816 10.2954 0.775175C10.2016 0.734389 10.1144 0.709484 10.0764 0.698644C9.96691 0.667351 9.99741 0.674526 10.0219 0.686782L9.12749 2.47564C9.22619 2.52499 9.31618 2.55763 9.38491 2.5798C9.41912 2.59083 9.44989 2.59984 9.47348 2.60658C9.48519 2.60992 9.49638 2.61307 9.50504 2.6155C9.51443 2.61813 9.52095 2.61997 9.52699 2.62169C9.53948 2.62526 9.54114 2.6259 9.53806 2.62488C9.53476 2.62379 9.51974 2.61877 9.49798 2.60931C9.45666 2.59135 9.36067 2.54451 9.26239 2.44623L10.6766 1.03202ZM9.81724 0.611066C9.48804 0.528766 9.21471 0.459757 9.02239 0.395649L8.38993 2.29302C8.67136 2.38683 9.0297 2.47573 9.33217 2.55135L9.81724 0.611066ZM8.70616 0.344332C8.72796 0.344332 8.74488 0.345688 8.75567 0.346868C8.76111 0.347463 8.76526 0.348044 8.76794 0.348452C8.76929 0.348657 8.77031 0.348826 8.77098 0.348941C8.77165 0.349056 8.772 0.349122 8.77201 0.349123C8.77201 0.349123 8.77171 0.349066 8.77106 0.348934C8.77041 0.348803 8.76945 0.348606 8.76816 0.348328C8.76552 0.347762 8.76182 0.346935 8.75669 0.345733C8.74534 0.343072 8.73277 0.339948 8.71182 0.33471C8.67746 0.32612 8.60891 0.308671 8.53513 0.294838C8.45817 0.280408 8.35359 0.265373 8.23241 0.265373V2.26537C8.21061 2.26537 8.19368 2.26402 8.1829 2.26284C8.17745 2.26224 8.1733 2.26166 8.17063 2.26125C8.16928 2.26105 8.16825 2.26088 8.16758 2.26076C8.16691 2.26065 8.16656 2.26058 8.16656 2.26058C8.16655 2.26058 8.16686 2.26064 8.16751 2.26077C8.16816 2.2609 8.16911 2.2611 8.1704 2.26138C8.17304 2.26194 8.17674 2.26277 8.18187 2.26397C8.19322 2.26663 8.20579 2.26976 8.22675 2.275C8.26111 2.28359 8.32966 2.30103 8.40343 2.31487C8.4804 2.3293 8.58498 2.34433 8.70616 2.34433V0.344332ZM8.23241 0.265373H7.2849V2.26537H8.23241V0.265373ZM7.2849 0.265373C2.78467 0.265373 -0.821404 3.87144 -0.821404 8.37168H1.1786C1.1786 4.97601 3.88924 2.26537 7.2849 2.26537V0.265373ZM-0.791547 8.12914C-0.936467 8.70882 -0.693562 9.22513 -0.351636 9.54075C-0.0141964 9.85224 0.436276 10.0033 0.889226 10.0033V8.00335C0.868423 8.00335 0.924101 7.99654 1.00492 8.07115C1.09023 8.14989 1.2147 8.35037 1.14874 8.61421L-0.791547 8.12914Z",
              fill: "var(--color-active)",
              mask: "url(#path-1-inside-1_828_425)"
            }
          )
        ]
      }
    ),
    spainFlag: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "20px",
        height: "20px",
        viewBox: "0 0 36 36",
        xmlns: "http://www.w3.org/2000/svg",
        "aria-hidden": "true",
        role: "img",
        className: "iconify iconify--twemoji",
        preserveAspectRatio: "xMidYMid meet",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fill: "#C60A1D",
              d: "M36 27a4 4 0 0 1-4 4H4a4 4 0 0 1-4-4V9a4 4 0 0 1 4-4h28a4 4 0 0 1 4 4v18z"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#FFC400", d: "M0 12h36v12H0z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#EA596E", d: "M9 17v3a3 3 0 1 0 6 0v-3H9z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#F4A2B2", d: "M12 16h3v3h-3z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#DD2E44", d: "M9 16h3v3H9z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("ellipse", { fill: "#EA596E", cx: "12", cy: "14.5", rx: "3", ry: "1.5" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("ellipse", { fill: "#FFAC33", cx: "12", cy: "13.75", rx: "3", ry: ".75" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#99AAB5", d: "M7 16h1v7H7zm9 0h1v7h-1z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fill: "#66757F",
              d: "M6 22h3v1H6zm9 0h3v1h-3zm-8-7h1v1H7zm9 0h1v1h-1z"
            }
          )
        ]
      }
    ),
    usaFlag: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "20px",
        height: "20px",
        viewBox: "0 -4 28 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_503_3486)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "28", height: "20", rx: "2", fill: "white" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "mask",
              {
                id: "mask0_503_3486",
                maskUnits: "userSpaceOnUse",
                x: "0",
                y: "0",
                width: "28",
                height: "20",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "28", height: "20", rx: "2", fill: "white" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { mask: "url(#mask0_503_3486)", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M28 0H0V1.33333H28V0ZM28 2.66667H0V4H28V2.66667ZM0 5.33333H28V6.66667H0V5.33333ZM28 8H0V9.33333H28V8ZM0 10.6667H28V12H0V10.6667ZM28 13.3333H0V14.6667H28V13.3333ZM0 16H28V17.3333H0V16ZM28 18.6667H0V20H28V18.6667Z",
                  fill: "#D02F44"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "12", height: "9.33333", fill: "#46467F" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("g", { filter: "url(#filter0_d_503_3486)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M2.66665 1.99999C2.66665 2.36818 2.36817 2.66666 1.99998 2.66666C1.63179 2.66666 1.33331 2.36818 1.33331 1.99999C1.33331 1.63181 1.63179 1.33333 1.99998 1.33333C2.36817 1.33333 2.66665 1.63181 2.66665 1.99999ZM5.33331 1.99999C5.33331 2.36818 5.03484 2.66666 4.66665 2.66666C4.29846 2.66666 3.99998 2.36818 3.99998 1.99999C3.99998 1.63181 4.29846 1.33333 4.66665 1.33333C5.03484 1.33333 5.33331 1.63181 5.33331 1.99999ZM7.33331 2.66666C7.7015 2.66666 7.99998 2.36818 7.99998 1.99999C7.99998 1.63181 7.7015 1.33333 7.33331 1.33333C6.96512 1.33333 6.66665 1.63181 6.66665 1.99999C6.66665 2.36818 6.96512 2.66666 7.33331 2.66666ZM10.6666 1.99999C10.6666 2.36818 10.3682 2.66666 9.99998 2.66666C9.63179 2.66666 9.33331 2.36818 9.33331 1.99999C9.33331 1.63181 9.63179 1.33333 9.99998 1.33333C10.3682 1.33333 10.6666 1.63181 10.6666 1.99999ZM3.33331 3.99999C3.7015 3.99999 3.99998 3.70152 3.99998 3.33333C3.99998 2.96514 3.7015 2.66666 3.33331 2.66666C2.96512 2.66666 2.66665 2.96514 2.66665 3.33333C2.66665 3.70152 2.96512 3.99999 3.33331 3.99999ZM6.66665 3.33333C6.66665 3.70152 6.36817 3.99999 5.99998 3.99999C5.63179 3.99999 5.33331 3.70152 5.33331 3.33333C5.33331 2.96514 5.63179 2.66666 5.99998 2.66666C6.36817 2.66666 6.66665 2.96514 6.66665 3.33333ZM8.66665 3.99999C9.03484 3.99999 9.33331 3.70152 9.33331 3.33333C9.33331 2.96514 9.03484 2.66666 8.66665 2.66666C8.29846 2.66666 7.99998 2.96514 7.99998 3.33333C7.99998 3.70152 8.29846 3.99999 8.66665 3.99999ZM10.6666 4.66666C10.6666 5.03485 10.3682 5.33333 9.99998 5.33333C9.63179 5.33333 9.33331 5.03485 9.33331 4.66666C9.33331 4.29847 9.63179 3.99999 9.99998 3.99999C10.3682 3.99999 10.6666 4.29847 10.6666 4.66666ZM7.33331 5.33333C7.7015 5.33333 7.99998 5.03485 7.99998 4.66666C7.99998 4.29847 7.7015 3.99999 7.33331 3.99999C6.96512 3.99999 6.66665 4.29847 6.66665 4.66666C6.66665 5.03485 6.96512 5.33333 7.33331 5.33333ZM5.33331 4.66666C5.33331 5.03485 5.03484 5.33333 4.66665 5.33333C4.29846 5.33333 3.99998 5.03485 3.99998 4.66666C3.99998 4.29847 4.29846 3.99999 4.66665 3.99999C5.03484 3.99999 5.33331 4.29847 5.33331 4.66666ZM1.99998 5.33333C2.36817 5.33333 2.66665 5.03485 2.66665 4.66666C2.66665 4.29847 2.36817 3.99999 1.99998 3.99999C1.63179 3.99999 1.33331 4.29847 1.33331 4.66666C1.33331 5.03485 1.63179 5.33333 1.99998 5.33333ZM3.99998 5.99999C3.99998 6.36819 3.7015 6.66666 3.33331 6.66666C2.96512 6.66666 2.66665 6.36819 2.66665 5.99999C2.66665 5.6318 2.96512 5.33333 3.33331 5.33333C3.7015 5.33333 3.99998 5.6318 3.99998 5.99999ZM5.99998 6.66666C6.36817 6.66666 6.66665 6.36819 6.66665 5.99999C6.66665 5.6318 6.36817 5.33333 5.99998 5.33333C5.63179 5.33333 5.33331 5.6318 5.33331 5.99999C5.33331 6.36819 5.63179 6.66666 5.99998 6.66666ZM9.33331 5.99999C9.33331 6.36819 9.03484 6.66666 8.66665 6.66666C8.29846 6.66666 7.99998 6.36819 7.99998 5.99999C7.99998 5.6318 8.29846 5.33333 8.66665 5.33333C9.03484 5.33333 9.33331 5.6318 9.33331 5.99999ZM9.99998 8C10.3682 8 10.6666 7.70152 10.6666 7.33333C10.6666 6.96514 10.3682 6.66666 9.99998 6.66666C9.63179 6.66666 9.33331 6.96514 9.33331 7.33333C9.33331 7.70152 9.63179 8 9.99998 8ZM7.99998 7.33333C7.99998 7.70152 7.7015 8 7.33331 8C6.96512 8 6.66665 7.70152 6.66665 7.33333C6.66665 6.96514 6.96512 6.66666 7.33331 6.66666C7.7015 6.66666 7.99998 6.96514 7.99998 7.33333ZM4.66665 8C5.03484 8 5.33331 7.70152 5.33331 7.33333C5.33331 6.96514 5.03484 6.66666 4.66665 6.66666C4.29846 6.66666 3.99998 6.96514 3.99998 7.33333C3.99998 7.70152 4.29846 8 4.66665 8ZM2.66665 7.33333C2.66665 7.70152 2.36817 8 1.99998 8C1.63179 8 1.33331 7.70152 1.33331 7.33333C1.33331 6.96514 1.63179 6.66666 1.99998 6.66666C2.36817 6.66666 2.66665 6.96514 2.66665 7.33333Z",
                  fill: "url(#paint0_linear_503_3486)"
                }
              ) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "filter",
              {
                id: "filter0_d_503_3486",
                x: "1.33331",
                y: "1.33333",
                width: "9.33331",
                height: "7.66667",
                filterUnits: "userSpaceOnUse",
                colorInterpolationFilters: "sRGB",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "feColorMatrix",
                    {
                      in: "SourceAlpha",
                      type: "matrix",
                      values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0",
                      result: "hardAlpha"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("feOffset", { dy: "1" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "feColorMatrix",
                    {
                      type: "matrix",
                      values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.06 0"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "feBlend",
                    {
                      mode: "normal",
                      in2: "BackgroundImageFix",
                      result: "effect1_dropShadow_503_3486"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "feBlend",
                    {
                      mode: "normal",
                      in: "SourceGraphic",
                      in2: "effect1_dropShadow_503_3486",
                      result: "shape"
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "linearGradient",
              {
                id: "paint0_linear_503_3486",
                x1: "1.33331",
                y1: "1.33333",
                x2: "1.33331",
                y2: "7.99999",
                gradientUnits: "userSpaceOnUse",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { stopColor: "white" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: "#F0F0F0" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_503_3486", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "28", height: "20", rx: "2", fill: "white" }) })
          ] })
        ]
      }
    ),
    blankCircle: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "20px",
        height: "20px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z",
            stroke: "var(--font-color-secondary)",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    ),
    reminderSvg: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "16px",
        height: "16px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M16 3.98999H8C6.93913 3.98999 5.92178 4.41135 5.17163 5.1615C4.42149 5.91164 4 6.92912 4 7.98999V17.99C4 19.0509 4.42149 20.0682 5.17163 20.8184C5.92178 21.5685 6.93913 21.99 8 21.99H16C17.0609 21.99 18.0783 21.5685 18.8284 20.8184C19.5786 20.0682 20 19.0509 20 17.99V7.98999C20 6.92912 19.5786 5.91164 18.8284 5.1615C18.0783 4.41135 17.0609 3.98999 16 3.98999Z",
              stroke: "#02A9EA",
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M9 2V7",
              stroke: "#02A9EA",
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15 2V7",
              stroke: "#02A9EA",
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M8 16H14",
              stroke: "#02A9EA",
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M8 12H16",
              stroke: "#02A9EA",
              strokeWidth: "1.5",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    sendSvg: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "20px",
        height: "20px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M11.5003 12H5.41872M5.24634 12.7972L4.24158 15.7986C3.69128 17.4424 3.41613 18.2643 3.61359 18.7704C3.78506 19.21 4.15335 19.5432 4.6078 19.6701C5.13111 19.8161 5.92151 19.4604 7.50231 18.7491L17.6367 14.1886C19.1797 13.4942 19.9512 13.1471 20.1896 12.6648C20.3968 12.2458 20.3968 11.7541 20.1896 11.3351C19.9512 10.8529 19.1797 10.5057 17.6367 9.81135L7.48483 5.24303C5.90879 4.53382 5.12078 4.17921 4.59799 4.32468C4.14397 4.45101 3.77572 4.78336 3.60365 5.22209C3.40551 5.72728 3.67772 6.54741 4.22215 8.18767L5.24829 11.2793C5.34179 11.561 5.38855 11.7019 5.407 11.8459C5.42338 11.9738 5.42321 12.1032 5.40651 12.231C5.38768 12.375 5.34057 12.5157 5.24634 12.7972Z",
            stroke: "var(--read-font-color)",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    ),
    openEyeIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "15px",
        height: "15px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M15.0007 12C15.0007 13.6569 13.6576 15 12.0007 15C10.3439 15 9.00073 13.6569 9.00073 12C9.00073 10.3431 10.3439 9 12.0007 9C13.6576 9 15.0007 10.3431 15.0007 12Z",
              stroke: "#000000",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12.0012 5C7.52354 5 3.73326 7.94288 2.45898 12C3.73324 16.0571 7.52354 19 12.0012 19C16.4788 19 20.2691 16.0571 21.5434 12C20.2691 7.94291 16.4788 5 12.0012 5Z",
              stroke: "#000000",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          )
        ]
      }
    ),
    closeEyeIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "15px",
        height: "15px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M2.99902 3L20.999 21M9.8433 9.91364C9.32066 10.4536 8.99902 11.1892 8.99902 12C8.99902 13.6569 10.3422 15 11.999 15C12.8215 15 13.5667 14.669 14.1086 14.133M6.49902 6.64715C4.59972 7.90034 3.15305 9.78394 2.45703 12C3.73128 16.0571 7.52159 19 11.9992 19C13.9881 19 15.8414 18.4194 17.3988 17.4184M10.999 5.04939C11.328 5.01673 11.6617 5 11.9992 5C16.4769 5 20.2672 7.94291 21.5414 12C21.2607 12.894 20.8577 13.7338 20.3522 14.5",
            stroke: "#000000",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    ),
    solutionIcon: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "18px",
        height: "18px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12 7C9.23858 7 7 9.23858 7 12C7 13.3613 7.54402 14.5955 8.42651 15.4972C8.77025 15.8484 9.05281 16.2663 9.14923 16.7482L9.67833 19.3924C9.86537 20.3272 10.6862 21 11.6395 21H12.3605C13.3138 21 14.1346 20.3272 14.3217 19.3924L14.8508 16.7482C14.9472 16.2663 15.2297 15.8484 15.5735 15.4972C16.456 14.5955 17 13.3613 17 12C17 9.23858 14.7614 7 12 7Z",
              stroke: "var(--color-active)",
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M12 4V3",
              stroke: "var(--color-active)",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M18 6L19 5",
              stroke: "var(--color-active)",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M20 12H21",
              stroke: "var(--color-active)",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M4 12H3",
              stroke: "var(--color-active)",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M5 5L6 6",
              stroke: "var(--color-active)",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M10 17H14",
              stroke: "var(--color-active)",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              opacity: "0.1",
              d: "M7 12C7 9.23858 9.23858 7 12 7C14.7614 7 17 9.23858 17 12C17 13.3613 16.456 14.5955 15.5735 15.4972C15.2297 15.8484 14.9472 16.2663 14.8508 16.7482L14.8004 17H9.19961L9.14923 16.7482C9.05281 16.2663 8.77025 15.8484 8.42651 15.4972C7.54402 14.5955 7 13.3613 7 12Z",
              fill: "var(--color-active)"
            }
          )
        ]
      }
    ),
    youtubeVideo: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "200px",
        height: "200px",
        viewBox: "0 0 24 24",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: "youtube_fill" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "页面-1",
              stroke: "none",
              strokeWidth: "1",
              fill: "none",
              fillRule: "evenodd",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Brand", transform: "translate(-912.000000, -48.000000)", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "youtube_fill", transform: "translate(912.000000, 48.000000)", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M24,0 L24,24 L0,24 L0,0 L24,0 Z M12.5934901,23.257841 L12.5819402,23.2595131 L12.5108777,23.2950439 L12.4918791,23.2987469 L12.4918791,23.2987469 L12.4767152,23.2950439 L12.4056548,23.2595131 C12.3958229,23.2563662 12.3870493,23.2590235 12.3821421,23.2649074 L12.3780323,23.275831 L12.360941,23.7031097 L12.3658947,23.7234994 L12.3769048,23.7357139 L12.4804777,23.8096931 L12.4953491,23.8136134 L12.4953491,23.8136134 L12.5071152,23.8096931 L12.6106902,23.7357139 L12.6232938,23.7196733 L12.6232938,23.7196733 L12.6266527,23.7031097 L12.609561,23.275831 C12.6075724,23.2657013 12.6010112,23.2592993 12.5934901,23.257841 L12.5934901,23.257841 Z M12.8583906,23.1452862 L12.8445485,23.1473072 L12.6598443,23.2396597 L12.6498822,23.2499052 L12.6498822,23.2499052 L12.6471943,23.2611114 L12.6650943,23.6906389 L12.6699349,23.7034178 L12.6699349,23.7034178 L12.678386,23.7104931 L12.8793402,23.8032389 C12.8914285,23.8068999 12.9022333,23.8029875 12.9078286,23.7952264 L12.9118235,23.7811639 L12.8776777,23.1665331 C12.8752882,23.1545897 12.8674102,23.1470016 12.8583906,23.1452862 L12.8583906,23.1452862 Z M12.1430473,23.1473072 C12.1332178,23.1423925 12.1221763,23.1452606 12.1156365,23.1525954 L12.1099173,23.1665331 L12.0757714,23.7811639 C12.0751323,23.7926639 12.0828099,23.8018602 12.0926481,23.8045676 L12.108256,23.8032389 L12.3092106,23.7104931 L12.3186497,23.7024347 L12.3186497,23.7024347 L12.3225043,23.6906389 L12.340401,23.2611114 L12.337245,23.2485176 L12.337245,23.2485176 L12.3277531,23.2396597 L12.1430473,23.1473072 Z",
                    id: "MingCute",
                    fillRule: "nonzero"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: "M12,4 C12.8554231,4 13.7316302,4.02241864 14.5816652,4.05776684 L15.5861395,4.10578357 L15.5861395,4.10578357 L16.5474575,4.16256888 L16.5474575,4.16256888 L17.447588,4.22447896 L17.447588,4.22447896 L18.2685,4.28787 L18.2685,4.28787 C20.1065,4.43702 21.5836,5.85942 21.7633,7.71109 L21.8030749,8.13562908 L21.8030749,8.13562908 L21.8780889,9.04557185 C21.9482222,9.98880444 22,11.0173333 22,12 C22,12.9826667 21.9482222,14.0112 21.8780889,14.9544296 L21.8030749,15.8643665 C21.7899654,16.0096642 21.7766556,16.1513778 21.7633,16.2889 C21.5836,18.1406 20.1065,19.563 18.2685,19.7121 L17.447588,19.7754863 L17.447588,19.7754863 L16.5474575,19.837399 L16.5474575,19.837399 L15.5861395,19.8941917 L15.5861395,19.8941917 L14.5816652,19.9422178 C13.7316302,19.977574 12.8554231,20 12,20 C11.1445923,20 10.2683828,19.977574 9.41834133,19.9422178 L8.4138582,19.8941917 L8.4138582,19.8941917 L7.45253268,19.837399 L7.45253268,19.837399 L6.55240116,19.7754863 L6.55240116,19.7754863 L5.7315,19.7121 L5.7315,19.7121 C3.89351,19.563 2.4164,18.1406 2.23668,16.2889 L2.19692159,15.8643665 L2.19692159,15.8643665 L2.12192296,14.9544296 C2.05179556,14.0112 2,12.9826667 2,12 C2,11.0173333 2.05179556,9.98880444 2.12192296,9.04557185 L2.19692159,8.13562908 C2.21002667,7.99032988 2.22333111,7.84861444 2.23668,7.71109 C2.4164,5.85942 3.89351,4.43702 5.7315,4.28787 L6.55240056,4.22447896 L6.55240056,4.22447896 L7.45253071,4.16256888 L7.45253071,4.16256888 L8.41385476,4.10578357 L8.41385476,4.10578357 L9.41833696,4.05776684 C10.2683781,4.02241864 11.1445885,4 12,4 Z M10,9.57513 L10,14.4249 C10,14.8868 10.5,15.1754 10.9,14.9445 L15.1,12.5196 C15.5,12.2887 15.5,11.7113 15.1,11.4804 L10.9,9.05551 C10.5,8.82457 10,9.11325 10,9.57513 Z",
                    id: "形状",
                    fill: "red"
                  }
                )
              ] }) })
            }
          )
        ]
      }
    ),
    learnpackLogo: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "24",
        height: "28",
        viewBox: "0 0 24 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M0 7.82707V19.3184C0 20.0446 0.387928 20.7155 1.01755 21.0786L10.9824 26.8242C11.6121 27.1873 12.3879 27.1873 13.0176 26.8242L22.9824 21.0786C23.6121 20.7155 24 20.0446 24 19.3184V7.82707C24 7.10091 23.6121 6.42998 22.9824 6.0669L13.0176 0.321138C12.3879 -0.0419417 11.6121 -0.0419417 10.9824 0.321138L1.01755 6.0669C0.387928 6.42983 0 7.10091 0 7.82707Z",
              fill: "#00041A"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M11.98 21.627C11.8633 21.6896 11.7225 21.688 11.6071 21.6229L4.0149 17.3429C3.75712 17.1975 3.43809 17.3836 3.43809 17.6793C3.43809 17.8152 3.50964 17.9411 3.62635 18.0109L11.6297 22.7894C11.7497 22.861 11.8989 22.8624 12.0202 22.7932L20.3671 18.0254C20.5001 17.9494 20.5754 17.8024 20.5597 17.6503C20.5357 17.4167 20.5138 17.0937 20.5677 17.0293L11.98 21.627Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M20.5709 17.0291L20.5926 17.0176C20.5843 17.0176 20.5771 17.0218 20.5709 17.0291Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M20.2609 19.2883L11.8275 24.0176L3.31856 19.1585C3.07296 19.0182 2.92126 18.7573 2.92126 18.4746V16.5681C2.92126 16.2047 3.31247 15.9754 3.63025 16.1523L11.8361 20.7249L21.5692 15.2171C21.674 15.1578 21.6649 15.0039 21.5539 14.9573L20.4219 14.4822C19.6862 14.1734 18.8521 14.2021 18.1394 14.5606L11.8361 17.7318L5.54567 14.6348C4.72435 14.2303 3.76117 14.2317 2.94094 14.6382C2.28351 14.964 1.86777 15.6336 1.86777 16.3665V17.9276C1.86777 18.8003 2.32913 19.6082 3.08124 20.0524L11.8275 25.2184L22.0571 19.356L21.5818 19.1821C21.1472 19.0229 20.6644 19.0618 20.2609 19.2882V19.2883Z",
              fill: "#0097CF"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M22.5422 8.25559L11.9895 2.16C11.8945 2.10524 11.7775 2.10555 11.6828 2.16078L1.25703 8.25808C1.05267 8.3776 1.05689 8.67406 1.26453 8.78764L4.96539 10.8126V12.5122C4.96539 12.8275 5.13694 13.1178 5.41331 13.2702L11.4096 16.5777C11.6697 16.7211 11.9851 16.7217 12.2456 16.5789L18.2903 13.2696C18.5679 13.1176 18.7405 12.8265 18.7405 12.5102V10.8124L21.4213 9.38102V13.1824C21.4213 13.3995 21.5977 13.5757 21.8152 13.5757H21.9842C22.2017 13.5757 22.3781 13.3995 22.3781 13.1824V8.87018L22.5331 8.78749C22.7438 8.67499 22.7488 8.3751 22.542 8.25559H22.5422ZM20.8006 8.69044L11.9487 13.3479C11.887 13.3804 11.8133 13.38 11.7519 13.3471L3.07075 8.69793C2.92545 8.62023 2.92279 8.41317 3.0659 8.33157L11.7247 3.39138C11.7884 3.35503 11.8665 3.35456 11.9306 3.39029L20.8047 8.32237C20.9501 8.40319 20.9478 8.61305 20.8005 8.69059L20.8006 8.69044Z",
              fill: "white"
            }
          )
        ]
      }
    ),
    resetIconV2: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "18",
        height: "19",
        viewBox: "0 0 18 19",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M16.6871 8.1831C16.107 8.1831 15.7202 8.56987 15.7202 9.15004C15.7202 12.9211 12.7227 15.9186 8.95161 15.9186H8.27476C8.08137 15.9186 7.98467 15.9186 7.79129 15.8219C7.5979 15.8219 7.5012 15.7252 7.30782 15.7252C7.21112 15.7252 7.11443 15.6285 7.01773 15.6285C6.34088 15.4351 5.66402 15.0484 5.08386 14.6616C4.98716 14.5649 4.89047 14.5649 4.89047 14.4682C4.79377 14.3715 4.69708 14.2748 4.60039 14.2748C4.407 14.1781 4.21361 13.9847 4.11691 13.888L3.92353 13.6947L5.66402 13.4046C6.14749 13.3079 6.53427 12.8244 6.43757 12.2442C6.34088 11.7608 5.85741 11.374 5.27724 11.4707L2.08634 12.0509L1.31279 12.2442C1.02271 12.2442 0.829319 12.4376 0.732625 12.631C0.635931 12.8244 0.539237 13.1145 0.539237 13.3079L1.31279 17.369C1.40948 17.8525 1.79626 18.1426 2.27973 18.1426H2.47312C2.95659 18.0459 3.34336 17.5624 3.24667 16.9823L2.95659 15.3385C3.14997 15.5318 3.44006 15.7252 3.63344 15.9186H3.73014C3.82683 16.0153 3.92353 16.112 4.02022 16.112C4.21361 16.3054 4.407 16.4021 4.69708 16.4988C4.89047 16.8856 5.18055 16.9823 5.47063 17.1756H5.56732C5.66402 17.2723 5.85741 17.2723 6.05079 17.369C6.43757 17.4657 6.82435 17.5624 7.11443 17.6591C7.30782 17.6591 7.50121 17.7558 7.69459 17.7558H8.85492C13.6896 17.7558 17.5574 13.888 17.5574 9.05334C17.6541 8.56987 17.1706 8.1831 16.6871 8.1831ZM1.31279 10.117C1.89295 10.117 2.27973 9.7302 2.27973 9.15004C2.27973 5.37897 5.27724 2.38146 9.04831 2.38146H9.72517C9.91856 2.38146 10.0152 2.38146 10.2086 2.47815C10.402 2.47815 10.4987 2.57484 10.6921 2.57484C10.7888 2.57484 10.8855 2.67154 10.9822 2.67154C11.659 2.86493 12.3359 3.15501 12.9161 3.63848C13.0128 3.73517 13.1095 3.73517 13.2062 3.83187C13.3028 3.92856 13.3995 3.92856 13.4962 4.02525C13.5929 4.12195 13.6896 4.31534 13.883 4.41203L14.0764 4.60542L12.3359 4.8955C11.8524 4.99219 11.4657 5.47566 11.5624 6.05583C11.659 6.5393 12.0458 6.82938 12.5293 6.82938H12.7227L16.7838 6.05583C17.2673 5.95913 17.6541 5.47566 17.5574 4.8955L16.7838 0.931046C16.6871 0.447576 16.2037 0.0608003 15.6235 0.157494C15.14 0.254188 14.7533 0.737658 14.8499 1.31782L15.14 2.96162C14.9466 2.76823 14.6566 2.47815 14.4632 2.38146H14.3665C14.2698 2.28476 14.1731 2.18807 14.0764 2.18807C13.883 1.99468 13.6896 1.89799 13.3995 1.7046C13.1095 1.51121 12.8194 1.41452 12.5293 1.22113H12.4326C12.3359 1.12443 12.1425 1.12443 11.9491 1.02774C11.5624 0.931046 11.1756 0.834352 10.8855 0.737658C10.6921 0.737658 10.4987 0.640964 10.3053 0.640964H9.145C4.3103 0.640964 0.442542 4.50872 0.442542 9.34342C0.345848 9.7302 0.732625 10.117 1.31279 10.117Z",
            fill: "#A9A9A9"
          }
        )
      }
    ),
    feedbackIconV2: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "14",
        height: "19",
        viewBox: "0 0 14 19",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            "fill-rule": "evenodd",
            clipRule: "evenodd",
            d: "M7.16665 0.142578C3.59499 0.142578 0.684879 3.10377 0.686646 6.74167C0.687824 8.7034 1.57146 10.5361 3.04301 11.7834V13.9407C3.04301 14.9275 3.84123 15.7404 4.81028 15.7404H9.52301C10.4921 15.7404 11.2903 14.9275 11.2903 13.9407V11.7858C12.7624 10.5379 13.6461 8.704 13.6466 6.74167C13.6484 3.10377 10.7383 0.142578 7.16665 0.142578ZM7.16665 1.34241C7.86324 1.34115 8.55323 1.47994 9.19703 1.75083C9.84084 2.02172 10.4258 2.41938 10.9184 2.921C11.4109 3.42262 11.8014 4.01833 12.0674 4.67397C12.3334 5.32961 12.4697 6.03227 12.4685 6.74167C12.4669 7.54869 12.2873 8.34505 11.943 9.07191C11.5987 9.79877 11.0984 10.4376 10.4791 10.9411H7.16665C6.37019 10.9297 6.37019 12.1517 7.16665 12.1409H10.1121V13.9407C10.1121 14.2832 9.85938 14.5406 9.52301 14.5406H4.81028C4.47391 14.5406 4.22119 14.2832 4.22119 13.9407V12.1409H4.81028C5.60673 12.1523 5.60673 10.9303 4.81028 10.9411H3.85772C3.23766 10.438 2.73661 9.79942 2.39165 9.07252C2.04668 8.34561 1.86664 7.54901 1.86483 6.74167C1.86359 6.03227 1.99987 5.32961 2.26588 4.67397C2.53188 4.01833 2.92236 3.42262 3.41493 2.921C3.90749 2.41938 4.49245 2.02172 5.13626 1.75083C5.78007 1.47994 6.47005 1.34115 7.16665 1.34241ZM7.13896 3.73608C7.03361 3.7413 6.93156 3.77523 6.84348 3.83433C6.7554 3.89342 6.68452 3.97552 6.63823 4.07204L5.46005 6.47351C5.41505 6.56522 5.39387 6.66715 5.39855 6.76956C5.40323 6.87198 5.43361 6.97147 5.48678 7.05853C5.53995 7.14559 5.61415 7.21732 5.70228 7.26687C5.79042 7.31642 5.88956 7.34215 5.99023 7.34159H7.39109L6.63882 8.87318C6.57574 9.01486 6.56905 9.17594 6.62016 9.32254C6.67128 9.46914 6.77621 9.58985 6.91291 9.6593C7.0496 9.72875 7.20741 9.74152 7.35316 9.69494C7.49892 9.64836 7.62126 9.54604 7.69447 9.4095L8.87383 7.00863C8.91888 6.91683 8.94005 6.81479 8.93532 6.71227C8.93058 6.60976 8.90011 6.51019 8.84679 6.4231C8.79348 6.33601 8.71912 6.2643 8.63083 6.21483C8.54253 6.16536 8.44325 6.13979 8.34247 6.14055H6.94279L7.69506 4.60896C7.74234 4.5151 7.76448 4.4102 7.75925 4.30484C7.75401 4.19949 7.72159 4.0974 7.66525 4.00887C7.60891 3.92035 7.53065 3.84852 7.43835 3.80062C7.34606 3.75273 7.24299 3.73047 7.13955 3.73608H7.13896ZM5.93191 16.9415C5.93113 16.9419 5.93034 16.9423 5.92955 16.9427C5.77727 16.9563 5.63614 17.0296 5.53586 17.1472C5.43559 17.2647 5.38399 17.4172 5.39193 17.5727C5.39987 17.7281 5.46672 17.8744 5.57843 17.9807C5.69013 18.087 5.83797 18.145 5.99082 18.1425H8.34247C8.49871 18.1425 8.64854 18.0793 8.75902 17.9668C8.8695 17.8543 8.93156 17.7017 8.93156 17.5426C8.93156 17.3835 8.8695 17.2309 8.75902 17.1184C8.64854 17.0059 8.49871 16.9427 8.34247 16.9427H5.99082C5.97122 16.9413 5.95156 16.9409 5.93191 16.9415Z",
            fill: "#A9A9A9"
          }
        )
      }
    ),
    runCodeIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "19",
        height: "19",
        viewBox: "0 0 19 19",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M8.0335 13.1926L13.4335 9.14258L8.0335 5.09258V13.1926ZM9.8335 0.142578C4.861 0.142578 0.833496 4.17008 0.833496 9.14258C0.833496 14.1151 4.861 18.1426 9.8335 18.1426C14.806 18.1426 18.8335 14.1151 18.8335 9.14258C18.8335 4.17008 14.806 0.142578 9.8335 0.142578ZM9.8335 16.3426C5.8645 16.3426 2.6335 13.1116 2.6335 9.14258C2.6335 5.17358 5.8645 1.94258 9.8335 1.94258C13.8025 1.94258 17.0335 5.17358 17.0335 9.14258C17.0335 13.1116 13.8025 16.3426 9.8335 16.3426Z",
            fill: "white"
          }
        )
      }
    ),
    github: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "800px",
        height: "800px",
        viewBox: "0 0 20 20",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: "github [#142]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("desc", { children: "Created with Sketch." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              id: "Page-1",
              stroke: "none",
              strokeWidth: "1",
              fill: "none",
              fillRule: "evenodd",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  id: "Dribbble-Light-Preview",
                  transform: "translate(-140.000000, -7559.000000)",
                  fill: "var(--read-font-color)",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "icons", transform: "translate(56.000000, 160.000000)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: "M94,7399 C99.523,7399 104,7403.59 104,7409.253 C104,7413.782 101.138,7417.624 97.167,7418.981 C96.66,7419.082 96.48,7418.762 96.48,7418.489 C96.48,7418.151 96.492,7417.047 96.492,7415.675 C96.492,7414.719 96.172,7414.095 95.813,7413.777 C98.04,7413.523 100.38,7412.656 100.38,7408.718 C100.38,7407.598 99.992,7406.684 99.35,7405.966 C99.454,7405.707 99.797,7404.664 99.252,7403.252 C99.252,7403.252 98.414,7402.977 96.505,7404.303 C95.706,7404.076 94.85,7403.962 94,7403.958 C93.15,7403.962 92.295,7404.076 91.497,7404.303 C89.586,7402.977 88.746,7403.252 88.746,7403.252 C88.203,7404.664 88.546,7405.707 88.649,7405.966 C88.01,7406.684 87.619,7407.598 87.619,7408.718 C87.619,7412.646 89.954,7413.526 92.175,7413.785 C91.889,7414.041 91.63,7414.493 91.54,7415.156 C90.97,7415.418 89.522,7415.871 88.63,7414.304 C88.63,7414.304 88.101,7413.319 87.097,7413.247 C87.097,7413.247 86.122,7413.234 87.029,7413.87 C87.029,7413.87 87.684,7414.185 88.139,7415.37 C88.139,7415.37 88.726,7417.2 91.508,7416.58 C91.513,7417.437 91.522,7418.245 91.522,7418.489 C91.522,7418.76 91.338,7419.077 90.839,7418.982 C86.865,7417.627 84,7413.783 84,7409.253 C84,7403.59 88.478,7399 94,7399",
                      id: "github-[#142]"
                    }
                  ) })
                }
              )
            }
          )
        ]
      }
    ),
    iconBack: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "14",
        height: "15",
        viewBox: "0 0 14 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12.8328 6.40303H3.97417L7.82577 2.56311C8.04555 2.34333 8.16902 2.04524 8.16902 1.73443C8.16902 1.42361 8.04555 1.12553 7.82577 0.90575C7.60599 0.685971 7.3079 0.5625 6.99709 0.5625C6.68628 0.5625 6.38819 0.685971 6.16841 0.90575L0.332654 6.74151C0.226396 6.85251 0.143102 6.9834 0.0875521 7.12667C-0.0291841 7.41082 -0.0291841 7.72955 0.0875521 8.0137C0.143102 8.15697 0.226396 8.28786 0.332654 8.39886L6.16841 14.2346C6.27691 14.344 6.406 14.4308 6.54823 14.4901C6.69046 14.5494 6.84301 14.5799 6.99709 14.5799C7.15117 14.5799 7.30372 14.5494 7.44595 14.4901C7.58818 14.4308 7.71727 14.344 7.82577 14.2346C7.93516 14.1261 8.02199 13.997 8.08125 13.8548C8.1405 13.7126 8.17101 13.56 8.17101 13.4059C8.17101 13.2519 8.1405 13.0993 8.08125 12.9571C8.02199 12.8149 7.93516 12.6858 7.82577 12.5773L3.97417 8.73734H12.8328C13.1424 8.73734 13.4393 8.61437 13.6581 8.39549C13.877 8.1766 14 7.87973 14 7.57019C14 7.26064 13.877 6.96377 13.6581 6.74488C13.4393 6.526 13.1424 6.40303 12.8328 6.40303Z",
            fill: "white"
          }
        )
      }
    ),
    moon: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "30px",
        height: "30px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z",
            stroke: "var(--read-font-color)",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    ),
    sun: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "800px",
        height: "800px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z",
            stroke: "var(--read-font-color)",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        )
      }
    ),
    nextArrow: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "14",
        height: "10",
        viewBox: "0 0 14 10",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M8.4658 0.198869L13.2785 4.51989C13.5738 4.78505 13.5738 5.21495 13.2785 5.48011L8.4658 9.80113C8.17047 10.0663 7.69165 10.0663 7.39631 9.80113C7.10098 9.53597 7.10098 9.10606 7.39631 8.8409L10.918 5.67898L1.2561 5.67898C0.838441 5.67898 0.499859 5.37499 0.499859 5C0.499859 4.62501 0.838441 4.32102 1.2561 4.32102L10.918 4.32102L7.39631 1.1591C7.10098 0.893936 7.10098 0.464029 7.39631 0.198869C7.69165 -0.0662898 8.17047 -0.0662898 8.4658 0.198869Z",
            fill: "white"
          }
        )
      }
    ),
    redirect: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "800px",
        height: "800px",
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fill: "var(--read-font-color)",
            fillRule: "evenodd",
            d: "M8 3.517a1 1 0 011.62-.784l5.348 4.233a1 1 0 010 1.568l-5.347 4.233A1 1 0 018 11.983v-1.545c-.76-.043-1.484.003-2.254.218-.994.279-2.118.857-3.506 1.99a.993.993 0 01-1.129.096.962.962 0 01-.445-1.099c.415-1.5 1.425-3.141 2.808-4.412C4.69 6.114 6.244 5.241 8 5.042V3.517zm1.5 1.034v1.2a.75.75 0 01-.75.75c-1.586 0-3.066.738-4.261 1.835a8.996 8.996 0 00-1.635 2.014c.878-.552 1.695-.916 2.488-1.138 1.247-.35 2.377-.33 3.49-.207a.75.75 0 01.668.745v1.2l4.042-3.2L9.5 4.55z",
            clipRule: "evenodd"
          }
        )
      }
    ),
    closeX: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "800px",
        height: "800px",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: "M20.7457 3.32851C20.3552 2.93798 19.722 2.93798 19.3315 3.32851L12.0371 10.6229L4.74275 3.32851C4.35223 2.93798 3.71906 2.93798 3.32854 3.32851C2.93801 3.71903 2.93801 4.3522 3.32854 4.74272L10.6229 12.0371L3.32856 19.3314C2.93803 19.722 2.93803 20.3551 3.32856 20.7457C3.71908 21.1362 4.35225 21.1362 4.74277 20.7457L12.0371 13.4513L19.3315 20.7457C19.722 21.1362 20.3552 21.1362 20.7457 20.7457C21.1362 20.3551 21.1362 19.722 20.7457 19.3315L13.4513 12.0371L20.7457 4.74272C21.1362 4.3522 21.1362 3.71903 20.7457 3.32851Z",
            fill: "var(--read-font-color)"
          }
        )
      }
    ),
    newTab: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "800px",
        height: "800px",
        viewBox: "0 0 24 24",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            stroke: "var(--read-font-color)",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            strokeWidth: "2",
            d: "M10 4H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-4m-8-2 8-8m0 0v5m0-5h-5"
          }
        )
      }
    ),
    rigoSvg: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        width: "30",
        height: "30",
        viewBox: "0 0 24 14",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M18.4549 2.36911L17.93 1.40069L17.2413 0.129606C17.1479 -0.0432019 16.8817 -0.0432019 16.7883 0.129606L16.0996 1.40069L15.5936 2.33415H5.89392C5.12428 2.33415 4.46601 2.81711 4.19531 3.50085H19.7989C19.5707 2.92499 19.0677 2.49097 18.4549 2.36861V2.36911Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M22.8283 4.43156H22.2655V4.25426C22.2655 2.67701 20.9839 1.39844 19.4031 1.39844H17.9308L18.4557 2.36686C19.0685 2.48922 19.5715 2.92274 19.7997 3.4991H4.19609C4.46679 2.81536 5.12505 2.3324 5.8947 2.3324H15.5939L16.0998 1.39894H4.59265C3.01191 1.39894 1.73034 2.67751 1.73034 4.25476V4.43206H1.16696C0.96269 4.43206 0.796875 4.59538 0.796875 4.79715V9.66722C0.796875 9.869 0.96269 10.0323 1.16696 10.0323H3.13127V10.2136C3.13127 10.3954 3.1947 10.5622 3.30009 10.6926C3.31507 10.7111 3.33105 10.729 3.34753 10.746C3.381 10.78 3.41746 10.811 3.45691 10.8379C3.51585 10.8784 3.58077 10.9108 3.6502 10.9328C3.71962 10.9548 3.79354 10.9668 3.86995 10.9668H10.5175L11.413 8.1664L11.8166 6.9038C11.8755 6.72001 12.1213 6.72001 12.1802 6.9038L12.5837 8.1664L13.4792 10.9668H20.1273C20.2422 10.9668 20.3506 10.9403 20.4475 10.8924C20.5014 10.8659 20.5514 10.8329 20.5973 10.7945C20.6338 10.764 20.6672 10.7295 20.6977 10.6926C20.7202 10.6646 20.7412 10.6351 20.7596 10.6042C20.8276 10.4903 20.8665 10.3565 20.8665 10.2136V10.0323H22.8283C23.0326 10.0323 23.1984 9.869 23.1984 9.66722V4.79665C23.1984 4.59488 23.0326 4.43156 22.8283 4.43156ZM7.56384 8.1659V9.34109C7.56384 9.59381 7.35507 9.79858 7.09736 9.79858C6.83964 9.79858 6.63088 9.59381 6.63088 9.34109V4.88855C6.63088 4.63583 6.83964 4.43106 7.09736 4.43106C7.35507 4.43106 7.56384 4.63583 7.56384 4.88855V8.1654V8.1659ZM17.3664 8.1659V9.34109C17.3664 9.59381 17.1576 9.79858 16.8999 9.79858C16.6422 9.79858 16.4335 9.59381 16.4335 9.34109V4.88855C16.4335 4.63583 16.6422 4.43106 16.8999 4.43106C17.1576 4.43106 17.3664 4.63583 17.3664 4.88855V8.1654V8.1659Z",
              fill: "#080B16"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M13.4785 10.9664L12.583 8.16606L12.1795 6.90347C12.1205 6.71968 11.8748 6.71968 11.8159 6.90347L11.4123 8.16606L10.5168 10.9664H4.0625V12.1381C4.0625 13.1665 4.88209 14.0001 5.89346 14.0001H18.0999C19.1112 14.0001 19.9308 13.1665 19.9308 12.1381V10.9664H13.4785Z",
              fill: "white"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M7.09929 4.438C6.84158 4.438 6.63281 4.64277 6.63281 4.89549V9.34803C6.63281 9.60075 6.84158 9.80552 7.09929 9.80552C7.35701 9.80552 7.56577 9.60075 7.56577 9.34803V4.89499C7.56577 4.64227 7.35701 4.4375 7.09929 4.4375V4.438Z",
              fill: "#E95B17"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d: "M16.8962 4.438C16.6385 4.438 16.4297 4.64277 16.4297 4.89549V9.34803C16.4297 9.60075 16.6385 9.80552 16.8962 9.80552C17.1539 9.80552 17.3626 9.60075 17.3626 9.34803V4.89499C17.3626 4.64227 17.1539 4.4375 16.8962 4.4375V4.438Z",
              fill: "#0096CF"
            }
          )
        ]
      }
    )
  };
  const Modal = ({
    children,
    outsideClickHandler,
    htmlId,
    extraClass,
    blockScroll = true
  }) => {
    const modalRef = reactExports.useRef(null);
    const handleClickOutside = (event) => {
      if (modalRef.current === event.target || event.target.classList && event.target.classList.includes("modal-closer")) {
        outsideClickHandler();
      }
    };
    reactExports.useEffect(() => {
      if (modalRef.current) {
        modalRef.current.addEventListener("mousedown", handleClickOutside);
      }
      const originalOverflow = document.body.style.overflow;
      if (blockScroll) {
        document.body.style.overflow = "hidden";
      }
      return () => {
        if (modalRef.current) {
          modalRef.current.removeEventListener("mousedown", handleClickOutside);
        }
        if (blockScroll) {
          document.body.style.overflow = originalOverflow;
        }
      };
    }, []);
    return reactDomExports.createPortal(
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: modalRef, className: "self-closing-modal", id: htmlId, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `modal-content ${extraClass ? extraClass : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: outsideClickHandler, className: "modal-closer", children: svgs.closeIcon }),
        children
      ] }) }),
      document.body
    );
  };
  function SimpleButton({
    text: text2,
    action,
    svg,
    extraClass,
    disabled,
    id: id2,
    size,
    title
  }) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        id: id2,
        disabled: Boolean(disabled),
        className: `simple-button-svg ${extraClass} ${size}`,
        onClick: action,
        title,
        children: [
          svg,
          text2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: text2 })
        ]
      }
    );
  }
  function warn() {
    if (console && console.warn) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (isString(args[0]))
        args[0] = `react-i18next:: ${args[0]}`;
      console.warn(...args);
    }
  }
  const alreadyWarned = {};
  function warnOnce() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (isString(args[0]) && alreadyWarned[args[0]])
      return;
    if (isString(args[0]))
      alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
    warn(...args);
  }
  const loadedClb = (i18n, cb2) => () => {
    if (i18n.isInitialized) {
      cb2();
    } else {
      const initialized = () => {
        setTimeout(() => {
          i18n.off("initialized", initialized);
        }, 0);
        cb2();
      };
      i18n.on("initialized", initialized);
    }
  };
  const loadNamespaces = (i18n, ns, cb2) => {
    i18n.loadNamespaces(ns, loadedClb(i18n, cb2));
  };
  const loadLanguages = (i18n, lng, ns, cb2) => {
    if (isString(ns))
      ns = [ns];
    ns.forEach((n2) => {
      if (i18n.options.ns.indexOf(n2) < 0)
        i18n.options.ns.push(n2);
    });
    i18n.loadLanguages(lng, loadedClb(i18n, cb2));
  };
  const oldI18nextHasLoadedNamespace = function(ns, i18n) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const lng = i18n.languages[0];
    const fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
    const lastLng = i18n.languages[i18n.languages.length - 1];
    if (lng.toLowerCase() === "cimode")
      return true;
    const loadNotPending = (l2, n2) => {
      const loadState = i18n.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 2;
    };
    if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
      return false;
    if (i18n.hasResourceBundle(lng, ns))
      return true;
    if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
      return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
      return true;
    return false;
  };
  const hasLoadedNamespace = function(ns, i18n) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!i18n.languages || !i18n.languages.length) {
      warnOnce("i18n.languages were undefined or empty", i18n.languages);
      return true;
    }
    const isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
    if (!isNewerI18next) {
      return oldI18nextHasLoadedNamespace(ns, i18n, options);
    }
    return i18n.hasLoadedNamespace(ns, {
      lng: options.lng,
      precheck: (i18nInstance2, loadNotPending) => {
        if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
          return false;
      }
    });
  };
  const isString = (obj) => typeof obj === "string";
  const isObject$2 = (obj) => typeof obj === "object" && obj !== null;
  const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
  const htmlEntities = {
    "&amp;": "&",
    "&#38;": "&",
    "&lt;": "<",
    "&#60;": "<",
    "&gt;": ">",
    "&#62;": ">",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&nbsp;": " ",
    "&#160;": " ",
    "&copy;": "©",
    "&#169;": "©",
    "&reg;": "®",
    "&#174;": "®",
    "&hellip;": "…",
    "&#8230;": "…",
    "&#x2F;": "/",
    "&#47;": "/"
  };
  const unescapeHtmlEntity = (m2) => htmlEntities[m2];
  const unescape$1 = (text2) => text2.replace(matchHtmlEntity, unescapeHtmlEntity);
  let defaultOptions = {
    bindI18n: "languageChanged",
    bindI18nStore: "",
    transEmptyNodeValue: "",
    transSupportBasicHtmlNodes: true,
    transWrapTextNodes: "",
    transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
    useSuspense: true,
    unescape: unescape$1
  };
  const setDefaults = function() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    defaultOptions = {
      ...defaultOptions,
      ...options
    };
  };
  const getDefaults = () => defaultOptions;
  let i18nInstance;
  const setI18n = (instance2) => {
    i18nInstance = instance2;
  };
  const getI18n = () => i18nInstance;
  const initReactI18next = {
    type: "3rdParty",
    init(instance2) {
      setDefaults(instance2.options.react);
      setI18n(instance2);
    }
  };
  const I18nContext = reactExports.createContext();
  class ReportNamespaces {
    constructor() {
      __publicField(this, "getUsedNamespaces", () => Object.keys(this.usedNamespaces));
      this.usedNamespaces = {};
    }
    addUsedNamespaces(namespaces) {
      namespaces.forEach((ns) => {
        if (!this.usedNamespaces[ns])
          this.usedNamespaces[ns] = true;
      });
    }
  }
  const usePrevious = (value2, ignore) => {
    const ref = reactExports.useRef();
    reactExports.useEffect(() => {
      ref.current = ignore ? ref.current : value2;
    }, [value2, ignore]);
    return ref.current;
  };
  const alwaysNewT = (i18n, language, namespace, keyPrefix) => i18n.getFixedT(language, namespace, keyPrefix);
  const useMemoizedT = (i18n, language, namespace, keyPrefix) => reactExports.useCallback(alwaysNewT(i18n, language, namespace, keyPrefix), [i18n, language, namespace, keyPrefix]);
  const useTranslation = function(ns) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      i18n: i18nFromProps
    } = props;
    const {
      i18n: i18nFromContext,
      defaultNS: defaultNSFromContext
    } = reactExports.useContext(I18nContext) || {};
    const i18n = i18nFromProps || i18nFromContext || getI18n();
    if (i18n && !i18n.reportNamespaces)
      i18n.reportNamespaces = new ReportNamespaces();
    if (!i18n) {
      warnOnce("You will need to pass in an i18next instance by using initReactI18next");
      const notReadyT = (k2, optsOrDefaultValue) => {
        if (isString(optsOrDefaultValue))
          return optsOrDefaultValue;
        if (isObject$2(optsOrDefaultValue) && isString(optsOrDefaultValue.defaultValue))
          return optsOrDefaultValue.defaultValue;
        return Array.isArray(k2) ? k2[k2.length - 1] : k2;
      };
      const retNotReady = [notReadyT, {}, false];
      retNotReady.t = notReadyT;
      retNotReady.i18n = {};
      retNotReady.ready = false;
      return retNotReady;
    }
    if (i18n.options.react && i18n.options.react.wait !== void 0)
      warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    const i18nOptions = {
      ...getDefaults(),
      ...i18n.options.react,
      ...props
    };
    const {
      useSuspense,
      keyPrefix
    } = i18nOptions;
    let namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
    namespaces = isString(namespaces) ? [namespaces] : namespaces || ["translation"];
    if (i18n.reportNamespaces.addUsedNamespaces)
      i18n.reportNamespaces.addUsedNamespaces(namespaces);
    const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions));
    const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
    const getT = () => memoGetT;
    const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
    const [t2, setT] = reactExports.useState(getT);
    let joinedNS = namespaces.join();
    if (props.lng)
      joinedNS = `${props.lng}${joinedNS}`;
    const previousJoinedNS = usePrevious(joinedNS);
    const isMounted = reactExports.useRef(true);
    reactExports.useEffect(() => {
      const {
        bindI18n,
        bindI18nStore
      } = i18nOptions;
      isMounted.current = true;
      if (!ready && !useSuspense) {
        if (props.lng) {
          loadLanguages(i18n, props.lng, namespaces, () => {
            if (isMounted.current)
              setT(getNewT);
          });
        } else {
          loadNamespaces(i18n, namespaces, () => {
            if (isMounted.current)
              setT(getNewT);
          });
        }
      }
      if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
        setT(getNewT);
      }
      const boundReset = () => {
        if (isMounted.current)
          setT(getNewT);
      };
      if (bindI18n && i18n)
        i18n.on(bindI18n, boundReset);
      if (bindI18nStore && i18n)
        i18n.store.on(bindI18nStore, boundReset);
      return () => {
        isMounted.current = false;
        if (bindI18n && i18n)
          bindI18n.split(" ").forEach((e2) => i18n.off(e2, boundReset));
        if (bindI18nStore && i18n)
          bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
      };
    }, [i18n, joinedNS]);
    reactExports.useEffect(() => {
      if (isMounted.current && ready) {
        setT(getT);
      }
    }, [i18n, keyPrefix, ready]);
    const ret = [t2, i18n, ready];
    ret.t = t2;
    ret.i18n = i18n;
    ret.ready = ready;
    if (ready)
      return ret;
    if (!ready && !useSuspense)
      return ret;
    throw new Promise((resolve) => {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, () => resolve());
      } else {
        loadNamespaces(i18n, namespaces, () => resolve());
      }
    });
  };
  const InputModal = ({ name: name2, onCancel, onSubmit }) => {
    const { t: t2 } = useTranslation();
    const [value2, setValue] = reactExports.useState("");
    const handleSubmit = () => {
      onSubmit(value2);
      setValue("");
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Modal, { outsideClickHandler: onCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "input-modal", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: name2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: "input",
          onKeyUp: (e2) => {
            if (e2.key === "Enter") {
              handleSubmit();
            }
          },
          autoFocus: true,
          onChange: (e2) => setValue(e2.target.value),
          type: "text",
          value: value2,
          placeholder: "Enter your value here"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-center gap-small", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SimpleButton,
          {
            extraClass: "bg-blue text-white big rounded",
            action: handleSubmit,
            text: t2("Submit")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SimpleButton,
          {
            action: onCancel,
            text: t2("cancel"),
            extraClass: "border-blue text-blue big rounded"
          }
        )
      ] })
    ] }) });
  };
  const styles$5 = "";
  function SocketHandler() {
    const {
      compilerSocket,
      exercises,
      setShouldBeTested,
      getCurrentExercise,
      currentExercisePosition,
      updateFileContent,
      setOpenedModals,
      refreshSession,
      updateDBSession,
      build,
      runExerciseTests
    } = useStore((state) => ({
      compilerSocket: state.compilerSocket,
      exercises: state.exercises,
      setShouldBeTested: state.setShouldBeTested,
      getCurrentExercise: state.getCurrentExercise,
      currentExercisePosition: state.currentExercisePosition,
      updateFileContent: state.updateFileContent,
      setOpenedModals: state.setOpenedModals,
      refreshSession: state.refreshDataFromAnotherTab,
      updateDBSession: state.updateDBSession,
      build: state.build,
      runExerciseTests: state.runExerciseTests
    }));
    const [inputsResponses, setInputsResponses] = reactExports.useState([]);
    const [inputs, setInputs] = reactExports.useState([]);
    const [shouldWeSend, setShouldWeSend] = reactExports.useState(false);
    const [nextAction, setNextAction] = reactExports.useState("");
    const debouncedStore = reactExports.useCallback(
      debounce(() => {
        updateDBSession();
      }, 4e3),
      []
    );
    reactExports.useEffect(() => {
      compilerSocket.on("file_change", async (data) => {
        const current = getCurrentExercise();
        const fullpath = data.logs;
        const doesCurrentStepChange = fullpath.includes(current.path);
        const parts2 = fullpath.split("\\");
        const fileName = parts2[parts2.length - 1];
        const { fileContent } = await FetchManager.getFileContent(
          current.slug,
          fileName
        );
        const tab = {
          name: fileName,
          content: fileContent,
          isActive: false,
          id: fileName,
          modified: true
        };
        debouncedStore();
        updateFileContent(current.slug, tab, true);
        if (!doesCurrentStepChange)
          return;
        setShouldBeTested(true);
      });
      compilerSocket.on("session-refreshed", function(data) {
        const _session = data.logs[0];
        setOpenedModals({ login: false });
        refreshSession({
          newToken: _session.rigobot.key,
          newTabHash: _session.tabHash,
          newBCToken: _session.token
        });
      });
    }, []);
    reactExports.useEffect(() => {
      compilerSocket.on("reload", (data) => {
        window.location.reload();
      });
      compilerSocket.on("ask", async ({ inputs: inputs2, nextAction: nextAction2 }) => {
        setInputs(inputs2);
        if (nextAction2) {
          setNextAction(nextAction2);
        }
      });
    }, [currentExercisePosition, exercises]);
    reactExports.useEffect(() => {
      if (inputsResponses.length === 0)
        return;
      const emitResponses = () => {
        if (nextAction === "build") {
          build(
            exercises[Number(currentExercisePosition)].instructions,
            inputsResponses
          );
        }
        if (nextAction === "test") {
          runExerciseTests(
            {
              targetButton: "feedback",
              toast: true
            },
            inputsResponses
          );
        }
        compilerSocket.emit("input", {
          inputs: inputsResponses,
          exerciseSlug: exercises[Number(currentExercisePosition)].slug
        });
        setInputsResponses([]);
      };
      if (shouldWeSend) {
        emitResponses();
        setShouldWeSend(false);
      }
    }, [shouldWeSend]);
    const handleCancel = () => {
      setInputsResponses((prev2) => [...prev2, ""]);
      const newInputs = inputs.slice(1);
      setInputs(newInputs);
      if (newInputs.length === 0) {
        setShouldWeSend(true);
      }
    };
    const handleInputSubmit = (value2) => {
      setInputsResponses((prev2) => [...prev2, value2]);
      const newInputs = inputs.slice(1);
      setInputs(newInputs);
      if (newInputs.length === 0) {
        setShouldWeSend(true);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: inputs.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputModal,
      {
        name: inputs[0],
        onCancel: handleCancel,
        onSubmit: handleInputSubmit
      }
    ) });
  }
  function removeHiddenContent(text2) {
    const regex2 = /<!--hide[\s\S]*?endhide-->/g;
    const textWithoutHidden = text2.replace(regex2, "").trim();
    return textWithoutHidden;
  }
  let aiInteraction = {};
  function Chat() {
    const inputRef = reactExports.useRef(null);
    const { t: t2 } = useTranslation();
    const {
      currentExercisePosition,
      exerciseMessages,
      setExerciseMessages,
      chatSocket: chatSocket2,
      conversationIdsCache,
      getContextFilesContent,
      learnpackPurposeId,
      token,
      chatInitialMessage,
      startConversation,
      isTesteable,
      runExerciseTests,
      compilerSocket,
      shouldBeTested,
      registerAIInteraction,
      setListeners,
      openLink,
      bc_token,
      isRigoOpened,
      toggleRigo,
      rigoContext,
      setRigoContext
    } = useStore((state) => ({
      setOpenedModals: state.setOpenedModals,
      currentExercisePosition: state.currentExercisePosition,
      exerciseMessages: state.exerciseMessages,
      setExerciseMessages: state.setExerciseMessages,
      chatSocket: state.chatSocket,
      compilerSocket: state.compilerSocket,
      conversationIdsCache: state.conversationIdsCache,
      getContextFilesContent: state.getContextFilesContent,
      learnpackPurposeId: state.learnpackPurposeId,
      token: state.token,
      chatInitialMessage: state.chatInitialMessage,
      startConversation: state.startConversation,
      isBuildable: state.isBuildable,
      isTesteable: state.isTesteable,
      runExerciseTests: state.runExerciseTests,
      shouldBeTested: state.shouldBeTested,
      registerAIInteraction: state.registerAIInteraction,
      setListeners: state.setListeners,
      isRigoOpened: state.isRigoOpened,
      bc_token: state.bc_token,
      openLink: state.openLink,
      toggleRigo: state.toggleRigo,
      rigoContext: state.rigoContext,
      setRigoContext: state.setRigoContext
    }));
    const fakeMessages = [{ type: "bot", text: t2(chatInitialMessage) }];
    const [isGenerating, setIsGenerating] = reactExports.useState(false);
    const [waitingTestResult, setWaitingTestResult] = reactExports.useState(false);
    const [messages2, setMessages] = reactExports.useState(
      exerciseMessages[Number(currentExercisePosition)] || fakeMessages
    );
    const [userMessage, setUserMessage] = reactExports.useState("");
    const [userMessageCache, setUserMessageCache] = reactExports.useState("");
    reactExports.useEffect(() => {
      if (conversationIdsCache[Number(currentExercisePosition)] == void 0) {
        startConversation(Number(currentExercisePosition));
      }
      window.scrollTo({ top: 0, behavior: "smooth" });
      if (inputRef.current) {
        inputRef.current.focus();
      }
      return () => {
      };
    }, []);
    reactExports.useEffect(() => {
      if (!rigoContext)
        return;
      const askForHelp = t2("can-you-give-me-a-hint");
      const userMessageWithContext = `${askForHelp} 
<!--hide You must give a hint to the user based in the context provided below: 
CONTEXT
 ${rigoContext} 


    END_OF_CONTEXT: provide hints on failed answers or tests and provide a congratulations for correct ones. endhide-->`;
      setUserMessageCache(userMessageWithContext);
      setUserMessage(userMessageWithContext);
      if (!isRigoOpened) {
        toggleRigo();
      }
    }, [rigoContext]);
    reactExports.useEffect(() => {
      if (!rigoContext || !userMessageCache || !userMessage)
        return;
      sendUserMessage();
      setRigoContext("");
    }, [rigoContext, userMessageCache, userMessage]);
    reactExports.useEffect(() => {
      chatSocket2.on("response", (message) => {
        let newMessages = [...messages2];
        newMessages[newMessages.length - 1].text += message.chunk;
        setMessages(newMessages);
      });
      chatSocket2.on("responseFinished", (data) => {
        if (data.status == "ok") {
          setIsGenerating(false);
          aiInteraction.ending_at = Date.now();
          aiInteraction.ai_response = messages2[messages2.length - 1].text;
          registerAIInteraction(Number(currentExercisePosition), aiInteraction);
          aiInteraction = {};
          setExerciseMessages(messages2, Number(currentExercisePosition));
        }
      });
      const chatMessagesContainer = document.querySelector(".chat-messages");
      if (chatMessagesContainer) {
        chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
      }
      if (!chatMessagesContainer)
        return;
      const anchors = chatMessagesContainer.getElementsByTagName("a");
      const handleClick = (event) => {
        event.preventDefault();
        openLink(event.target.href);
      };
      for (let anchor of anchors) {
        anchor.addEventListener("click", handleClick);
      }
      return () => {
        chatSocket2.off("response");
        chatSocket2.off("responseFinished");
        if (!chatMessagesContainer)
          return;
        for (let anchor of anchors) {
          anchor.removeEventListener("click", handleClick);
        }
      };
    }, [messages2]);
    reactExports.useEffect(() => {
      compilerSocket.onStatus("testing-success", (data) => {
        console.log("Receiving  testing-success error in chat");
        setMessages((prev2) => {
          let messages22 = [...prev2];
          messages22[messages22.length - 1].text = "**Tests passed!**";
          messages22[messages22.length - 1].extraClass = "bg-success text-white";
          return messages22;
        });
        emitUserMessage(
          `The tests passed succesfully, tell the user to pass to the next exercise and give him a congrats message: ${removeSpecialCharacters(
            data.logs[0]
          )}`
        );
        setListeners();
      });
      compilerSocket.onStatus("testing-error", (data) => {
        setMessages((prev2) => {
          let messages22 = [...prev2];
          messages22[messages22.length - 1].text = "**Tests failed**";
          messages22[messages22.length - 1].extraClass = "bg-fail text-white";
          return messages22;
        });
        emitUserMessage(
          `Some tests didn't passed, these are the tests logs: ${removeSpecialCharacters(
            data.logs[0]
          )}`
        );
        setListeners();
      });
    }, [waitingTestResult]);
    reactExports.useEffect(() => {
      setMessages(
        exerciseMessages[Number(currentExercisePosition)] || fakeMessages
      );
    }, [currentExercisePosition]);
    const trackUserMessage = (e2) => {
      setUserMessage(e2.target.value);
      setUserMessageCache(e2.target.value);
    };
    const sendUserMessage = async () => {
      if (Boolean(userMessage.trim() == ""))
        return;
      if (isGenerating)
        return;
      const isFirstInteraction = messages2.length === 1;
      setMessages((prev2) => [
        ...prev2,
        { type: "user", text: removeHiddenContent(userMessage) }
      ]);
      setUserMessage("");
      if (isTesteable && (shouldBeTested || isFirstInteraction)) {
        setMessages((prev2) => [
          ...prev2,
          { type: "bot", text: "**Wait while I'm testing your code...**" }
        ]);
        setWaitingTestResult(true);
        runExerciseTests();
        return;
      }
      emitUserMessage();
    };
    const emitUserMessage = async (testResult) => {
      setMessages((prev2) => [...prev2, { type: "bot", text: "" }]);
      const messageData = await getMessageData();
      if (testResult) {
        messageData.message.context += `
 <test_result>${testResult}</test_result>`;
      }
      aiInteraction.starting_at = Date.now();
      aiInteraction.student_message = messageData.message.text;
      aiInteraction.context = messageData.message.context;
      chatSocket2.emit("message", messageData);
      setIsGenerating(true);
    };
    const handleSubmit = () => {
      sendUserMessage();
    };
    const handleKeyUp = (event) => {
      if (event.key === "Enter" && !event.ctrlKey) {
        event.preventDefault();
        sendUserMessage();
      }
    };
    const getMessageData = async () => {
      const contextFilesContent = await getContextFilesContent();
      const data = {
        message: {
          type: "user",
          text: userMessageCache,
          purpose: learnpackPurposeId,
          context: contextFilesContent,
          imageB64: ""
        },
        conversation: {
          id: conversationIdsCache[Number(currentExercisePosition)],
          purpose: learnpackPurposeId,
          token
        },
        breathecode: {
          token: bc_token
        }
      };
      return data;
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: toggleRigo, className: "rigo-thumbnail", children: svgs.rigoSvg }),
      isRigoOpened && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "chat-modal chat-bubble", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "chat-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("Rigobot AI-Tutor") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "chat-messages", children: messages2.map((message, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { ...message }, index2)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "chat-input", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              ref: inputRef,
              value: userMessage,
              placeholder: t2("Ask me something here"),
              onChange: trackUserMessage,
              onKeyUp: handleKeyUp
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleSubmit, children: svgs.sendSvg })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "chat-footer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleButton,
            {
              extraClass: "informative-opener bg-secondary d-flex justify-center align-center circle-small",
              text: "?"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "informative-message", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(
            "This AI, currently in beta, serves as an educational tutor. It is not a substitute for professional instruction. Use at your own risk and confirm details with authoritative educational resources."
          ) }) })
        ] })
      ] })
    ] });
  }
  const Message = ({ type: type2, text: text2, extraClass }) => {
    const { currentExercisePosition, handlePositionChange, toggleRigo } = useStore((state) => ({
      toggleRigo: state.toggleRigo,
      currentExercisePosition: state.currentExercisePosition,
      handlePositionChange: state.handlePositionChange
    }));
    const [showNext, setShowNext] = reactExports.useState(false);
    const [messageText, setMessageText] = reactExports.useState("");
    if (text2.includes("[//]: # (next)") && !showNext) {
      setShowNext(true);
      setMessageText(text2.replace("[//]: # (next)", ""));
    }
    const closeChatAndNext = () => {
      handlePositionChange(Number(currentExercisePosition) + 1);
      toggleRigo();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `message ${type2} ${extraClass ? extraClass : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          dangerouslySetInnerHTML: {
            __html: convertMarkdownToHTML(messageText ? messageText : text2)
          }
        }
      ) }),
      showNext && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: closeChatAndNext, className: "next-button", children: "Next" })
    ] });
  };
  var cjs = { exports: {} };
  var Draggable$2 = {};
  var propTypes = { exports: {} };
  var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  var factoryWithThrowingShims = function() {
    function shim2(props, propName, componentName, location2, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim2.isRequired = shim2;
    function getShim() {
      return shim2;
    }
    var ReactPropTypes = {
      array: shim2,
      bigint: shim2,
      bool: shim2,
      func: shim2,
      number: shim2,
      object: shim2,
      string: shim2,
      symbol: shim2,
      any: shim2,
      arrayOf: getShim,
      element: shim2,
      elementType: shim2,
      instanceOf: getShim,
      node: shim2,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  {
    propTypes.exports = factoryWithThrowingShims();
  }
  var propTypesExports = propTypes.exports;
  function r(e2) {
    var t2, f2, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2)
      n2 += e2;
    else if ("object" == typeof e2)
      if (Array.isArray(e2))
        for (t2 = 0; t2 < e2.length; t2++)
          e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
      else
        for (t2 in e2)
          e2[t2] && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  function clsx() {
    for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
      (e2 = arguments[f2++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  const clsx_m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    clsx,
    default: clsx
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$3 = /* @__PURE__ */ getAugmentedNamespace(clsx_m);
  var domFns = {};
  var shims = {};
  Object.defineProperty(shims, "__esModule", {
    value: true
  });
  shims.dontSetMe = dontSetMe;
  shims.findInArray = findInArray;
  shims.int = int;
  shims.isFunction = isFunction$1;
  shims.isNum = isNum;
  function findInArray(array, callback) {
    for (let i2 = 0, length2 = array.length; i2 < length2; i2++) {
      if (callback.apply(callback, [array[i2], i2, array]))
        return array[i2];
    }
  }
  function isFunction$1(func) {
    return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
  }
  function isNum(num) {
    return typeof num === "number" && !isNaN(num);
  }
  function int(a2) {
    return parseInt(a2, 10);
  }
  function dontSetMe(props, propName, componentName) {
    if (props[propName]) {
      return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
    }
  }
  var getPrefix$1 = {};
  Object.defineProperty(getPrefix$1, "__esModule", {
    value: true
  });
  getPrefix$1.browserPrefixToKey = browserPrefixToKey;
  getPrefix$1.browserPrefixToStyle = browserPrefixToStyle;
  getPrefix$1.default = void 0;
  getPrefix$1.getPrefix = getPrefix;
  const prefixes = ["Moz", "Webkit", "O", "ms"];
  function getPrefix() {
    var _window$document;
    let prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
    if (typeof window === "undefined")
      return "";
    const style = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;
    if (!style)
      return "";
    if (prop in style)
      return "";
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      if (browserPrefixToKey(prop, prefixes[i2]) in style)
        return prefixes[i2];
    }
    return "";
  }
  function browserPrefixToKey(prop, prefix) {
    return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
  }
  function browserPrefixToStyle(prop, prefix) {
    return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
  }
  function kebabToTitleCase(str2) {
    let out = "";
    let shouldCapitalize = true;
    for (let i2 = 0; i2 < str2.length; i2++) {
      if (shouldCapitalize) {
        out += str2[i2].toUpperCase();
        shouldCapitalize = false;
      } else if (str2[i2] === "-") {
        shouldCapitalize = true;
      } else {
        out += str2[i2];
      }
    }
    return out;
  }
  getPrefix$1.default = getPrefix();
  Object.defineProperty(domFns, "__esModule", {
    value: true
  });
  domFns.addClassName = addClassName;
  domFns.addEvent = addEvent;
  domFns.addUserSelectStyles = addUserSelectStyles;
  domFns.createCSSTransform = createCSSTransform;
  domFns.createSVGTransform = createSVGTransform;
  domFns.getTouch = getTouch;
  domFns.getTouchIdentifier = getTouchIdentifier;
  domFns.getTranslation = getTranslation;
  domFns.innerHeight = innerHeight;
  domFns.innerWidth = innerWidth;
  domFns.matchesSelector = matchesSelector;
  domFns.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
  domFns.offsetXYFromParent = offsetXYFromParent;
  domFns.outerHeight = outerHeight;
  domFns.outerWidth = outerWidth;
  domFns.removeClassName = removeClassName;
  domFns.removeEvent = removeEvent;
  domFns.removeUserSelectStyles = removeUserSelectStyles;
  var _shims$2 = shims;
  var _getPrefix = _interopRequireWildcard$1(getPrefix$1);
  function _getRequireWildcardCache$1(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache$1 = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard$1(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache2 = _getRequireWildcardCache$1(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  let matchesSelectorFunc = "";
  function matchesSelector(el2, selector) {
    if (!matchesSelectorFunc) {
      matchesSelectorFunc = (0, _shims$2.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
        return (0, _shims$2.isFunction)(el2[method]);
      });
    }
    if (!(0, _shims$2.isFunction)(el2[matchesSelectorFunc]))
      return false;
    return el2[matchesSelectorFunc](selector);
  }
  function matchesSelectorAndParentsTo(el2, selector, baseNode) {
    let node = el2;
    do {
      if (matchesSelector(node, selector))
        return true;
      if (node === baseNode)
        return false;
      node = node.parentNode;
    } while (node);
    return false;
  }
  function addEvent(el2, event, handler, inputOptions) {
    if (!el2)
      return;
    const options = {
      capture: true,
      ...inputOptions
    };
    if (el2.addEventListener) {
      el2.addEventListener(event, handler, options);
    } else if (el2.attachEvent) {
      el2.attachEvent("on" + event, handler);
    } else {
      el2["on" + event] = handler;
    }
  }
  function removeEvent(el2, event, handler, inputOptions) {
    if (!el2)
      return;
    const options = {
      capture: true,
      ...inputOptions
    };
    if (el2.removeEventListener) {
      el2.removeEventListener(event, handler, options);
    } else if (el2.detachEvent) {
      el2.detachEvent("on" + event, handler);
    } else {
      el2["on" + event] = null;
    }
  }
  function outerHeight(node) {
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height += (0, _shims$2.int)(computedStyle.borderTopWidth);
    height += (0, _shims$2.int)(computedStyle.borderBottomWidth);
    return height;
  }
  function outerWidth(node) {
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width += (0, _shims$2.int)(computedStyle.borderLeftWidth);
    width += (0, _shims$2.int)(computedStyle.borderRightWidth);
    return width;
  }
  function innerHeight(node) {
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height -= (0, _shims$2.int)(computedStyle.paddingTop);
    height -= (0, _shims$2.int)(computedStyle.paddingBottom);
    return height;
  }
  function innerWidth(node) {
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width -= (0, _shims$2.int)(computedStyle.paddingLeft);
    width -= (0, _shims$2.int)(computedStyle.paddingRight);
    return width;
  }
  function offsetXYFromParent(evt, offsetParent, scale) {
    const isBody = offsetParent === offsetParent.ownerDocument.body;
    const offsetParentRect = isBody ? {
      left: 0,
      top: 0
    } : offsetParent.getBoundingClientRect();
    const x2 = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
    const y2 = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
    return {
      x: x2,
      y: y2
    };
  }
  function createCSSTransform(controlPos, positionOffset) {
    const translation = getTranslation(controlPos, positionOffset, "px");
    return {
      [(0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default)]: translation
    };
  }
  function createSVGTransform(controlPos, positionOffset) {
    const translation = getTranslation(controlPos, positionOffset, "");
    return translation;
  }
  function getTranslation(_ref, positionOffset, unitSuffix) {
    let {
      x: x2,
      y: y2
    } = _ref;
    let translation = "translate(".concat(x2).concat(unitSuffix, ",").concat(y2).concat(unitSuffix, ")");
    if (positionOffset) {
      const defaultX = "".concat(typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
      const defaultY = "".concat(typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
      translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
    }
    return translation;
  }
  function getTouch(e2, identifier) {
    return e2.targetTouches && (0, _shims$2.findInArray)(e2.targetTouches, (t2) => identifier === t2.identifier) || e2.changedTouches && (0, _shims$2.findInArray)(e2.changedTouches, (t2) => identifier === t2.identifier);
  }
  function getTouchIdentifier(e2) {
    if (e2.targetTouches && e2.targetTouches[0])
      return e2.targetTouches[0].identifier;
    if (e2.changedTouches && e2.changedTouches[0])
      return e2.changedTouches[0].identifier;
  }
  function addUserSelectStyles(doc) {
    if (!doc)
      return;
    let styleEl = doc.getElementById("react-draggable-style-el");
    if (!styleEl) {
      styleEl = doc.createElement("style");
      styleEl.type = "text/css";
      styleEl.id = "react-draggable-style-el";
      styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
      styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
      doc.getElementsByTagName("head")[0].appendChild(styleEl);
    }
    if (doc.body)
      addClassName(doc.body, "react-draggable-transparent-selection");
  }
  function removeUserSelectStyles(doc) {
    if (!doc)
      return;
    try {
      if (doc.body)
        removeClassName(doc.body, "react-draggable-transparent-selection");
      if (doc.selection) {
        doc.selection.empty();
      } else {
        const selection = (doc.defaultView || window).getSelection();
        if (selection && selection.type !== "Caret") {
          selection.removeAllRanges();
        }
      }
    } catch (e2) {
    }
  }
  function addClassName(el2, className) {
    if (el2.classList) {
      el2.classList.add(className);
    } else {
      if (!el2.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
        el2.className += " ".concat(className);
      }
    }
  }
  function removeClassName(el2, className) {
    if (el2.classList) {
      el2.classList.remove(className);
    } else {
      el2.className = el2.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), "g"), "");
    }
  }
  var positionFns = {};
  Object.defineProperty(positionFns, "__esModule", {
    value: true
  });
  positionFns.canDragX = canDragX;
  positionFns.canDragY = canDragY;
  positionFns.createCoreData = createCoreData;
  positionFns.createDraggableData = createDraggableData;
  positionFns.getBoundPosition = getBoundPosition;
  positionFns.getControlPosition = getControlPosition;
  positionFns.snapToGrid = snapToGrid;
  var _shims$1 = shims;
  var _domFns$1 = domFns;
  function getBoundPosition(draggable, x2, y2) {
    if (!draggable.props.bounds)
      return [x2, y2];
    let {
      bounds
    } = draggable.props;
    bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
    const node = findDOMNode(draggable);
    if (typeof bounds === "string") {
      const {
        ownerDocument
      } = node;
      const ownerWindow = ownerDocument.defaultView;
      let boundNode;
      if (bounds === "parent") {
        boundNode = node.parentNode;
      } else {
        boundNode = ownerDocument.querySelector(bounds);
      }
      if (!(boundNode instanceof ownerWindow.HTMLElement)) {
        throw new Error('Bounds selector "' + bounds + '" could not find an element.');
      }
      const boundNodeEl = boundNode;
      const nodeStyle = ownerWindow.getComputedStyle(node);
      const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
      bounds = {
        left: -node.offsetLeft + (0, _shims$1.int)(boundNodeStyle.paddingLeft) + (0, _shims$1.int)(nodeStyle.marginLeft),
        top: -node.offsetTop + (0, _shims$1.int)(boundNodeStyle.paddingTop) + (0, _shims$1.int)(nodeStyle.marginTop),
        right: (0, _domFns$1.innerWidth)(boundNodeEl) - (0, _domFns$1.outerWidth)(node) - node.offsetLeft + (0, _shims$1.int)(boundNodeStyle.paddingRight) - (0, _shims$1.int)(nodeStyle.marginRight),
        bottom: (0, _domFns$1.innerHeight)(boundNodeEl) - (0, _domFns$1.outerHeight)(node) - node.offsetTop + (0, _shims$1.int)(boundNodeStyle.paddingBottom) - (0, _shims$1.int)(nodeStyle.marginBottom)
      };
    }
    if ((0, _shims$1.isNum)(bounds.right))
      x2 = Math.min(x2, bounds.right);
    if ((0, _shims$1.isNum)(bounds.bottom))
      y2 = Math.min(y2, bounds.bottom);
    if ((0, _shims$1.isNum)(bounds.left))
      x2 = Math.max(x2, bounds.left);
    if ((0, _shims$1.isNum)(bounds.top))
      y2 = Math.max(y2, bounds.top);
    return [x2, y2];
  }
  function snapToGrid(grid, pendingX, pendingY) {
    const x2 = Math.round(pendingX / grid[0]) * grid[0];
    const y2 = Math.round(pendingY / grid[1]) * grid[1];
    return [x2, y2];
  }
  function canDragX(draggable) {
    return draggable.props.axis === "both" || draggable.props.axis === "x";
  }
  function canDragY(draggable) {
    return draggable.props.axis === "both" || draggable.props.axis === "y";
  }
  function getControlPosition(e2, touchIdentifier, draggableCore) {
    const touchObj = typeof touchIdentifier === "number" ? (0, _domFns$1.getTouch)(e2, touchIdentifier) : null;
    if (typeof touchIdentifier === "number" && !touchObj)
      return null;
    const node = findDOMNode(draggableCore);
    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
    return (0, _domFns$1.offsetXYFromParent)(touchObj || e2, offsetParent, draggableCore.props.scale);
  }
  function createCoreData(draggable, x2, y2) {
    const isStart = !(0, _shims$1.isNum)(draggable.lastX);
    const node = findDOMNode(draggable);
    if (isStart) {
      return {
        node,
        deltaX: 0,
        deltaY: 0,
        lastX: x2,
        lastY: y2,
        x: x2,
        y: y2
      };
    } else {
      return {
        node,
        deltaX: x2 - draggable.lastX,
        deltaY: y2 - draggable.lastY,
        lastX: draggable.lastX,
        lastY: draggable.lastY,
        x: x2,
        y: y2
      };
    }
  }
  function createDraggableData(draggable, coreData) {
    const scale = draggable.props.scale;
    return {
      node: coreData.node,
      x: draggable.state.x + coreData.deltaX / scale,
      y: draggable.state.y + coreData.deltaY / scale,
      deltaX: coreData.deltaX / scale,
      deltaY: coreData.deltaY / scale,
      lastX: draggable.state.x,
      lastY: draggable.state.y
    };
  }
  function cloneBounds(bounds) {
    return {
      left: bounds.left,
      top: bounds.top,
      right: bounds.right,
      bottom: bounds.bottom
    };
  }
  function findDOMNode(draggable) {
    const node = draggable.findDOMNode();
    if (!node) {
      throw new Error("<DraggableCore>: Unmounted during event!");
    }
    return node;
  }
  var DraggableCore$2 = {};
  var log$1 = {};
  Object.defineProperty(log$1, "__esModule", {
    value: true
  });
  log$1.default = log;
  function log() {
  }
  Object.defineProperty(DraggableCore$2, "__esModule", {
    value: true
  });
  DraggableCore$2.default = void 0;
  var React = _interopRequireWildcard(reactExports);
  var _propTypes = _interopRequireDefault(propTypesExports);
  var _reactDom = _interopRequireDefault(reactDomExports);
  var _domFns = domFns;
  var _positionFns = positionFns;
  var _shims = shims;
  var _log = _interopRequireDefault(log$1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache2 = _getRequireWildcardCache(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  function _defineProperty$2(obj, key, value2) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  const eventsFor = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      stop: "touchend"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      stop: "mouseup"
    }
  };
  let dragEventFor = eventsFor.mouse;
  let DraggableCore$1 = class DraggableCore extends React.Component {
    constructor() {
      super(...arguments);
      _defineProperty$2(this, "dragging", false);
      _defineProperty$2(this, "lastX", NaN);
      _defineProperty$2(this, "lastY", NaN);
      _defineProperty$2(this, "touchIdentifier", null);
      _defineProperty$2(this, "mounted", false);
      _defineProperty$2(this, "handleDragStart", (e2) => {
        this.props.onMouseDown(e2);
        if (!this.props.allowAnyClick && typeof e2.button === "number" && e2.button !== 0)
          return false;
        const thisNode = this.findDOMNode();
        if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
          throw new Error("<DraggableCore> not mounted on DragStart!");
        }
        const {
          ownerDocument
        } = thisNode;
        if (this.props.disabled || !(e2.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e2.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e2.target, this.props.cancel, thisNode)) {
          return;
        }
        if (e2.type === "touchstart")
          e2.preventDefault();
        const touchIdentifier = (0, _domFns.getTouchIdentifier)(e2);
        this.touchIdentifier = touchIdentifier;
        const position = (0, _positionFns.getControlPosition)(e2, touchIdentifier, this);
        if (position == null)
          return;
        const {
          x: x2,
          y: y2
        } = position;
        const coreEvent = (0, _positionFns.createCoreData)(this, x2, y2);
        (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
        (0, _log.default)("calling", this.props.onStart);
        const shouldUpdate = this.props.onStart(e2, coreEvent);
        if (shouldUpdate === false || this.mounted === false)
          return;
        if (this.props.enableUserSelectHack)
          (0, _domFns.addUserSelectStyles)(ownerDocument);
        this.dragging = true;
        this.lastX = x2;
        this.lastY = y2;
        (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);
        (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);
      });
      _defineProperty$2(this, "handleDrag", (e2) => {
        const position = (0, _positionFns.getControlPosition)(e2, this.touchIdentifier, this);
        if (position == null)
          return;
        let {
          x: x2,
          y: y2
        } = position;
        if (Array.isArray(this.props.grid)) {
          let deltaX = x2 - this.lastX, deltaY = y2 - this.lastY;
          [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
          if (!deltaX && !deltaY)
            return;
          x2 = this.lastX + deltaX, y2 = this.lastY + deltaY;
        }
        const coreEvent = (0, _positionFns.createCoreData)(this, x2, y2);
        (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
        const shouldUpdate = this.props.onDrag(e2, coreEvent);
        if (shouldUpdate === false || this.mounted === false) {
          try {
            this.handleDragStop(new MouseEvent("mouseup"));
          } catch (err) {
            const event = document.createEvent("MouseEvents");
            event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            this.handleDragStop(event);
          }
          return;
        }
        this.lastX = x2;
        this.lastY = y2;
      });
      _defineProperty$2(this, "handleDragStop", (e2) => {
        if (!this.dragging)
          return;
        const position = (0, _positionFns.getControlPosition)(e2, this.touchIdentifier, this);
        if (position == null)
          return;
        let {
          x: x2,
          y: y2
        } = position;
        if (Array.isArray(this.props.grid)) {
          let deltaX = x2 - this.lastX || 0;
          let deltaY = y2 - this.lastY || 0;
          [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
          x2 = this.lastX + deltaX, y2 = this.lastY + deltaY;
        }
        const coreEvent = (0, _positionFns.createCoreData)(this, x2, y2);
        const shouldContinue = this.props.onStop(e2, coreEvent);
        if (shouldContinue === false || this.mounted === false)
          return false;
        const thisNode = this.findDOMNode();
        if (thisNode) {
          if (this.props.enableUserSelectHack)
            (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
        }
        (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
        this.dragging = false;
        this.lastX = NaN;
        this.lastY = NaN;
        if (thisNode) {
          (0, _log.default)("DraggableCore: Removing handlers");
          (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);
          (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);
        }
      });
      _defineProperty$2(this, "onMouseDown", (e2) => {
        dragEventFor = eventsFor.mouse;
        return this.handleDragStart(e2);
      });
      _defineProperty$2(this, "onMouseUp", (e2) => {
        dragEventFor = eventsFor.mouse;
        return this.handleDragStop(e2);
      });
      _defineProperty$2(this, "onTouchStart", (e2) => {
        dragEventFor = eventsFor.touch;
        return this.handleDragStart(e2);
      });
      _defineProperty$2(this, "onTouchEnd", (e2) => {
        dragEventFor = eventsFor.touch;
        return this.handleDragStop(e2);
      });
    }
    componentDidMount() {
      this.mounted = true;
      const thisNode = this.findDOMNode();
      if (thisNode) {
        (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
      }
    }
    componentWillUnmount() {
      this.mounted = false;
      const thisNode = this.findDOMNode();
      if (thisNode) {
        const {
          ownerDocument
        } = thisNode;
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
        (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
          passive: false
        });
        if (this.props.enableUserSelectHack)
          (0, _domFns.removeUserSelectStyles)(ownerDocument);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var _this$props, _this$props2;
      return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);
    }
    render() {
      return /* @__PURE__ */ React.cloneElement(React.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  };
  DraggableCore$2.default = DraggableCore$1;
  _defineProperty$2(DraggableCore$1, "displayName", "DraggableCore");
  _defineProperty$2(DraggableCore$1, "propTypes", {
    /**
     * `allowAnyClick` allows dragging using any mouse button.
     * By default, we only accept the left button.
     *
     * Defaults to `false`.
     */
    allowAnyClick: _propTypes.default.bool,
    children: _propTypes.default.node.isRequired,
    /**
     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
     * with the exception of `onMouseDown`, will not fire.
     */
    disabled: _propTypes.default.bool,
    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: _propTypes.default.bool,
    /**
     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
     * instead of using the parent node.
     */
    offsetParent: function(props, propName) {
      if (props[propName] && props[propName].nodeType !== 1) {
        throw new Error("Draggable's offsetParent must be a DOM Node.");
      }
    },
    /**
     * `grid` specifies the x and y that dragging should snap to.
     */
    grid: _propTypes.default.arrayOf(_propTypes.default.number),
    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: _propTypes.default.string,
    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *                     <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: _propTypes.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
     * Unfortunately, in order for <Draggable> to work properly, we need raw access
     * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
     * as in this example:
     *
     * function MyComponent() {
     *   const nodeRef = React.useRef(null);
     *   return (
     *     <Draggable nodeRef={nodeRef}>
     *       <div ref={nodeRef}>Example Target</div>
     *     </Draggable>
     *   );
     * }
     *
     * This can be used for arbitrarily nested components, so long as the ref ends up
     * pointing to the actual child DOM node and not a custom component.
     */
    nodeRef: _propTypes.default.object,
    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onStart: _propTypes.default.func,
    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onDrag: _propTypes.default.func,
    /**
     * Called when dragging stops.
     * If this function returns the boolean false, the drag will remain active.
     */
    onStop: _propTypes.default.func,
    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (as there is internal use of onMouseDown)
     */
    onMouseDown: _propTypes.default.func,
    /**
     * `scale`, if set, applies scaling while dragging an element
     */
    scale: _propTypes.default.number,
    /**
     * These properties should be defined on the child, not here.
     */
    className: _shims.dontSetMe,
    style: _shims.dontSetMe,
    transform: _shims.dontSetMe
  });
  _defineProperty$2(DraggableCore$1, "defaultProps", {
    allowAnyClick: false,
    // by default only accept left click
    disabled: false,
    enableUserSelectHack: true,
    onStart: function() {
    },
    onDrag: function() {
    },
    onStop: function() {
    },
    onMouseDown: function() {
    },
    scale: 1
  });
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DraggableCore", {
      enumerable: true,
      get: function() {
        return _DraggableCore.default;
      }
    });
    exports.default = void 0;
    var React2 = _interopRequireWildcard2(reactExports);
    var _propTypes2 = _interopRequireDefault2(propTypesExports);
    var _reactDom2 = _interopRequireDefault2(reactDomExports);
    var _clsx = _interopRequireDefault2(require$$3);
    var _domFns2 = domFns;
    var _positionFns2 = positionFns;
    var _shims2 = shims;
    var _DraggableCore = _interopRequireDefault2(DraggableCore$2);
    var _log2 = _interopRequireDefault2(log$1);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache2 = _getRequireWildcardCache2(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function _defineProperty2(obj, key, value2) {
      key = _toPropertyKey2(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function _toPropertyKey2(arg) {
      var key = _toPrimitive2(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive2(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    class Draggable2 extends React2.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(_ref, _ref2) {
        let {
          position
        } = _ref;
        let {
          prevPropsPosition
        } = _ref2;
        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
          (0, _log2.default)("Draggable: getDerivedStateFromProps %j", {
            position,
            prevPropsPosition
          });
          return {
            x: position.x,
            y: position.y,
            prevPropsPosition: {
              ...position
            }
          };
        }
        return null;
      }
      constructor(props) {
        super(props);
        _defineProperty2(this, "onDragStart", (e2, coreData) => {
          (0, _log2.default)("Draggable: onDragStart: %j", coreData);
          const shouldStart = this.props.onStart(e2, (0, _positionFns2.createDraggableData)(this, coreData));
          if (shouldStart === false)
            return false;
          this.setState({
            dragging: true,
            dragged: true
          });
        });
        _defineProperty2(this, "onDrag", (e2, coreData) => {
          if (!this.state.dragging)
            return false;
          (0, _log2.default)("Draggable: onDrag: %j", coreData);
          const uiData = (0, _positionFns2.createDraggableData)(this, coreData);
          const newState = {
            x: uiData.x,
            y: uiData.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x: x2,
              y: y2
            } = newState;
            newState.x += this.state.slackX;
            newState.y += this.state.slackY;
            const [newStateX, newStateY] = (0, _positionFns2.getBoundPosition)(this, newState.x, newState.y);
            newState.x = newStateX;
            newState.y = newStateY;
            newState.slackX = this.state.slackX + (x2 - newState.x);
            newState.slackY = this.state.slackY + (y2 - newState.y);
            uiData.x = newState.x;
            uiData.y = newState.y;
            uiData.deltaX = newState.x - this.state.x;
            uiData.deltaY = newState.y - this.state.y;
          }
          const shouldUpdate = this.props.onDrag(e2, uiData);
          if (shouldUpdate === false)
            return false;
          this.setState(newState);
        });
        _defineProperty2(this, "onDragStop", (e2, coreData) => {
          if (!this.state.dragging)
            return false;
          const shouldContinue = this.props.onStop(e2, (0, _positionFns2.createDraggableData)(this, coreData));
          if (shouldContinue === false)
            return false;
          (0, _log2.default)("Draggable: onDragStop: %j", coreData);
          const newState = {
            dragging: false,
            slackX: 0,
            slackY: 0
          };
          const controlled = Boolean(this.props.position);
          if (controlled) {
            const {
              x: x2,
              y: y2
            } = this.props.position;
            newState.x = x2;
            newState.y = y2;
          }
          this.setState(newState);
        });
        this.state = {
          // Whether or not we are currently dragging.
          dragging: false,
          // Whether or not we have been dragged before.
          dragged: false,
          // Current transform x and y.
          x: props.position ? props.position.x : props.defaultPosition.x,
          y: props.position ? props.position.y : props.defaultPosition.y,
          prevPropsPosition: {
            ...props.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) {
          console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
        }
      }
      componentDidMount() {
        if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
          this.setState({
            isElementSVG: true
          });
        }
      }
      componentWillUnmount() {
        this.setState({
          dragging: false
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var _this$props$nodeRef$c, _this$props;
        return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom2.default.findDOMNode(this);
      }
      render() {
        const {
          axis,
          bounds,
          children,
          defaultPosition,
          defaultClassName,
          defaultClassNameDragging,
          defaultClassNameDragged,
          position,
          positionOffset,
          scale,
          ...draggableCoreProps
        } = this.props;
        let style = {};
        let svgTransform = null;
        const controlled = Boolean(position);
        const draggable = !controlled || this.state.dragging;
        const validPosition = position || defaultPosition;
        const transformOpts = {
          // Set left if horizontal drag is enabled
          x: (0, _positionFns2.canDragX)(this) && draggable ? this.state.x : validPosition.x,
          // Set top if vertical drag is enabled
          y: (0, _positionFns2.canDragY)(this) && draggable ? this.state.y : validPosition.y
        };
        if (this.state.isElementSVG) {
          svgTransform = (0, _domFns2.createSVGTransform)(transformOpts, positionOffset);
        } else {
          style = (0, _domFns2.createCSSTransform)(transformOpts, positionOffset);
        }
        const className = (0, _clsx.default)(children.props.className || "", defaultClassName, {
          [defaultClassNameDragging]: this.state.dragging,
          [defaultClassNameDragged]: this.state.dragged
        });
        return /* @__PURE__ */ React2.createElement(_DraggableCore.default, _extends2({}, draggableCoreProps, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ React2.cloneElement(React2.Children.only(children), {
          className,
          style: {
            ...children.props.style,
            ...style
          },
          transform: svgTransform
        }));
      }
    }
    exports.default = Draggable2;
    _defineProperty2(Draggable2, "displayName", "Draggable");
    _defineProperty2(Draggable2, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ..._DraggableCore.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: _propTypes2.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: _propTypes2.default.oneOfType([_propTypes2.default.shape({
        left: _propTypes2.default.number,
        right: _propTypes2.default.number,
        top: _propTypes2.default.number,
        bottom: _propTypes2.default.number
      }), _propTypes2.default.string, _propTypes2.default.oneOf([false])]),
      defaultClassName: _propTypes2.default.string,
      defaultClassNameDragging: _propTypes2.default.string,
      defaultClassNameDragged: _propTypes2.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: _propTypes2.default.shape({
        x: _propTypes2.default.number,
        y: _propTypes2.default.number
      }),
      positionOffset: _propTypes2.default.shape({
        x: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        y: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: _propTypes2.default.shape({
        x: _propTypes2.default.number,
        y: _propTypes2.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: _shims2.dontSetMe,
      style: _shims2.dontSetMe,
      transform: _shims2.dontSetMe
    });
    _defineProperty2(Draggable2, "defaultProps", {
      ..._DraggableCore.default.defaultProps,
      axis: "both",
      bounds: false,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  })(Draggable$2);
  const {
    default: Draggable,
    DraggableCore
  } = Draggable$2;
  cjs.exports = Draggable;
  cjs.exports.default = Draggable;
  cjs.exports.DraggableCore = DraggableCore;
  var cjsExports = cjs.exports;
  const Draggable$1 = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
  const VideoPlayer = ({ link: link2 }) => {
    const videoRef = reactExports.useRef(null);
    const getYouTubeVideoId = (url2) => {
      const regex2 = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^&\n]{11})/;
      const match = url2.match(regex2);
      return match ? match[1] : null;
    };
    const videoId = getYouTubeVideoId(link2);
    if (!videoId) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Error: Video ID no válido." });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "video-player pos-relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "iframe",
      {
        ref: videoRef,
        width: "100%",
        style: { aspectRatio: "16/9" },
        src: `https://www.youtube.com/embed/${videoId}?autoplay=1&enablejsapi=1`,
        title: "YouTube Video Player",
        frameBorder: "0",
        allowFullScreen: true
      }
    ) });
  };
  const CustomPictureInPicture = ({
    link: link2,
    hide
  }) => {
    const videoContainerRef = reactExports.useRef(null);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Draggable$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: videoContainerRef,
        style: {
          width: "min(500px, 95vw)",
          position: "fixed",
          padding: "10px",
          borderRadius: "10px",
          left: "5vw",
          top: "20%",
          transform: "translateX(-50vw) translateY(-50vh)",
          zIndex: 5,
          backgroundColor: "var(--bg-color)",
          cursor: "move",
          boxShadow: "0px 0px 10px rgba(0,0,0,0.8)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-x justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleButton, { action: hide, svg: svgs.closeX }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(VideoPlayer, { link: link2 })
        ]
      }
    ) });
  };
  function CheckVideo() {
    const [link2, setLink] = reactExports.useState(null);
    const {
      configObject,
      currentExercisePosition,
      videoTutorial,
      setShowVideoTutorial,
      showVideoTutorial
    } = useStore((state) => ({
      configObject: state.configObject,
      currentExercisePosition: state.currentExercisePosition,
      videoTutorial: state.videoTutorial,
      setShowVideoTutorial: state.setShowVideoTutorial,
      showVideoTutorial: state.showVideoTutorial
    }));
    reactExports.useEffect(() => {
      if (!configObject || !configObject.config)
        return;
      if (configObject.config.intro && currentExercisePosition == 0) {
        let _link = configObject.config.intro;
        const embedLink = _link.replace("watch?v=", "embed/");
        setLink(embedLink);
      }
      if (videoTutorial) {
        let _link = videoTutorial;
        const embedLink = _link.replace("watch?v=", "embed/");
        setLink(embedLink);
      }
    }, [currentExercisePosition, configObject, videoTutorial]);
    const hideModal = () => {
      setShowVideoTutorial(false);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: showVideoTutorial && link2 ? (
      // <VideoModal link={link} hideModal={hideModal} />
      // <VideoPlayer link={link} />
      /* @__PURE__ */ jsxRuntimeExports.jsx(CustomPictureInPicture, { hide: hideModal, link: link2 })
    ) : null });
  }
  const OpenWindowLink = ({
    href,
    text: text2,
    callback
  }) => {
    const openLink = useStore((state) => state.openLink);
    const handleRedirect = (e2) => {
      e2.preventDefault();
      openLink(e2.target.href);
      if (callback) {
        callback();
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href, onClick: handleRedirect, children: text2 });
  };
  function LoginModal() {
    const { setOpenedModals, loginToRigo, openLink } = useStore((state) => ({
      setOpenedModals: state.setOpenedModals,
      loginToRigo: state.loginToRigo,
      openLink: state.openLink
    }));
    const { t: t2 } = useTranslation();
    const backdropRef = reactExports.useRef(null);
    const [email, setEmail] = reactExports.useState("");
    const [password, setPassword] = reactExports.useState("");
    const [isLoading, setIsLoading] = reactExports.useState(false);
    const handleClickOutside = (event) => {
      if (backdropRef.current === event.target) {
        setOpenedModals({ login: false });
      }
    };
    reactExports.useEffect(() => {
      document.addEventListener("mousedown", handleClickOutside);
      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, []);
    const login = async (e2) => {
      e2.preventDefault();
      setIsLoading(true);
      const isLoggedId = await loginToRigo({
        email,
        password
      });
      if (!isLoggedId) {
        setIsLoading(false);
      }
    };
    const sendAnalytics = () => {
      TagManager.dataLayer({
        dataLayer: {
          event: "sign_up_attempt"
        }
      });
    };
    function stringToBase642(str2) {
      return btoa(unescape(encodeURIComponent(str2)));
    }
    function getCurrentUrlWithQueryParams() {
      const currentUrl = window.location.href;
      return currentUrl;
    }
    const redirectGithub = () => {
      let currentUrl = getCurrentUrlWithQueryParams();
      _t.success(t2("redirecting-to-github"));
      openLink(
        `https://breathecode.herokuapp.com/v1/auth/github/?url=${stringToBase642(
          currentUrl
        )}`,
        { redirect: true }
      );
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Modal,
      {
        extraClass: "login-modal",
        outsideClickHandler: () => {
          setOpenedModals({ login: false });
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("login") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("login-message") }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleButton,
            {
              extraClass: "btn-dark w-100 justify-center big rounded",
              text: t2("login-github"),
              svg: svgs.github,
              action: redirectGithub
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { action: "", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "separator", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("or") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", {})
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                placeholder: "Email",
                type: "text",
                autoComplete: "email",
                name: "email",
                onChange: (e2) => {
                  setEmail(e2.target.value);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                placeholder: t2("Password"),
                autoComplete: "current-password",
                type: "password",
                name: "password",
                onChange: (e2) => {
                  setPassword(e2.target.value);
                }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "my-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SimpleButton,
                {
                  text: isLoading ? t2("Loading...") : t2("login"),
                  action: login,
                  extraClass: "bg-blue big"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                SimpleButton,
                {
                  extraClass: "btn-dark big rounded",
                  action: () => {
                    setOpenedModals({ login: false });
                  },
                  text: t2("skip")
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                t2("Don't have an account? "),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  OpenWindowLink,
                  {
                    callback: sendAnalytics,
                    text: t2("Sign up here!"),
                    href: "https://4geeks.com/pricing?plan=basic"
                  }
                ),
                " "
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                t2("forgot-password"),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  OpenWindowLink,
                  {
                    callback: sendAnalytics,
                    text: t2("recover-it-here"),
                    href: `https://breathecode.herokuapp.com/v1/auth/password/reset?url=${getCurrentUrlWithQueryParams()}`
                  }
                ),
                " "
              ] })
            ] })
          ] })
        ] })
      }
    ) });
  }
  function SocketDisconnectionModal() {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal, { blockScroll: false, outsideClickHandler: () => {
    }, htmlId: "socket-disconnected", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Content, {})
    ] });
  }
  const Header = () => {
    const { t: t2 } = useTranslation();
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-center", children: t2("Socket disconnected!") }) });
  };
  const WindowReloader = () => {
    const { t: t2 } = useTranslation();
    const reload = () => {
      window.location.reload();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SimpleButton,
      {
        extraClass: "bg-blue pill centered",
        action: reload,
        text: t2("Reload")
      }
    );
  };
  const Step = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: props.title }),
      props.instructions
    ] });
  };
  const Steps = () => {
    const { t: t2 } = useTranslation();
    const steps = [
      {
        title: t2("Step 1"),
        instructions: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("Check that Learnpack is running in your terminal.") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("Run: "),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "learnpack start" })
          ] })
        ] })
      },
      {
        title: t2("Step 2"),
        instructions: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(
            "If Learnpack is running but you still see this modal, reload the window:"
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(WindowReloader, {})
        ] })
      }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: steps.map((step, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { title: step.title, instructions: step.instructions }, index2)) });
  };
  const Content = () => {
    const { t: t2 } = useTranslation();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("Sorry, this error can happen for certain reasons.") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("The basic steps to troubleshoot this error are the following:") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Steps, {})
    ] });
  };
  const RigobotInviteModal = () => {
    const { openLink, bc_token, setOpenedModals } = useStore((state) => ({
      openLink: state.openLink,
      bc_token: state.bc_token,
      setOpenedModals: state.setOpenedModals
    }));
    const closeModal = () => {
      _t.error("The user clicked outside the modal");
    };
    const acceptRigobot = () => {
      const inviteUrl = "https://rigobot.herokuapp.com/invite?referer=4geeks&token=" + bc_token;
      openLink(inviteUrl);
      setOpenedModals({ rigobotInvite: false });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Modal,
      {
        outsideClickHandler: closeModal,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Missing Rigobot user" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            "It appears that you didn't accept ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Rigobot's" }),
            " ",
            "invitation yet. Learnpack uses Rigobot AI services under the hood, if you want to use the fabolous ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Learnpack Tutor" }),
            ", please accept Rigobot invitation!"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: acceptRigobot, className: "button ", children: "Accept now" }) })
        ] })
      }
    );
  };
  const SolutionModal = () => {
    const { setOpenedModals, currentSolution } = useStore((state) => ({
      setOpenedModals: state.setOpenedModals,
      currentSolution: state.currentSolution
    }));
    const copyCode = () => {
      navigator.clipboard.writeText(currentSolution);
      _t.success("Code copied to clipboard");
      setOpenedModals({ solution: false });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal, { outsideClickHandler: () => setOpenedModals({ solution: false }), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "This is just one solution, can you find another one?" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { style: { textAlign: "left", minWidth: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: currentSolution }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: copyCode, className: "button", children: "Copy code" })
    ] });
  };
  const ResetModal = () => {
    const { t: t2 } = useTranslation();
    const {
      setOpenedModals,
      resetExercise,
      getCurrentExercise
    } = useStore((state) => ({
      compilerSocket: state.compilerSocket,
      setOpenedModals: state.setOpenedModals,
      resetExercise: state.resetExercise,
      getCurrentExercise: state.getCurrentExercise
    }));
    reactExports.useEffect(() => {
      window.scrollTo({ top: 0, behavior: "smooth" });
    });
    const toggleModal = () => {
      setOpenedModals({ reset: false });
    };
    const handleReset = () => {
      resetExercise({
        exerciseSlug: getCurrentExercise().slug
      });
      toggleModal();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal, { extraClass: "reset-modal", outsideClickHandler: toggleModal, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("Reset") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(
        "Are you sure you want to reset the exercise? You will lose all your progress"
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SimpleButton,
          {
            text: t2("Reset"),
            extraClass: "pill bg-blue big",
            action: handleReset
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SimpleButton,
          {
            text: t2("Cancel"),
            extraClass: "pill border-blue color-blue big",
            action: toggleModal
          }
        )
      ] })
    ] });
  };
  const _$1 = "";
  const defaultSteps = [
    {
      title: "Welcome to LearnPack!",
      text: `This is a quick tutorial to help you get started. Click next to continue.`,
      id: null,
      position: ["100px", "20%"]
    },
    {
      title: "If you prefer, you can change the language!",
      text: `Click on the flag to change the language.`,
      id: "language-component",
      position: ["120px", "20%"]
    },
    {
      title: "The run button",
      text: `Use this button to compile or run your code. The behavior depends of the files in the exercise directory. You can also use the shortcut \`Ctrl\` + \`Enter\` to run the code.`,
      id: "build-button",
      position: ["80px", "20%"]
    },
    {
      title: "Options to get feedback",
      text: "Within this dropdown you can get feedback on your code. Let's try the available ones! You can use the following shortcuts:\n\n`Ctrl` + `Shift` + `Enter`: Run the tests if available. \n\n`Ctrl` + `Alt` + `Enter`: Open the chat with Rigobot",
      id: "feedback-button",
      position: ["210px", "20%"]
    },
    {
      title: "Reset button",
      text: "Sometimes you want to start over, use this button to `reset` the code to its original state.",
      id: "reset-button",
      position: ["100px", "20%"]
    },
    {
      title: "Open the sidebar",
      text: "Inside the sidebar you can go through the exercises and see your progress. Also you can report a bug.",
      id: "sidebar-toggle",
      position: ["100px", "20%"]
    }
  ];
  const Presentator = ({}) => {
    const [element, setElement] = reactExports.useState(null);
    const [currentStep, setCurrentStep] = reactExports.useState(0);
    const steps = defaultSteps;
    reactExports.useEffect(() => {
      const idToSearch = steps[currentStep].id;
      const element2 = document.getElementById(
        idToSearch ? idToSearch : "no-element"
      );
      if (element2) {
        setElement(element2);
      }
    }, [currentStep]);
    const handlePositionChange = (action) => {
      if (action === "next") {
        setCurrentStep((prev2) => prev2 + 1);
      }
      if (action === "prev") {
        setCurrentStep((prev2) => prev2 - 1);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "no-element" }),
      element && reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Badge,
          {
            currentStep,
            element,
            title: steps[currentStep].title,
            text: steps[currentStep].text,
            position: steps[currentStep].position,
            handlePositionChange,
            numberOfSteps: steps.length
          }
        ),
        //   @ts-ignore
        element.parentNode
      )
    ] });
  };
  const Badge = ({
    text: text2,
    title,
    handlePositionChange,
    element,
    numberOfSteps,
    currentStep,
    position
  }) => {
    const { t: t2 } = useTranslation();
    const { setOpenedModals } = useStore((state) => ({
      setOpenedModals: state.setOpenedModals
    }));
    let cachedStyles = element ? {
      border: element.style.border,
      zIndex: element.style.zIndex,
      background: element.style.background,
      borderRadius: element.style.borderRadius
    } : {
      border: "",
      zIndex: "",
      background: "",
      borderRadius: ""
    };
    reactExports.useEffect(() => {
      if (!element)
        return;
      if (element.id !== "no-element") {
        element.style.border = "2px solid red";
      }
      element.style.zIndex = "1";
      element.style.borderRadius = "10px";
      element.style.background = "white";
      return () => {
        element.style.border = cachedStyles.border;
        element.style.zIndex = "0";
        element.style.borderRadius = cachedStyles.borderRadius;
        element.style.background = cachedStyles.background;
      };
    }, [element]);
    const next = () => {
      handlePositionChange("next");
    };
    const prev2 = () => {
      handlePositionChange("prev");
    };
    const closeTutorial = () => {
      setOpenedModals({ tutorial: false });
    };
    const handleClickBackdrop = (e2) => {
      if (e2.target.classList.contains("presentator")) {
        closeTutorial();
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: handleClickBackdrop, className: "presentator" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { top: position[0], left: position[1] }, className: "_badge", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2(title) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "_content",
            dangerouslySetInnerHTML: { __html: convertMarkdownToHTML(t2(text2)) }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "_footer", children: [
          !(currentStep === 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleButton,
            {
              extraClass: "pill",
              svg: svgs.prevArrowButton,
              action: prev2
            }
          ),
          !(currentStep === numberOfSteps - 1) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleButton,
            {
              extraClass: "pill",
              svg: svgs.nextArrowButton,
              action: next
            }
          ),
          currentStep === numberOfSteps - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleButton,
            {
              extraClass: "pill border-blue color-blue on-hover-active",
              text: "Finish!",
              action: closeTutorial
            }
          )
        ] })
      ] })
    ] });
  };
  const formatMessage = (message) => {
    return message.replace("BAD_PROMPT", "Bad Prompt").replace("GOOD_PROMPT", "Good Prompt");
  };
  const DialogModal = () => {
    const { setOpenedModals, dialogData } = useStore((state) => ({
      setOpenedModals: state.setOpenedModals,
      dialogData: state.dialogData
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Modal, { outsideClickHandler: () => setOpenedModals({ dialog: false }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        dangerouslySetInnerHTML: {
          __html: convertMarkdownToHTML(formatMessage(dialogData.message))
        }
      }
    ) });
  };
  const modals = "";
  const SessionModal = () => {
    const { setOpenedModals, sessionActions } = useStore((s2) => ({
      setOpenedModals: s2.setOpenedModals,
      sessionActions: s2.sessionActions
    }));
    const { t: t2 } = useTranslation();
    const outsideClickHandler = () => {
      _t.error(t2("please-select-option"));
    };
    const handleContinue = async () => {
      await sessionActions({ action: "continue" });
      setOpenedModals({ session: false });
    };
    const handleNew = async () => {
      await sessionActions({ action: "new" });
      setOpenedModals({ session: false });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal, { outsideClickHandler, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-center", children: t2("we-got-you-covered") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("prev-session") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-center gap-big", children: [
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SimpleButton,
          {
            extraClass: "pill bg-blue",
            text: "Continue here",
            action: handleContinue
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SimpleButton,
          {
            extraClass: "pill btn-dark",
            text: "Start again",
            action: handleNew
          }
        )
      ] })
    ] });
  };
  const MustLoginModal = () => {
    const { t: t2 } = useTranslation();
    const { setOpenedModals } = useStore((s2) => ({
      setOpenedModals: s2.setOpenedModals
    }));
    const handleClickOutside = () => {
      setOpenedModals({ mustLogin: false });
    };
    const handleLogin = () => {
      setOpenedModals({ login: true, mustLogin: false });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal, { outsideClickHandler: handleClickOutside, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center", children: t2("you-must-login-title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("you-must-login-message") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-center gap-big", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SimpleButton,
          {
            action: handleLogin,
            extraClass: "pill clickeable bg-blue  big",
            text: "Login",
            svg: svgs.sendSvg
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SimpleButton,
          {
            action: handleClickOutside,
            extraClass: "pill clickeable bg-secondary big",
            text: t2("skip")
          }
        )
      ] })
    ] });
  };
  const ModalsContainer = () => {
    const { openedModals } = useStore((state) => ({
      openedModals: state.openedModals,
      token: state.token
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SocketDisconnectionModal, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CheckVideo, {}),
      openedModals.login && /* @__PURE__ */ jsxRuntimeExports.jsx(LoginModal, {}),
      openedModals.chat && /* @__PURE__ */ jsxRuntimeExports.jsx(Chat, {}),
      openedModals.rigobotInvite && /* @__PURE__ */ jsxRuntimeExports.jsx(RigobotInviteModal, {}),
      openedModals.solution && /* @__PURE__ */ jsxRuntimeExports.jsx(SolutionModal, {}),
      openedModals.reset && /* @__PURE__ */ jsxRuntimeExports.jsx(ResetModal, {}),
      openedModals.tutorial && /* @__PURE__ */ jsxRuntimeExports.jsx(Presentator, {}),
      openedModals.dialog && /* @__PURE__ */ jsxRuntimeExports.jsx(DialogModal, {}),
      openedModals.session && /* @__PURE__ */ jsxRuntimeExports.jsx(SessionModal, {}),
      openedModals.mustLogin && /* @__PURE__ */ jsxRuntimeExports.jsx(MustLoginModal, {})
    ] });
  };
  const ShortcutsListener = ({ children }) => {
    const { t: t2 } = useTranslation();
    const {
      currentExercisePosition,
      handlePositionChange,
      build,
      runExerciseTests,
      setOpenedModals,
      openedModals,
      isBuildable,
      isTesteable
    } = useStore((state) => ({
      currentExercisePosition: state.currentExercisePosition,
      handlePositionChange: state.handlePositionChange,
      exercises: state.exercises,
      build: state.build,
      runExerciseTests: state.runExerciseTests,
      setOpenedModals: state.setOpenedModals,
      openedModals: state.openedModals,
      isBuildable: state.isBuildable,
      isTesteable: state.isTesteable
    }));
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        if (event.ctrlKey && event.key === "ArrowRight" && !event.shiftKey) {
          handlePositionChange(Number(currentExercisePosition) + 1);
        }
        if (event.ctrlKey && event.key === "ArrowLeft" && !event.shiftKey) {
          handlePositionChange(Number(currentExercisePosition) - 1);
        }
        if (event.ctrlKey && !event.shiftKey && !event.altKey && event.key === "Enter" && isBuildable) {
          build(t2("Running..."));
        }
        if (event.ctrlKey && event.shiftKey && event.key === "Enter" && isTesteable) {
          runExerciseTests({
            toast: true,
            setFeedbackButton: true,
            feedbackButtonText: t2("Running..."),
            targetButton: "feedback"
          });
        }
        if (event.ctrlKey && event.altKey && event.key === "Enter") {
          setOpenedModals({ chat: !openedModals.chat });
        }
        if (event.ctrlKey && (event.key === "+" || event.key === "-")) {
          event.preventDefault();
          const scale = window.devicePixelRatio;
          if (scale > 2) {
            document.body.style.transform = `scale(${2 / scale})`;
          } else {
            document.body.style.transform = "none";
          }
        }
      };
      window.addEventListener("keydown", handleKeyDown);
      return () => {
        window.removeEventListener("keydown", handleKeyDown);
      };
    }, [currentExercisePosition, openedModals.chat]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shortcut", children });
  };
  const consoleLogger = {
    type: "logger",
    log(args) {
      this.output("log", args);
    },
    warn(args) {
      this.output("warn", args);
    },
    error(args) {
      this.output("error", args);
    },
    output(type2, args) {
      if (console && console[type2])
        console[type2].apply(console, args);
    }
  };
  class Logger {
    constructor(concreteLogger) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.init(concreteLogger, options);
    }
    init(concreteLogger) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
    log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
    warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
    error() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
    deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
    forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = `${prefix}${this.prefix} ${args[0]}`;
      return this.logger[lvl](args);
    }
    create(moduleName) {
      return new Logger(this.logger, {
        ...{
          prefix: `${this.prefix}:${moduleName}:`
        },
        ...this.options
      });
    }
    clone(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger(this.logger, options);
    }
  }
  var baseLogger = new Logger();
  class EventEmitter {
    constructor() {
      this.observers = {};
    }
    on(events, listener) {
      events.split(" ").forEach((event) => {
        if (!this.observers[event])
          this.observers[event] = /* @__PURE__ */ new Map();
        const numListeners = this.observers[event].get(listener) || 0;
        this.observers[event].set(listener, numListeners + 1);
      });
      return this;
    }
    off(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event].delete(listener);
    }
    emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        const cloned = Array.from(this.observers[event].entries());
        cloned.forEach((_ref) => {
          let [observer, numTimesAdded] = _ref;
          for (let i2 = 0; i2 < numTimesAdded; i2++) {
            observer(...args);
          }
        });
      }
      if (this.observers["*"]) {
        const cloned = Array.from(this.observers["*"].entries());
        cloned.forEach((_ref2) => {
          let [observer, numTimesAdded] = _ref2;
          for (let i2 = 0; i2 < numTimesAdded; i2++) {
            observer.apply(observer, [event, ...args]);
          }
        });
      }
    }
  }
  const defer = () => {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
  };
  const makeString = (object) => {
    if (object == null)
      return "";
    return "" + object;
  };
  const copy = (a2, s2, t2) => {
    a2.forEach((m2) => {
      if (s2[m2])
        t2[m2] = s2[m2];
    });
  };
  const lastOfPathSeparatorRegExp = /###/g;
  const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
  const canNotTraverseDeeper = (object) => !object || typeof object === "string";
  const getLastOfPath = (object, path, Empty) => {
    const stack = typeof path !== "string" ? path : path.split(".");
    let stackIndex = 0;
    while (stackIndex < stack.length - 1) {
      if (canNotTraverseDeeper(object))
        return {};
      const key = cleanKey(stack[stackIndex]);
      if (!object[key] && Empty)
        object[key] = new Empty();
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        object = object[key];
      } else {
        object = {};
      }
      ++stackIndex;
    }
    if (canNotTraverseDeeper(object))
      return {};
    return {
      obj: object,
      k: cleanKey(stack[stackIndex])
    };
  };
  const setPath = (object, path, newValue) => {
    const {
      obj,
      k: k2
    } = getLastOfPath(object, path, Object);
    if (obj !== void 0 || path.length === 1) {
      obj[k2] = newValue;
      return;
    }
    let e2 = path[path.length - 1];
    let p2 = path.slice(0, path.length - 1);
    let last = getLastOfPath(object, p2, Object);
    while (last.obj === void 0 && p2.length) {
      e2 = `${p2[p2.length - 1]}.${e2}`;
      p2 = p2.slice(0, p2.length - 1);
      last = getLastOfPath(object, p2, Object);
      if (last && last.obj && typeof last.obj[`${last.k}.${e2}`] !== "undefined") {
        last.obj = void 0;
      }
    }
    last.obj[`${last.k}.${e2}`] = newValue;
  };
  const pushPath = (object, path, newValue, concat) => {
    const {
      obj,
      k: k2
    } = getLastOfPath(object, path, Object);
    obj[k2] = obj[k2] || [];
    obj[k2].push(newValue);
  };
  const getPath = (object, path) => {
    const {
      obj,
      k: k2
    } = getLastOfPath(object, path);
    if (!obj)
      return void 0;
    return obj[k2];
  };
  const getPathWithDefaults = (data, defaultData, key) => {
    const value2 = getPath(data, key);
    if (value2 !== void 0) {
      return value2;
    }
    return getPath(defaultData, key);
  };
  const deepExtend = (target, source, overwrite) => {
    for (const prop in source) {
      if (prop !== "__proto__" && prop !== "constructor") {
        if (prop in target) {
          if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
            if (overwrite)
              target[prop] = source[prop];
          } else {
            deepExtend(target[prop], source[prop], overwrite);
          }
        } else {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  };
  const regexEscape = (str2) => str2.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  var _entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
  };
  const escape = (data) => {
    if (typeof data === "string") {
      return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
    }
    return data;
  };
  class RegExpCache {
    constructor(capacity) {
      this.capacity = capacity;
      this.regExpMap = /* @__PURE__ */ new Map();
      this.regExpQueue = [];
    }
    getRegExp(pattern2) {
      const regExpFromCache = this.regExpMap.get(pattern2);
      if (regExpFromCache !== void 0) {
        return regExpFromCache;
      }
      const regExpNew = new RegExp(pattern2);
      if (this.regExpQueue.length === this.capacity) {
        this.regExpMap.delete(this.regExpQueue.shift());
      }
      this.regExpMap.set(pattern2, regExpNew);
      this.regExpQueue.push(pattern2);
      return regExpNew;
    }
  }
  const chars = [" ", ",", "?", "!", ";"];
  const looksLikeObjectPathRegExpCache = new RegExpCache(20);
  const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
    nsSeparator = nsSeparator || "";
    keySeparator = keySeparator || "";
    const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
    if (possibleChars.length === 0)
      return true;
    const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
    let matched = !r2.test(key);
    if (!matched) {
      const ki2 = key.indexOf(keySeparator);
      if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
        matched = true;
      }
    }
    return matched;
  };
  const deepFind = function(obj, path) {
    let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
    if (!obj)
      return void 0;
    if (obj[path])
      return obj[path];
    const tokens = path.split(keySeparator);
    let current = obj;
    for (let i2 = 0; i2 < tokens.length; ) {
      if (!current || typeof current !== "object") {
        return void 0;
      }
      let next;
      let nextPath = "";
      for (let j2 = i2; j2 < tokens.length; ++j2) {
        if (j2 !== i2) {
          nextPath += keySeparator;
        }
        nextPath += tokens[j2];
        next = current[nextPath];
        if (next !== void 0) {
          if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j2 < tokens.length - 1) {
            continue;
          }
          i2 += j2 - i2 + 1;
          break;
        }
      }
      current = next;
    }
    return current;
  };
  const getCleanedCode = (code2) => {
    if (code2 && code2.indexOf("_") > 0)
      return code2.replace("_", "-");
    return code2;
  };
  class ResourceStore extends EventEmitter {
    constructor(data) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        ns: ["translation"],
        defaultNS: "translation"
      };
      super();
      this.data = data || {};
      this.options = options;
      if (this.options.keySeparator === void 0) {
        this.options.keySeparator = ".";
      }
      if (this.options.ignoreJSONStructure === void 0) {
        this.options.ignoreJSONStructure = true;
      }
    }
    addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
    removeNamespaces(ns) {
      const index2 = this.options.ns.indexOf(ns);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
    getResource(lng, ns, key) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      let path;
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      } else {
        path = [lng, ns];
        if (key) {
          if (Array.isArray(key)) {
            path.push(...key);
          } else if (typeof key === "string" && keySeparator) {
            path.push(...key.split(keySeparator));
          } else {
            path.push(key);
          }
        }
      }
      const result = getPath(this.data, path);
      if (!result && !ns && !key && lng.indexOf(".") > -1) {
        lng = path[0];
        ns = path[1];
        key = path.slice(2).join(".");
      }
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
    addResource(lng, ns, key, value2) {
      let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      let path = [lng, ns];
      if (key)
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value2 = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path, value2);
      if (!options.silent)
        this.emit("added", lng, ns, key, value2);
    }
    addResources(lng, ns, resources) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (const m2 in resources) {
        if (typeof resources[m2] === "string" || Array.isArray(resources[m2]))
          this.addResource(lng, ns, m2, resources[m2], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
    addResourceBundle(lng, ns, resources, deep, overwrite) {
      let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false,
        skipCopy: false
      };
      let path = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      let pack = getPath(this.data, path) || {};
      if (!options.skipCopy)
        resources = JSON.parse(JSON.stringify(resources));
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = {
          ...pack,
          ...resources
        };
      }
      setPath(this.data, path, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
    removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
    hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
    getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return {
          ...{},
          ...this.getResource(lng, ns)
        };
      return this.getResource(lng, ns);
    }
    getDataByLanguage(lng) {
      return this.data[lng];
    }
    hasLanguageSomeTranslations(lng) {
      const data = this.getDataByLanguage(lng);
      const n2 = data && Object.keys(data) || [];
      return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
    }
    toJSON() {
      return this.data;
    }
  }
  var postProcessor = {
    processors: {},
    addPostProcessor(module) {
      this.processors[module.name] = module;
    },
    handle(processors, value2, key, options, translator) {
      processors.forEach((processor) => {
        if (this.processors[processor])
          value2 = this.processors[processor].process(value2, key, options, translator);
      });
      return value2;
    }
  };
  const checkedLoadedFor = {};
  class Translator extends EventEmitter {
    constructor(services) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super();
      copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
      this.options = options;
      if (this.options.keySeparator === void 0) {
        this.options.keySeparator = ".";
      }
      this.logger = baseLogger.create("translator");
    }
    changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
    exists(key) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      const resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
    extractFromKey(key, options) {
      let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      let namespaces = options.ns || this.options.defaultNS || [];
      const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        const m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0) {
          return {
            key,
            namespaces
          };
        }
        const parts2 = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts2[0]) > -1)
          namespaces = parts2.shift();
        key = parts2.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
    translate(keys, options, lastKey) {
      if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (typeof options === "object")
        options = {
          ...options
        };
      if (!options)
        options = {};
      if (keys === void 0 || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      const {
        key,
        namespaces
      } = this.extractFromKey(keys[keys.length - 1], options);
      const namespace = namespaces[namespaces.length - 1];
      const lng = options.lng || this.language;
      const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          const nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            return {
              res: `${namespace}${nsSeparator}${key}`,
              usedKey: key,
              exactUsedKey: key,
              usedLng: lng,
              usedNS: namespace,
              usedParams: this.getUsedParamsDetails(options)
            };
          }
          return `${namespace}${nsSeparator}${key}`;
        }
        if (returnDetails) {
          return {
            res: key,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return key;
      }
      const resolved = this.resolve(keys, options);
      let res = resolved && resolved.res;
      const resUsedKey = resolved && resolved.usedKey || key;
      const resExactUsedKey = resolved && resolved.exactUsedKey || key;
      const resType = Object.prototype.toString.apply(res);
      const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && Array.isArray(res))) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
            ...options,
            ns: namespaces
          }) : `key '${key} (${this.language})' returned an object instead of string.`;
          if (returnDetails) {
            resolved.res = r2;
            resolved.usedParams = this.getUsedParamsDetails(options);
            return resolved;
          }
          return r2;
        }
        if (keySeparator) {
          const resTypeIsArray = Array.isArray(res);
          const copy2 = resTypeIsArray ? [] : {};
          const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (const m2 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
              copy2[m2] = this.translate(deepKey, {
                ...options,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
              if (copy2[m2] === deepKey)
                copy2[m2] = res[m2];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && Array.isArray(res)) {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        let usedDefault = false;
        let usedKey = false;
        const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        const hasDefaultValue = Translator.hasDefaultValue(options);
        const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
          ordinal: false
        }) : "";
        const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
        const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            const fk2 = this.resolve(key, {
              ...options,
              keySeparator: false
            });
            if (fk2 && fk2.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          let lngs = [];
          const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          const send = (l2, k2, specificDefaultValue) => {
            const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (this.options.missingKeyHandler) {
              this.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
            } else if (this.backendConnector && this.backendConnector.saveMissing) {
              this.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
            }
            this.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach((language) => {
                const suffixes = this.pluralResolver.getSuffixes(language, options);
                if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                  suffixes.push(`${this.options.pluralSeparator}zero`);
                }
                suffixes.forEach((suffix) => {
                  send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = `${namespace}:${key}`;
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        resolved.usedParams = this.getUsedParamsDetails(options);
        return resolved;
      }
      return res;
    }
    extendTranslation(res, key, options, resolved, lastKey) {
      var _this = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, {
          ...this.options.interpolation.defaultVariables,
          ...options
        }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init({
            ...options,
            ...{
              interpolation: {
                ...this.options.interpolation,
                ...options.interpolation
              }
            }
          });
        const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        let nestBef;
        if (skipOnVariables) {
          const nb2 = res.match(this.interpolator.nestingRegexp);
          nestBef = nb2 && nb2.length;
        }
        let data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data = {
            ...this.options.interpolation.defaultVariables,
            ...data
          };
        res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
        if (skipOnVariables) {
          const na = res.match(this.interpolator.nestingRegexp);
          const nestAft = na && na.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
          options.lng = this.language || resolved.usedLng;
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
              return null;
            }
            return _this.translate(...args, key);
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      const postProcess2 = options.postProcess || this.options.postProcess;
      const postProcessorNames = typeof postProcess2 === "string" ? [postProcess2] : postProcess2;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
          i18nResolved: {
            ...resolved,
            usedParams: this.getUsedParamsDetails(options)
          },
          ...options
        } : options, this);
      }
      return res;
    }
    resolve(keys) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let found;
      let usedKey;
      let exactUsedKey;
      let usedLng;
      let usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach((k2) => {
        if (this.isValidLookup(found))
          return;
        const extracted = this.extractFromKey(k2, options);
        const key = extracted.key;
        usedKey = key;
        let namespaces = extracted.namespaces;
        if (this.options.fallbackNS)
          namespaces = namespaces.concat(this.options.fallbackNS);
        const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
        const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
        namespaces.forEach((ns) => {
          if (this.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor[`${codes[0]}-${ns}`] = true;
            this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach((code2) => {
            if (this.isValidLookup(found))
              return;
            usedLng = code2;
            const finalKeys = [key];
            if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
              this.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, options);
            } else {
              let pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = this.pluralResolver.getSuffix(code2, options.count, options);
              const zeroSuffix = `${this.options.pluralSeparator}zero`;
              const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                  }
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            let possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!this.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = this.getResource(code2, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
    isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
    getResource(code2, ns, key) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code2, ns, key, options);
      return this.resourceStore.getResource(code2, ns, key, options);
    }
    getUsedParamsDetails() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
      const useOptionsReplaceForData = options.replace && typeof options.replace !== "string";
      let data = useOptionsReplaceForData ? options.replace : options;
      if (useOptionsReplaceForData && typeof options.count !== "undefined") {
        data.count = options.count;
      }
      if (this.options.interpolation.defaultVariables) {
        data = {
          ...this.options.interpolation.defaultVariables,
          ...data
        };
      }
      if (!useOptionsReplaceForData) {
        data = {
          ...data
        };
        for (const key of optionsKeys) {
          delete data[key];
        }
      }
      return data;
    }
    static hasDefaultValue(options) {
      const prefix = "defaultValue";
      for (const option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
          return true;
        }
      }
      return false;
    }
  }
  const capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
  class LanguageUtil {
    constructor(options) {
      this.options = options;
      this.supportedLngs = this.options.supportedLngs || false;
      this.logger = baseLogger.create("languageUtils");
    }
    getScriptPartFromCode(code2) {
      code2 = getCleanedCode(code2);
      if (!code2 || code2.indexOf("-") < 0)
        return null;
      const p2 = code2.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
    getLanguagePartFromCode(code2) {
      code2 = getCleanedCode(code2);
      if (!code2 || code2.indexOf("-") < 0)
        return code2;
      const p2 = code2.split("-");
      return this.formatLanguageCode(p2[0]);
    }
    formatLanguageCode(code2) {
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        let p2 = code2.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map((part) => part.toLowerCase());
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
    }
    isSupportedCode(code2) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code2 = this.getLanguagePartFromCode(code2);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
    }
    getBestMatchFromCodes(codes) {
      if (!codes)
        return null;
      let found;
      codes.forEach((code2) => {
        if (found)
          return;
        const cleanedLng = this.formatLanguageCode(code2);
        if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach((code2) => {
          if (found)
            return;
          const lngOnly = this.getLanguagePartFromCode(code2);
          if (this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = this.options.supportedLngs.find((supportedLng) => {
            if (supportedLng === lngOnly)
              return supportedLng;
            if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
              return;
            if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly)
              return supportedLng;
            if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
    getFallbackCodes(fallbacks, code2) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code2);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Array.isArray(fallbacks))
        return fallbacks;
      if (!code2)
        return fallbacks.default || [];
      let found = fallbacks[code2];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code2)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code2)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code2)];
      if (!found)
        found = fallbacks.default;
      return found || [];
    }
    toResolveHierarchy(code2, fallbackCode) {
      const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
      const codes = [];
      const addCode = (c2) => {
        if (!c2)
          return;
        if (this.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
        }
      };
      if (typeof code2 === "string" && (code2.indexOf("-") > -1 || code2.indexOf("_") > -1)) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code2));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code2));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code2));
      } else if (typeof code2 === "string") {
        addCode(this.formatLanguageCode(code2));
      }
      fallbackCodes.forEach((fc2) => {
        if (codes.indexOf(fc2) < 0)
          addCode(this.formatLanguageCode(fc2));
      });
      return codes;
    }
  }
  let sets = [{
    lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
    nr: [1, 2],
    fc: 1
  }, {
    lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
    nr: [1, 2],
    fc: 2
  }, {
    lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
    nr: [1],
    fc: 3
  }, {
    lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
    nr: [1, 2, 5],
    fc: 4
  }, {
    lngs: ["ar"],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
  }, {
    lngs: ["cs", "sk"],
    nr: [1, 2, 5],
    fc: 6
  }, {
    lngs: ["csb", "pl"],
    nr: [1, 2, 5],
    fc: 7
  }, {
    lngs: ["cy"],
    nr: [1, 2, 3, 8],
    fc: 8
  }, {
    lngs: ["fr"],
    nr: [1, 2],
    fc: 9
  }, {
    lngs: ["ga"],
    nr: [1, 2, 3, 7, 11],
    fc: 10
  }, {
    lngs: ["gd"],
    nr: [1, 2, 3, 20],
    fc: 11
  }, {
    lngs: ["is"],
    nr: [1, 2],
    fc: 12
  }, {
    lngs: ["jv"],
    nr: [0, 1],
    fc: 13
  }, {
    lngs: ["kw"],
    nr: [1, 2, 3, 4],
    fc: 14
  }, {
    lngs: ["lt"],
    nr: [1, 2, 10],
    fc: 15
  }, {
    lngs: ["lv"],
    nr: [1, 2, 0],
    fc: 16
  }, {
    lngs: ["mk"],
    nr: [1, 2],
    fc: 17
  }, {
    lngs: ["mnk"],
    nr: [0, 1, 2],
    fc: 18
  }, {
    lngs: ["mt"],
    nr: [1, 2, 11, 20],
    fc: 19
  }, {
    lngs: ["or"],
    nr: [2, 1],
    fc: 2
  }, {
    lngs: ["ro"],
    nr: [1, 2, 20],
    fc: 20
  }, {
    lngs: ["sl"],
    nr: [5, 1, 2, 3],
    fc: 21
  }, {
    lngs: ["he", "iw"],
    nr: [1, 2, 20, 21],
    fc: 22
  }];
  let _rulesPluralsTypes = {
    1: (n2) => Number(n2 > 1),
    2: (n2) => Number(n2 != 1),
    3: (n2) => 0,
    4: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
    5: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5),
    6: (n2) => Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2),
    7: (n2) => Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
    8: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3),
    9: (n2) => Number(n2 >= 2),
    10: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4),
    11: (n2) => Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3),
    12: (n2) => Number(n2 % 10 != 1 || n2 % 100 == 11),
    13: (n2) => Number(n2 !== 0),
    14: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3),
    15: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
    16: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2),
    17: (n2) => Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1),
    18: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2),
    19: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3),
    20: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2),
    21: (n2) => Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0),
    22: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3)
  };
  const nonIntlVersions = ["v1", "v2", "v3"];
  const intlVersions = ["v4"];
  const suffixesOrder = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
  };
  const createRules = () => {
    const rules = {};
    sets.forEach((set2) => {
      set2.lngs.forEach((l2) => {
        rules[l2] = {
          numbers: set2.nr,
          plurals: _rulesPluralsTypes[set2.fc]
        };
      });
    });
    return rules;
  };
  class PluralResolver {
    constructor(languageUtils) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.languageUtils = languageUtils;
      this.options = options;
      this.logger = baseLogger.create("pluralResolver");
      if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
        this.options.compatibilityJSON = "v3";
        this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
      }
      this.rules = createRules();
      this.pluralRulesCache = {};
    }
    addRule(lng, obj) {
      this.rules[lng] = obj;
    }
    clearCache() {
      this.pluralRulesCache = {};
    }
    getRule(code2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          const cleanedCode = getCleanedCode(code2 === "dev" ? "en" : code2);
          const type2 = options.ordinal ? "ordinal" : "cardinal";
          const cacheKey = JSON.stringify({
            cleanedCode,
            type: type2
          });
          if (cacheKey in this.pluralRulesCache) {
            return this.pluralRulesCache[cacheKey];
          }
          const rule = new Intl.PluralRules(cleanedCode, {
            type: type2
          });
          this.pluralRulesCache[cacheKey] = rule;
          return rule;
        } catch (err) {
          return;
        }
      }
      return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
    }
    needsPlural(code2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const rule = this.getRule(code2, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
    getPluralFormsOfKey(code2, key) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code2, options).map((suffix) => `${key}${suffix}`);
    }
    getSuffixes(code2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const rule = this.getRule(code2, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
      }
      return rule.numbers.map((number) => this.getSuffix(code2, number, options));
    }
    getSuffix(code2, count) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const rule = this.getRule(code2, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn(`no plural rule found for: ${code2}`);
      return "";
    }
    getSuffixRetroCompatible(rule, count) {
      const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      let suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return `_plural_${suffix.toString()}`;
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
    shouldUseIntlApi() {
      return !nonIntlVersions.includes(this.options.compatibilityJSON);
    }
  }
  const deepFindWithDefaults = function(data, defaultData, key) {
    let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    let path = getPathWithDefaults(data, defaultData, key);
    if (!path && ignoreJSONStructure && typeof key === "string") {
      path = deepFind(data, key, keySeparator);
      if (path === void 0)
        path = deepFind(defaultData, key, keySeparator);
    }
    return path;
  };
  const regexSafe = (val) => val.replace(/\$/g, "$$$$");
  class Interpolator {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.logger = baseLogger.create("interpolator");
      this.options = options;
      this.format = options.interpolation && options.interpolation.format || ((value2) => value2);
      this.init(options);
    }
    init() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      const {
        escape: escape$12,
        escapeValue,
        useRawValueToEscape,
        prefix,
        prefixEscaped,
        suffix,
        suffixEscaped,
        formatSeparator,
        unescapeSuffix,
        unescapePrefix,
        nestingPrefix,
        nestingPrefixEscaped,
        nestingSuffix,
        nestingSuffixEscaped,
        nestingOptionsSeparator,
        maxReplaces,
        alwaysFormat
      } = options.interpolation;
      this.escape = escape$12 !== void 0 ? escape$12 : escape;
      this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
      this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
      this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
      this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
      this.formatSeparator = formatSeparator || ",";
      this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
      this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
      this.maxReplaces = maxReplaces || 1e3;
      this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
      this.resetRegExp();
    }
    reset() {
      if (this.options)
        this.init(this.options);
    }
    resetRegExp() {
      const getOrResetRegExp = (existingRegExp, pattern2) => {
        if (existingRegExp && existingRegExp.source === pattern2) {
          existingRegExp.lastIndex = 0;
          return existingRegExp;
        }
        return new RegExp(pattern2, "g");
      };
      this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
      this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
      this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
    }
    interpolate(str2, data, lng, options) {
      let match;
      let value2;
      let replaces;
      const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      const handleFormat = (key) => {
        if (key.indexOf(this.formatSeparator) < 0) {
          const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
          return this.alwaysFormat ? this.format(path, void 0, lng, {
            ...options,
            ...data,
            interpolationkey: key
          }) : path;
        }
        const p2 = key.split(this.formatSeparator);
        const k2 = p2.shift().trim();
        const f2 = p2.join(this.formatSeparator).trim();
        return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
          ...options,
          ...data,
          interpolationkey: k2
        });
      };
      this.resetRegExp();
      const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      const todos = [{
        regex: this.regexpUnescape,
        safeValue: (val) => regexSafe(val)
      }, {
        regex: this.regexp,
        safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
      }];
      todos.forEach((todo) => {
        replaces = 0;
        while (match = todo.regex.exec(str2)) {
          const matchedVar = match[1].trim();
          value2 = handleFormat(matchedVar);
          if (value2 === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              const temp = missingInterpolationHandler(str2, match, options);
              value2 = typeof temp === "string" ? temp : "";
            } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
              value2 = "";
            } else if (skipOnVariables) {
              value2 = match[0];
              continue;
            } else {
              this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str2}`);
              value2 = "";
            }
          } else if (typeof value2 !== "string" && !this.useRawValueToEscape) {
            value2 = makeString(value2);
          }
          const safeValue = todo.safeValue(value2);
          str2 = str2.replace(match[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value2.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= this.maxReplaces) {
            break;
          }
        }
      });
      return str2;
    }
    nest(str2, fc2) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let match;
      let value2;
      let clonedOptions;
      const handleHasOptions = (key, inheritedOptions) => {
        const sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        const c2 = key.split(new RegExp(`${sep}[ ]*{`));
        let optionsString = `{${c2[1]}`;
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        const matchedSingleQuotes = optionsString.match(/'/g);
        const matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = {
              ...inheritedOptions,
              ...clonedOptions
            };
        } catch (e2) {
          this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
          return `${key}${sep}${optionsString}`;
        }
        if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1)
          delete clonedOptions.defaultValue;
        return key;
      };
      while (match = this.nestingRegexp.exec(str2)) {
        let formatters = [];
        clonedOptions = {
          ...options
        };
        clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
        clonedOptions.applyPostProcessor = false;
        delete clonedOptions.defaultValue;
        let doReduce = false;
        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          const r2 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
          match[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value2 = fc2(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value2 && match[0] === str2 && typeof value2 !== "string")
          return value2;
        if (typeof value2 !== "string")
          value2 = makeString(value2);
        if (!value2) {
          this.logger.warn(`missed to resolve ${match[1]} for nesting ${str2}`);
          value2 = "";
        }
        if (doReduce) {
          value2 = formatters.reduce((v2, f2) => this.format(v2, f2, options.lng, {
            ...options,
            interpolationkey: match[1].trim()
          }), value2.trim());
        }
        str2 = str2.replace(match[0], value2);
        this.regexp.lastIndex = 0;
      }
      return str2;
    }
  }
  const parseFormatStr = (formatStr) => {
    let formatName = formatStr.toLowerCase().trim();
    const formatOptions = {};
    if (formatStr.indexOf("(") > -1) {
      const p2 = formatStr.split("(");
      formatName = p2[0].toLowerCase().trim();
      const optStr = p2[1].substring(0, p2[1].length - 1);
      if (formatName === "currency" && optStr.indexOf(":") < 0) {
        if (!formatOptions.currency)
          formatOptions.currency = optStr.trim();
      } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
        if (!formatOptions.range)
          formatOptions.range = optStr.trim();
      } else {
        const opts = optStr.split(";");
        opts.forEach((opt) => {
          if (opt) {
            const [key, ...rest] = opt.split(":");
            const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
            const trimmedKey = key.trim();
            if (!formatOptions[trimmedKey])
              formatOptions[trimmedKey] = val;
            if (val === "false")
              formatOptions[trimmedKey] = false;
            if (val === "true")
              formatOptions[trimmedKey] = true;
            if (!isNaN(val))
              formatOptions[trimmedKey] = parseInt(val, 10);
          }
        });
      }
    }
    return {
      formatName,
      formatOptions
    };
  };
  const createCachedFormatter = (fn) => {
    const cache2 = {};
    return (val, lng, options) => {
      let optForCache = options;
      if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
        optForCache = {
          ...optForCache,
          [options.interpolationkey]: void 0
        };
      }
      const key = lng + JSON.stringify(optForCache);
      let formatter = cache2[key];
      if (!formatter) {
        formatter = fn(getCleanedCode(lng), options);
        cache2[key] = formatter;
      }
      return formatter(val);
    };
  };
  class Formatter {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.logger = baseLogger.create("formatter");
      this.options = options;
      this.formats = {
        number: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.NumberFormat(lng, {
            ...opt
          });
          return (val) => formatter.format(val);
        }),
        currency: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.NumberFormat(lng, {
            ...opt,
            style: "currency"
          });
          return (val) => formatter.format(val);
        }),
        datetime: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.DateTimeFormat(lng, {
            ...opt
          });
          return (val) => formatter.format(val);
        }),
        relativetime: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.RelativeTimeFormat(lng, {
            ...opt
          });
          return (val) => formatter.format(val, opt.range || "day");
        }),
        list: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.ListFormat(lng, {
            ...opt
          });
          return (val) => formatter.format(val);
        })
      };
      this.init(options);
    }
    init(services) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      const iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
    add(name2, fc2) {
      this.formats[name2.toLowerCase().trim()] = fc2;
    }
    addCached(name2, fc2) {
      this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc2);
    }
    format(value2, format2, lng) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const formats = format2.split(this.formatSeparator);
      if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
        const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
        formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
      }
      const result = formats.reduce((mem, f2) => {
        const {
          formatName,
          formatOptions
        } = parseFormatStr(f2);
        if (this.formats[formatName]) {
          let formatted = mem;
          try {
            const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = this.formats[formatName](mem, l2, {
              ...formatOptions,
              ...options,
              ...valOptions
            });
          } catch (error2) {
            this.logger.warn(error2);
          }
          return formatted;
        } else {
          this.logger.warn(`there was no format function for ${formatName}`);
        }
        return mem;
      }, value2);
      return result;
    }
  }
  const removePending = (q2, name2) => {
    if (q2.pending[name2] !== void 0) {
      delete q2.pending[name2];
      q2.pendingCount--;
    }
  };
  class Connector extends EventEmitter {
    constructor(backend, store, services) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      super();
      this.backend = backend;
      this.store = store;
      this.services = services;
      this.languageUtils = services.languageUtils;
      this.options = options;
      this.logger = baseLogger.create("backendConnector");
      this.waitingReads = [];
      this.maxParallelReads = options.maxParallelReads || 10;
      this.readingCalls = 0;
      this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
      this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
      this.state = {};
      this.queue = [];
      if (this.backend && this.backend.init) {
        this.backend.init(services, options.backend, options);
      }
    }
    queueLoad(languages, namespaces, options, callback) {
      const toLoad = {};
      const pending = {};
      const toLoadLanguages = {};
      const toLoadNamespaces = {};
      languages.forEach((lng) => {
        let hasAllNamespaces = true;
        namespaces.forEach((ns) => {
          const name2 = `${lng}|${ns}`;
          if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
            this.state[name2] = 2;
          } else if (this.state[name2] < 0)
            ;
          else if (this.state[name2] === 1) {
            if (pending[name2] === void 0)
              pending[name2] = true;
          } else {
            this.state[name2] = 1;
            hasAllNamespaces = false;
            if (pending[name2] === void 0)
              pending[name2] = true;
            if (toLoad[name2] === void 0)
              toLoad[name2] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
    loaded(name2, err, data) {
      const s2 = name2.split("|");
      const lng = s2[0];
      const ns = s2[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (!err && data) {
        this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
          skipCopy: true
        });
      }
      this.state[name2] = err ? -1 : 2;
      if (err && data)
        this.state[name2] = 0;
      const loaded = {};
      this.queue.forEach((q2) => {
        pushPath(q2.loaded, [lng], ns);
        removePending(q2, name2);
        if (err)
          q2.errors.push(err);
        if (q2.pendingCount === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach((l2) => {
            if (!loaded[l2])
              loaded[l2] = {};
            const loadedKeys = q2.loaded[l2];
            if (loadedKeys.length) {
              loadedKeys.forEach((n2) => {
                if (loaded[l2][n2] === void 0)
                  loaded[l2][n2] = true;
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded);
      this.queue = this.queue.filter((q2) => !q2.done);
    }
    read(lng, ns, fcName) {
      let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      let callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      const resolver = (err, data) => {
        this.readingCalls--;
        if (this.waitingReads.length > 0) {
          const next = this.waitingReads.shift();
          this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err && data && tried < this.maxRetries) {
          setTimeout(() => {
            this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      };
      const fc2 = this.backend[fcName].bind(this.backend);
      if (fc2.length === 2) {
        try {
          const r2 = fc2(lng, ns);
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => resolver(null, data)).catch(resolver);
          } else {
            resolver(null, r2);
          }
        } catch (err) {
          resolver(err);
        }
        return;
      }
      return fc2(lng, ns, resolver);
    }
    prepareLoading(languages, namespaces) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      const toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach((name2) => {
        this.loadOne(name2);
      });
    }
    load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
    reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
    loadOne(name2) {
      let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const s2 = name2.split("|");
      const lng = s2[0];
      const ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, (err, data) => {
        if (err)
          this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
        if (!err && data)
          this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
        this.loaded(name2, err, data);
      });
    }
    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        const opts = {
          ...options,
          isUpdate
        };
        const fc2 = this.backend.create.bind(this.backend);
        if (fc2.length < 6) {
          try {
            let r2;
            if (fc2.length === 5) {
              r2 = fc2(languages, namespace, key, fallbackValue, opts);
            } else {
              r2 = fc2(languages, namespace, key, fallbackValue);
            }
            if (r2 && typeof r2.then === "function") {
              r2.then((data) => clb(null, data)).catch(clb);
            } else {
              clb(null, r2);
            }
          } catch (err) {
            clb(err);
          }
        } else {
          fc2(languages, namespace, key, fallbackValue, clb, opts);
        }
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }
  const get = () => ({
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: (args) => {
      let ret = {};
      if (typeof args[1] === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (typeof args[2] === "object" || typeof args[3] === "object") {
        const options = args[3] || args[2];
        Object.keys(options).forEach((key) => {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: (value2) => value2,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  });
  const transformOptions = (options) => {
    if (typeof options.ns === "string")
      options.ns = [options.ns];
    if (typeof options.fallbackLng === "string")
      options.fallbackLng = [options.fallbackLng];
    if (typeof options.fallbackNS === "string")
      options.fallbackNS = [options.fallbackNS];
    if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
      options.supportedLngs = options.supportedLngs.concat(["cimode"]);
    }
    return options;
  };
  const noop = () => {
  };
  const bindMemberFunctions = (inst) => {
    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
    mems.forEach((mem) => {
      if (typeof inst[mem] === "function") {
        inst[mem] = inst[mem].bind(inst);
      }
    });
  };
  class I18n extends EventEmitter {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 ? arguments[1] : void 0;
      super();
      this.options = transformOptions(options);
      this.services = {};
      this.logger = baseLogger;
      this.modules = {
        external: []
      };
      bindMemberFunctions(this);
      if (callback && !this.isInitialized && !options.isClone) {
        if (!this.options.initImmediate) {
          this.init(options, callback);
          return this;
        }
        setTimeout(() => {
          this.init(options, callback);
        }, 0);
      }
    }
    init() {
      var _this = this;
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 ? arguments[1] : void 0;
      this.isInitializing = true;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      const defOpts = get();
      this.options = {
        ...defOpts,
        ...this.options,
        ...transformOptions(options)
      };
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = {
          ...defOpts.interpolation,
          ...this.options.interpolation
        };
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      const createClassOnDemand = (ClassOrObject) => {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      };
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        let formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        const lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        const s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s2.formatter = createClassOnDemand(formatter);
          s2.formatter.init(s2, this.options);
          this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
        }
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this.emit(event, ...args);
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          if (s2.languageDetector.init)
            s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init)
            s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this.emit(event, ...args);
        });
        this.modules.external.forEach((m2) => {
          if (m2.init)
            m2.init(this);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach((fcName) => {
        this[fcName] = function() {
          return _this.store[fcName](...arguments);
        };
      });
      const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach((fcName) => {
        this[fcName] = function() {
          _this.store[fcName](...arguments);
          return _this;
        };
      });
      const deferred = defer();
      const load2 = () => {
        const finish = (err, t2) => {
          this.isInitializing = false;
          if (this.isInitialized && !this.initializedStoreOnce)
            this.logger.warn("init: i18next is already initialized. You should call init just once!");
          this.isInitialized = true;
          if (!this.options.isClone)
            this.logger.log("initialized", this.options);
          this.emit("initialized", this.options);
          deferred.resolve(t2);
          callback(err, t2);
        };
        if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
          return finish(null, this.t.bind(this));
        this.changeLanguage(this.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load2();
      } else {
        setTimeout(load2, 0);
      }
      return deferred;
    }
    loadResources(language) {
      let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      let usedCallback = callback;
      const usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
          return usedCallback();
        const toLoad = [];
        const append = (lng) => {
          if (!lng)
            return;
          if (lng === "cimode")
            return;
          const lngs = this.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach((l2) => {
            if (l2 === "cimode")
              return;
            if (toLoad.indexOf(l2) < 0)
              toLoad.push(l2);
          });
        };
        if (!usedLng) {
          const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach((l2) => append(l2));
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach((l2) => append(l2));
        }
        this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
          if (!e2 && !this.resolvedLanguage && this.language)
            this.setResolvedLanguage(this.language);
          usedCallback(e2);
        });
      } else {
        usedCallback(null);
      }
    }
    reloadResources(lngs, ns, callback) {
      const deferred = defer();
      if (typeof lngs === "function") {
        callback = lngs;
        lngs = void 0;
      }
      if (typeof ns === "function") {
        callback = ns;
        ns = void 0;
      }
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop;
      this.services.backendConnector.reload(lngs, ns, (err) => {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
    use(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "formatter") {
        this.modules.formatter = module;
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
    setResolvedLanguage(l2) {
      if (!l2 || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l2) > -1)
        return;
      for (let li2 = 0; li2 < this.languages.length; li2++) {
        const lngInLngs = this.languages[li2];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
    changeLanguage(lng, callback) {
      var _this2 = this;
      this.isLanguageChangingTo = lng;
      const deferred = defer();
      this.emit("languageChanging", lng);
      const setLngProps = (l2) => {
        this.language = l2;
        this.languages = this.services.languageUtils.toResolveHierarchy(l2);
        this.resolvedLanguage = void 0;
        this.setResolvedLanguage(l2);
      };
      const done = (err, l2) => {
        if (l2) {
          setLngProps(l2);
          this.translator.changeLanguage(l2);
          this.isLanguageChangingTo = void 0;
          this.emit("languageChanged", l2);
          this.logger.log("languageChanged", l2);
        } else {
          this.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this2.t(...arguments);
        });
        if (callback)
          callback(err, function() {
            return _this2.t(...arguments);
          });
      };
      const setLng = (lngs) => {
        if (!lng && !lngs && this.services.languageDetector)
          lngs = [];
        const l2 = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!this.language) {
            setLngProps(l2);
          }
          if (!this.translator.language)
            this.translator.changeLanguage(l2);
          if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage)
            this.services.languageDetector.cacheUserLanguage(l2);
        }
        this.loadResources(l2, (err) => {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        if (this.services.languageDetector.detect.length === 0) {
          this.services.languageDetector.detect().then(setLng);
        } else {
          this.services.languageDetector.detect(setLng);
        }
      } else {
        setLng(lng);
      }
      return deferred;
    }
    getFixedT(lng, ns, keyPrefix) {
      var _this3 = this;
      const fixedT = function(key, opts) {
        let options;
        if (typeof opts !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = {
            ...opts
          };
        }
        options.lng = options.lng || fixedT.lng;
        options.lngs = options.lngs || fixedT.lngs;
        options.ns = options.ns || fixedT.ns;
        if (options.keyPrefix !== "")
          options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
        const keySeparator = _this3.options.keySeparator || ".";
        let resultKey;
        if (options.keyPrefix && Array.isArray(key)) {
          resultKey = key.map((k2) => `${options.keyPrefix}${keySeparator}${k2}`);
        } else {
          resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
        }
        return _this3.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
    t() {
      return this.translator && this.translator.translate(...arguments);
    }
    exists() {
      return this.translator && this.translator.exists(...arguments);
    }
    setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
    hasLoadedNamespace(ns) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      const lng = options.lng || this.resolvedLanguage || this.languages[0];
      const fallbackLng = this.options ? this.options.fallbackLng : false;
      const lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      const loadNotPending = (l2, n2) => {
        const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
        return loadState === -1 || loadState === 0 || loadState === 2;
      };
      if (options.precheck) {
        const preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
    loadNamespaces(ns, callback) {
      const deferred = defer();
      if (!this.options.ns) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach((n2) => {
        if (this.options.ns.indexOf(n2) < 0)
          this.options.ns.push(n2);
      });
      this.loadResources((err) => {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
    loadLanguages(lngs, callback) {
      const deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      const preloaded = this.options.preload || [];
      const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources((err) => {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
    dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
      return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
    static createInstance() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 ? arguments[1] : void 0;
      return new I18n(options, callback);
    }
    cloneInstance() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      const forkResourceStore = options.forkResourceStore;
      if (forkResourceStore)
        delete options.forkResourceStore;
      const mergedOptions = {
        ...this.options,
        ...options,
        ...{
          isClone: true
        }
      };
      const clone = new I18n(mergedOptions);
      if (options.debug !== void 0 || options.prefix !== void 0) {
        clone.logger = clone.logger.clone(options);
      }
      const membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach((m2) => {
        clone[m2] = this[m2];
      });
      clone.services = {
        ...this.services
      };
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      if (forkResourceStore) {
        clone.store = new ResourceStore(this.store.data, mergedOptions);
        clone.services.resourceStore = clone.store;
      }
      clone.translator = new Translator(clone.services, mergedOptions);
      clone.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone.emit(event, ...args);
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = mergedOptions;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
    toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }
  const instance = I18n.createInstance();
  instance.createInstance = I18n.createInstance;
  instance.createInstance;
  instance.dir;
  instance.init;
  instance.loadResources;
  instance.reloadResources;
  instance.use;
  instance.changeLanguage;
  instance.getFixedT;
  instance.t;
  instance.exists;
  instance.setDefaultNamespace;
  instance.hasLoadedNamespace;
  instance.loadNamespaces;
  instance.loadLanguages;
  instance.use(initReactI18next).init({
    resources: {
      en: {
        translation: {
          report: "Report 🐞",
          "login-message": "Log in to 4Geeks to get performance statistics, access to our AI mentor, and many other benefits.",
          Run: "Run",
          theme: "Theme",
          "Run tests": "Run tests",
          "Running...": "Running...",
          "Login to use AI feedback": "Login to get help from AI Mentor",
          login: "Sign in",
          "Get help from AI": "Rigobot AI Mentor",
          "To use the AI services you must login with your 4geeks account, and you have been accepted Rigobot": "To use the AI services you must login with your 4geeks account, and you have been accepted Rigobot",
          Password: "Password",
          "Don't have an account? ": "Don't have an account? ",
          "Sign up here!": "Sign up here!",
          "Loading...": "Loading...",
          submit: "Sign in",
          "Review model solution": "Review model solution",
          "Model solution not available": "Model solution not available",
          Reset: "Start over",
          "not available": "not available",
          "About LearnPack": "About LearnPack",
          "Feedback plays an important role when learning technical skills. ": "Feedback plays an important role when learning technical skills. ",
          "Learn why": "Learn why",
          "Are you sure you want to reset the exercise? You will lose all your progress": "Are you sure you want to reset the exercise? You will lose all your progress",
          Cancel: "Cancel",
          "Report a bug 🪰": "Report a bug 🪰",
          "solved-tests": "Solved tests",
          "Get feedback": "Get help",
          "Try again": "Try again",
          "Current version": "Current version",
          "Rigobot AI-Tutor": "Rigobot AI-Tutor",
          "Ask me something here": "Ask me something here",
          "This AI, currently in beta, serves as an educational tutor. It is not a substitute for professional instruction. Use at your own risk and confirm details with authoritative educational resources.": "This AI, currently in beta, serves as an educational tutor. It is not a substitute for professional instruction. Use at your own risk and confirm details with authoritative educational resources.",
          "Hello! I'm **Rigobot**, your friendly **AI Mentor**! \n\n I can help you if you feel stuck, ask me anything about this exercise!": "Hello! I'm **Rigobot**, your friendly **AI Mentor**! \n\n I can help you if you feel stuck, ask me anything about this exercise!",
          "The run button": "The run button",
          "No tests available": "No tests available",
          Succeded: "Succeded",
          "Socket disconnected!": "Socket disconnected!",
          Reload: "Reload",
          "Sorry, this error can happen for certain reasons.": "Sorry, this error can happen for certain reasons.",
          "The basic steps to troubleshoot this error are the following:": "The basic steps to troubleshoot this error are the following:",
          "Step 1": "Step 1",
          "Check that Learnpack is running in your terminal.": "Check that Learnpack is running in your terminal.",
          "Run: ": "Run: ",
          "Step 2": "Step 2",
          "If Learnpack is running but you still see this modal, reload the window:": "If Learnpack is running but you still see this modal, reload the window:",
          "Use this button to compile and run your code.": "Use this button to compile and run your code.",
          "Sometimes you want to start over, use this button to reset the code.": "Sometimes you want to start over, use this button to reset the code.",
          "Options to get feedback": "Options to get feedback",
          "Whithin this dropdown you can get feedback on your code.": "Whithin this dropdown you can get feedback on your code.",
          skip: "Skip",
          "incremental-test-alert": "You must successfully complete and test this step before continuing to the next one. Carefully read the instructions and ask for feedback if you need any help.",
          "agent-mismatch-error": "These exercises were designed to run in a different agent",
          instructions: "Instructions",
          "read-instructions": "Read the instructions and fill in your code to complete the exercise.",
          "prev-session": "You have a session opened in another place, do you want to continue your progress here or start from scratch?",
          "continue-here": "Continue here",
          "start-again": "Start again",
          "we-got-you-covered": "We got you covered",
          "please-select-option": "Please select an option",
          code: "Code",
          output: "Output",
          "compile-first": "You must compile or test your code to see the output",
          or: "or",
          "login-github": "Login with Github",
          continue: "Continue",
          "change-theme": "Change theme",
          exercises: "Exercises",
          "you-must-login-title": "Oops! Looks like you're not logged in.",
          "you-must-login-message": "To compile code on the web and use our AI mentor Rigobot, please log in first!",
          "execute-my-code": "Execute my code",
          "test-my-code": "Test my code",
          "display-another-tab": "Display in another tab",
          "close-tab": "Close tab",
          "redirecting-to-github": "Redirecting to GitHub...",
          "code-copied": "Code copied to clipboard",
          "double-click-to-copy": "Double click to copy this code",
          "model-solution": "Model Solution",
          "tests-feedback": "Tests Feedback",
          "terminal": "Terminal",
          "submit-quiz": "Submit quiz",
          "ask-rigo-for-a-hint": "Ask Rigobot for a hint",
          "can-you-give-me-a-hint": "Can you give me a hint?",
          "forgot-password": "Forgot your password? ",
          "recover-it-here": "Recover it here"
        }
      },
      es: {
        translation: {
          theme: "Tema",
          report: "Reportar 🐞",
          login: "Inicia sesión",
          Run: "Ejecutar",
          "Running...": "Ejecutando...",
          "Run tests": "Ejecutar tests",
          "Login to use AI feedback": "Inicia sesión para obtener ayuda del Mentor IA",
          "Get help from AI": "Obtener ayuda de Rigobot AI",
          "To use the AI services you must login with your 4geeks account, and you have been accepted Rigobot": "Para usar los servicios de IA, debes iniciar sesión con tu cuenta de 4geeks y haber aceptado los servicios de Rigobot",
          Password: "Contraseña",
          "Don't have an account? ": "¿No tienes una cuenta? ",
          "Sign up here!": "¡Regístrate aquí!",
          "Loading...": "Cargando...",
          "Review model solution": "Revisar solución modelo",
          submit: "Iniciar sesión",
          "Model solution not available": "Solución modelo no disponible",
          Reset: "Reiniciar",
          "not available": "no disponible",
          "About LearnPack": "Acerca de LearnPack",
          "Feedback plays an important role when learning technical skills. ": "La retroalimentación juega un papel importante al aprender habilidades técnicas. ",
          "Learn why": "Aprende por qué",
          "Are you sure you want to reset the exercise? You will lose all your progress": "¿Estás seguro de que quieres reiniciar el ejercicio? Perderás todo tu progreso",
          Cancel: "Cancelar",
          "Report a bug 🪰": "Reportar un error 🪰",
          "solved-tests": "Tests resueltos",
          "Get feedback": "Obtener ayuda",
          "Try again": "Intenta de nuevo",
          "Current version": "Versión actual",
          "Rigobot AI-Tutor": "Rigobot AI",
          "Ask me something here": "Escribe acá tus preguntas",
          "This AI, currently in beta, serves as an educational tutor. It is not a substitute for professional instruction. Use at your own risk and confirm details with authoritative educational resources.": "Esta IA, actualmente en beta, sirve como tutor educativo. No es un sustituto de la instrucción profesional. Úsalo bajo tu propio riesgo y confirma los detalles con recursos educativos autorizados.",
          "Hello! I'm **Rigobot**, your friendly **AI Mentor**! \n\n I can help you if you feel stuck, ask me anything about this exercise!": "¡Hola! Soy Rigobot, tu amigable Mentor AI, puedo ayudarte si te sientes atascado, ¡pregúntame cualquier cosa sobre este ejercicio!",
          "No tests available": "No hay tests disponibles",
          Succeded: "¡Perfecto!",
          "Socket disconnected!": "¡Conexión perdida!",
          Reload: "Recargar",
          "Sorry, this error can happen for certain reasons.": "Lo siento, este error puede ocurrir por ciertas razones.",
          "The basic steps to troubleshoot this error are the following:": "Los pasos básicos para solucionar este error son los siguientes:",
          "Step 1": "Paso 1",
          "Check that Learnpack is running in your terminal.": "Verifica que Learnpack esté corriendo en tu terminal.",
          "Run: ": "Ejecuta: ",
          "Step 2": "Paso 2",
          "If Learnpack is running but you still see this modal, reload the window:": "Si Learnpack está corriendo pero aún ves este modal, recarga la ventana:",
          "The run button": "El botón de ejecución",
          "Use this button to compile or run your code. The behavior depends of the files in the exercise directory. You can also use the shortcut `Ctrl` + `Enter` to run the code.": "Usa este botón para compilar o ejecutar tu código. El comportamiento depende de los archivos en el directorio del ejercicio. También puedes usar el atajo `Ctrl` + `Enter` para ejecutar el código.",
          "Options to get feedback": "Opciones para obtener ayuda",
          "Within this dropdown you can get feedback on your code. Let's try the available ones! You can use the following shortcuts:\n\n`Ctrl` + `Shift` + `Enter`: Run the tests if available. \n\n`Ctrl` + `Alt` + `Enter`: Open the chat with Rigobot": "Dentro de este menú desplegable puedes obtener ayuda con tu código. ¡Probemos las disponibles! Puedes usar los siguientes atajos:\n\n`Ctrl` + `Shift` + `Enter`: Ejecutar los tests si están disponibles. \n\n`Ctrl` + `Alt` + `Enter`: Abrir el chat con Rigobot",
          "Inside the sidebar you can go through the exercises and see your progress. Also you can report a bug.": "Dentro de la barra lateral puedes revisar los ejercicios y ver tu progreso. También puedes reportar un error.",
          "Open the sidebar": "Abrir la barra lateral",
          "Sometimes you want to start over, use this button to `reset` the code to its original state.": "A veces quieres empezar de nuevo, usa este botón para `reiniciar` el código a su estado original.",
          "Reset button": "Botón de reinicio",
          "Click on the flag to change the language.": "Haz clic en la bandera para cambiar el idioma.",
          "Welcome to LearnPack!": "¡Bienvenido a LearnPack!",
          "If you prefer, you can change the language!": "¡Si prefieres, puedes cambiar el idioma!",
          "This is a quick tutorial to help you get started. Click next to continue.": "Este es un tutorial rápido para ayudarte a comenzar. Haz clic en siguiente para continuar.",
          "login-message": "Inicia session en 4Geeks para obtener estadisticas de tu desempeño, acceso al nuestro mentor AI y muchos otros beneficios.",
          skip: "Saltar",
          "incremental-test-alert": "Debes completar y probar con éxito este paso antes de continuar con el siguiente. Lee cuidadosamente las instrucciones y pide retroalimentación si necesitas ayuda.",
          "agent-mismatch-error": "Estos ejercicios fueron diseñados para ejecutarse en un agente diferente",
          instructions: "Instrucciones",
          "read-instructions": "Lee las instrucciones y rellena tu codigo para compltar el ejercicio",
          "prev-session": "Tienes una sesión abierta en otro lugar, ¿quieres continuar con tu progreso acá o empezar desde cero?",
          "continue-here": "Seguir acá",
          "start-again": "Empezar de nuevo",
          "we-got-you-covered": "Te tenemos cubierto",
          "please-select-option": "Por favor selecciona una opción",
          code: "Código",
          output: "Salida",
          "compile-first": "Tienes que compilar o testear tu código para ver la salida",
          or: "o",
          "login-github": "Loggeate con Github",
          continue: "Sigue adelante",
          "change-theme": "Cambia el tema",
          exercises: "Ejercicios",
          "you-must-login-title": "¡Ups! Parece que no has iniciado sesión.",
          "you-must-login-message": "Para compilar código en la web y usar nuestro mentor AI Rigobot, ¡por favor inicia sesión primero!",
          "execute-my-code": "Ejecutar mi código",
          "test-my-code": "Testear mi código",
          "display-another-tab": "Mostrar en otra pestaña",
          "close-tab": "Cerrar pestaña",
          "redirecting-to-github": "Redirigiendo a GitHub...",
          "code-copied": "Código copiado al portapapeles",
          "double-click-to-copy": "Doble clic para copiar este código",
          "model-solution": "Solución modelo",
          "tests-feedback": "Resultados de los tests",
          "terminal": "Terminal",
          "submit-quiz": "Enviar cuestionario",
          "ask-rigo-for-a-hint": "Preguntar a Rigobot por una pista",
          "can-you-give-me-a-hint": "¿Puedes darme una pista?",
          "forgot-password": "¿Olvidaste tu contraseña?",
          "recover-it-here": "Recuperala aquí"
        }
      }
    },
    lng: "en",
    fallbackLng: "en",
    interpolation: {
      escapeValue: false
    }
  });
  const svgsLanguageMap = {
    es: svgs.spainFlag,
    us: svgs.usaFlag
  };
  function LanguageButton() {
    const { language } = useStore((state) => ({
      language: state.language
    }));
    reactExports.useEffect(() => {
      instance.changeLanguage(language);
    }, []);
    const [showDrop, setShowDropdown] = reactExports.useState(false);
    const toggleDrop = () => {
      setShowDropdown(!showDrop);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "language-component", className: "language-component", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          action: toggleDrop,
          text: language,
          svg: svgsLanguageMap[language]
        }
      ),
      showDrop && /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageDropdown, { toggleDrop })
    ] }) });
  }
  const LanguageDropdown = ({ toggleDrop }) => {
    const { language, setLanguage, getCurrentExercise } = useStore((state) => ({
      language: state.language,
      setLanguage: state.setLanguage,
      getCurrentExercise: state.getCurrentExercise
    }));
    const languages = Object.keys(getCurrentExercise().translations);
    const changeLanguage = (lang) => {
      instance.changeLanguage(lang);
    };
    const setLang = (lang) => {
      setLanguage(lang);
      changeLanguage(lang);
      toggleDrop();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "language-dropdown", children: languages.map(
      (l2, index2) => l2 !== language ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: () => setLang(l2), children: [
        svgsLanguageMap[l2],
        l2
      ] }, index2) : null
    ) });
  };
  function BugButton() {
    const { t: t2 } = useTranslation();
    const { currentExercisePosition, exercises, lessonTitle } = useStore(
      (state) => ({
        currentExercisePosition: state.currentExercisePosition,
        exercises: state.exercises,
        lessonTitle: state.lessonTitle
      })
    );
    let defaultTitle = "Bug";
    if (currentExercisePosition != 0) {
      defaultTitle = `Bug in ${exercises[Number(currentExercisePosition)].slug}`;
    }
    const body = `Lesson: ${lessonTitle} %0D%0A
    %0D%0AExplain the problem %0D%0A
    %0D%0AProvide an image or example of the problem %0D%0A

    `;
    const url2 = `https://github.com/learnpack/learnpack/issues/new?assignees=&labels=&projects=&template=bug_report.md&title=${defaultTitle}&body=${body}`;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(OpenWindowLink, { href: url2, text: t2("report") });
  }
  function ExercisesList({ closeSidebar }) {
    const { exercises } = useStore((state) => ({
      exercises: state.exercises
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "exercise-list", children: exercises.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ExerciseCard, { ...item, closeSidebar }, index2)) });
  }
  function ExerciseCard({
    title,
    position,
    closeSidebar,
    graded,
    done
  }) {
    const { handlePositionChange } = useStore((state) => ({
      handlePositionChange: state.handlePositionChange
    }));
    const titlefy = (str2) => {
      let arr = str2.split("-");
      arr.shift();
      let result = arr.join(" ");
      result = result.charAt(0).toUpperCase() + result.slice(1);
      return result;
    };
    const getNameWithoutNumber = (str2) => {
      return titlefy(str2);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "li",
      {
        className: "exercise-card",
        onClick: () => {
          handlePositionChange(position);
          closeSidebar();
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "blue-circle", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: title.split("-")[0] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getNameWithoutNumber(title) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: graded && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleButton,
            {
              svg: done ? svgs.checkIcon : svgs.blankCircle,
              text: ""
            }
          ) })
        ]
      }
    );
  }
  const name = "learnpack-ai";
  const version$1 = "5.0.8";
  const scripts = {
    dev: "node src/utils/development.js --turn on && vite",
    build: "node src/utils/checkDeleted.js && node src/utils/development.js --turn off && tsc && vite build && node bin/publish.js && node src/utils/createVersionsFile.js",
    "dev-build": "node src/utils/development.js --turn on && tsc && vite build",
    lint: "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    preview: "vite preview",
    "compile-command": "tsc src/utils/development.ts && node src/utils/development.js --turn on"
  };
  const dependencies = {
    "@monaco-editor/react": "^4.6.0",
    axios: "^1.7.7",
    "front-matter": "^4.0.2",
    i18next: "^23.10.1",
    "markdown-it": "^14.1.0",
    "markdown-it-task-lists": "^2.1.1",
    "monaco-editor": "^0.50.0",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    "react-draggable": "^4.4.6",
    "react-gtm-module": "^2.0.11",
    "react-hot-toast": "^2.4.1",
    "react-i18next": "^14.1.0",
    "react-monaco-editor": "^0.56.1",
    "react-router-dom": "^6.27.0",
    remarkable: "^2.0.1",
    "remarkable-katex": "^1.2.1",
    "socket.io": "^4.7.2",
    "socket.io-client": "^4.7.2",
    uuid: "^10.0.0",
    zustand: "^4.4.1"
  };
  const devDependencies = {
    "@types/markdown-it": "^14.1.2",
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@types/react-gtm-module": "^2.0.3",
    "@types/react-syntax-highlighter": "^15.5.13",
    "@types/remarkable": "^2.0.3",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@vitejs/plugin-react-swc": "^3.3.2",
    archiver: "^6.0.1",
    eslint: "^8.45.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.3",
    inquirer: "^9.2.12",
    typescript: "^5.0.2",
    vite: "^4.4.5"
  };
  const packageInfo = {
    name,
    "private": true,
    version: version$1,
    scripts,
    dependencies,
    devDependencies
  };
  const styles$4 = "";
  const version = packageInfo.version;
  let versionSections = version.split(".");
  versionSections[2] = String(parseInt(versionSections[2]) + 1);
  function drawCircle(percentage) {
    const canvas = document.getElementById(
      "percentageCanvas"
    );
    if (!canvas)
      return;
    const ctx = canvas.getContext("2d");
    const radius = 20;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    if (!ctx)
      return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(224, 224, 224, 0.311)";
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(
      centerX,
      centerY,
      radius,
      -Math.PI / 2,
      Math.PI * 2 * percentage - Math.PI / 2
    );
    ctx.closePath();
    ctx.fillStyle = "#21b761";
    ctx.fill();
  }
  function Sidebar() {
    const { t: t2 } = useTranslation();
    const { configObject, language, lessonTitle, theme, toggleTheme, exercises } = useStore((state) => ({
      configObject: state.configObject,
      language: state.language,
      lessonTitle: state.lessonTitle,
      theme: state.theme,
      toggleTheme: state.toggleTheme,
      exercises: state.exercises
    }));
    const [showSidebar, setShowSidebar] = reactExports.useState(false);
    const [progress, setProgress] = reactExports.useState({
      solved: exercises && exercises.filter ? exercises.filter((e2) => e2.done === true).length : 0,
      graded: exercises && exercises.filter ? exercises.filter((e2) => e2.graded).length : 0
    });
    let title = lessonTitle;
    if (configObject && configObject.config && typeof configObject.config.title === "object") {
      if (Object.keys(configObject.config.title).includes(language)) {
        title = configObject.config.title[language];
      }
    }
    const closeSidebar = () => {
      const sidebar = document.querySelector(".sidebar-component");
      sidebar == null ? void 0 : sidebar.classList.add("sidebar-disappear");
      sidebar == null ? void 0 : sidebar.addEventListener("animationend", () => {
        setShowSidebar(false);
      });
    };
    reactExports.useEffect(() => {
      const _progress = {
        solved: exercises.filter((e2) => e2.done === true).length,
        graded: exercises.filter((e2) => e2.graded).length
      };
      setProgress(_progress);
      const percentage = _progress.solved / _progress.graded;
      drawCircle(percentage);
    }, [showSidebar]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      showSidebar && reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sidebar-component", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("section", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: title }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "min-width", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "d-flex align-center gap-small", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "canvas",
                {
                  width: "50",
                  height: "50",
                  id: "percentageCanvas"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                progress.solved,
                "/",
                progress.graded,
                " ",
                t2("solved")
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleButton, { action: closeSidebar, svg: svgs.closeIcon })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ExercisesList, { closeSidebar }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "footer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(BugButton, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              "v",
              versionSections.join(".")
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SimpleButton,
              {
                text: t2("theme"),
                action: toggleTheme,
                extraClass: "clickeable pill",
                svg: theme === "dark" ? svgs.sun : svgs.moon
              }
            )
          ] })
        ] }) }),
        document.body
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          svg: svgs.dropdownButton,
          id: "sidebar-toggle",
          action: () => {
            setShowSidebar(true);
          }
        }
      )
    ] });
  }
  const header = "_header_13t9m_1";
  const styles$3 = {
    header
  };
  const NewHeader = () => {
    const {
      handlePositionChange,
      currentExercisePosition,
      exercises,
      test: test2,
      isIframe,
      language
    } = useStore((state) => ({
      handlePositionChange: state.handlePositionChange,
      currentExercisePosition: state.currentExercisePosition,
      exercises: state.exercises,
      test: state.test,
      isIframe: state.isIframe,
      language: state.language
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: styles$3.header, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            disabled: currentExercisePosition == 0,
            onClick: () => handlePositionChange(Number(currentExercisePosition) - 1),
            children: svgs.prevArrowButton
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            disabled: exercises && currentExercisePosition === exercises.length - 1,
            onClick: () => handlePositionChange(Number(currentExercisePosition) + 1),
            children: svgs.nextArrowButton
          }
        ),
        DEV_MODE
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("section", { children: svgs.learnpackLogo }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { children: [
        !isIframe && language && /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageButton, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Sidebar, {})
      ] })
    ] });
  };
  const container = "_container_1uhni_1";
  const appTabs = "_appTabs_1uhni_51";
  const hiddenOnMobile = "_hiddenOnMobile_1uhni_91";
  const styles$2 = {
    container,
    appTabs,
    hiddenOnMobile
  };
  function _defineProperty$1(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2$1(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys$1(Object(source), true).forEach(function(key) {
          _defineProperty$1(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$1(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _iterableToArrayLimit(arr, i2) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function compose$1() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }
    return function(x2) {
      return fns.reduceRight(function(y2, f2) {
        return f2(y2);
      }, x2);
    };
  }
  function curry$1(fn) {
    return function curried() {
      var _this = this;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return args.length >= fn.length ? fn.apply(this, args) : function() {
        for (var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          nextArgs[_key3] = arguments[_key3];
        }
        return curried.apply(_this, [].concat(args, nextArgs));
      };
    };
  }
  function isObject$1(value2) {
    return {}.toString.call(value2).includes("Object");
  }
  function isEmpty(obj) {
    return !Object.keys(obj).length;
  }
  function isFunction(value2) {
    return typeof value2 === "function";
  }
  function hasOwnProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  function validateChanges(initial, changes) {
    if (!isObject$1(changes))
      errorHandler$1("changeType");
    if (Object.keys(changes).some(function(field) {
      return !hasOwnProperty(initial, field);
    }))
      errorHandler$1("changeField");
    return changes;
  }
  function validateSelector(selector) {
    if (!isFunction(selector))
      errorHandler$1("selectorType");
  }
  function validateHandler(handler) {
    if (!(isFunction(handler) || isObject$1(handler)))
      errorHandler$1("handlerType");
    if (isObject$1(handler) && Object.values(handler).some(function(_handler) {
      return !isFunction(_handler);
    }))
      errorHandler$1("handlersType");
  }
  function validateInitial(initial) {
    if (!initial)
      errorHandler$1("initialIsRequired");
    if (!isObject$1(initial))
      errorHandler$1("initialType");
    if (isEmpty(initial))
      errorHandler$1("initialContent");
  }
  function throwError$1(errorMessages2, type2) {
    throw new Error(errorMessages2[type2] || errorMessages2["default"]);
  }
  var errorMessages$1 = {
    initialIsRequired: "initial state is required",
    initialType: "initial state should be an object",
    initialContent: "initial state shouldn't be an empty object",
    handlerType: "handler should be an object or a function",
    handlersType: "all handlers should be a functions",
    selectorType: "selector should be a function",
    changeType: "provided value of changes should be an object",
    changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
    "default": "an unknown error accured in `state-local` package"
  };
  var errorHandler$1 = curry$1(throwError$1)(errorMessages$1);
  var validators$1 = {
    changes: validateChanges,
    selector: validateSelector,
    handler: validateHandler,
    initial: validateInitial
  };
  function create(initial) {
    var handler = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    validators$1.initial(initial);
    validators$1.handler(handler);
    var state = {
      current: initial
    };
    var didUpdate = curry$1(didStateUpdate)(state, handler);
    var update = curry$1(updateState)(state);
    var validate = curry$1(validators$1.changes)(initial);
    var getChanges = curry$1(extractChanges)(state);
    function getState2() {
      var selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(state2) {
        return state2;
      };
      validators$1.selector(selector);
      return selector(state.current);
    }
    function setState2(causedChanges) {
      compose$1(didUpdate, update, validate, getChanges)(causedChanges);
    }
    return [getState2, setState2];
  }
  function extractChanges(state, causedChanges) {
    return isFunction(causedChanges) ? causedChanges(state.current) : causedChanges;
  }
  function updateState(state, changes) {
    state.current = _objectSpread2(_objectSpread2({}, state.current), changes);
    return changes;
  }
  function didStateUpdate(state, handler, changes) {
    isFunction(handler) ? handler(state.current) : Object.keys(changes).forEach(function(field) {
      var _handler$field;
      return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state.current[field]);
    });
    return changes;
  }
  var index = {
    create
  };
  var config$1 = {
    paths: {
      vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs"
    }
  };
  function curry(fn) {
    return function curried() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return args.length >= fn.length ? fn.apply(this, args) : function() {
        for (var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          nextArgs[_key2] = arguments[_key2];
        }
        return curried.apply(_this, [].concat(args, nextArgs));
      };
    };
  }
  function isObject(value2) {
    return {}.toString.call(value2).includes("Object");
  }
  function validateConfig(config2) {
    if (!config2)
      errorHandler("configIsRequired");
    if (!isObject(config2))
      errorHandler("configType");
    if (config2.urls) {
      informAboutDeprecation();
      return {
        paths: {
          vs: config2.urls.monacoBase
        }
      };
    }
    return config2;
  }
  function informAboutDeprecation() {
    console.warn(errorMessages.deprecation);
  }
  function throwError(errorMessages2, type2) {
    throw new Error(errorMessages2[type2] || errorMessages2["default"]);
  }
  var errorMessages = {
    configIsRequired: "the configuration object is required",
    configType: "the configuration object should be an object",
    "default": "an unknown error accured in `@monaco-editor/loader` package",
    deprecation: "Deprecation warning!\n    You are using deprecated way of configuration.\n\n    Instead of using\n      monaco.config({ urls: { monacoBase: '...' } })\n    use\n      monaco.config({ paths: { vs: '...' } })\n\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\n  "
  };
  var errorHandler = curry(throwError)(errorMessages);
  var validators = {
    config: validateConfig
  };
  var compose = function compose2() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }
    return function(x2) {
      return fns.reduceRight(function(y2, f2) {
        return f2(y2);
      }, x2);
    };
  };
  function merge(target, source) {
    Object.keys(source).forEach(function(key) {
      if (source[key] instanceof Object) {
        if (target[key]) {
          Object.assign(source[key], merge(target[key], source[key]));
        }
      }
    });
    return _objectSpread2$1(_objectSpread2$1({}, target), source);
  }
  var CANCELATION_MESSAGE = {
    type: "cancelation",
    msg: "operation is manually canceled"
  };
  function makeCancelable(promise) {
    var hasCanceled_ = false;
    var wrappedPromise = new Promise(function(resolve, reject) {
      promise.then(function(val) {
        return hasCanceled_ ? reject(CANCELATION_MESSAGE) : resolve(val);
      });
      promise["catch"](reject);
    });
    return wrappedPromise.cancel = function() {
      return hasCanceled_ = true;
    }, wrappedPromise;
  }
  var _state$create = index.create({
    config: config$1,
    isInitialized: false,
    resolve: null,
    reject: null,
    monaco: null
  }), _state$create2 = _slicedToArray(_state$create, 2), getState = _state$create2[0], setState = _state$create2[1];
  function config(globalConfig) {
    var _validators$config = validators.config(globalConfig), monaco = _validators$config.monaco, config2 = _objectWithoutProperties(_validators$config, ["monaco"]);
    setState(function(state) {
      return {
        config: merge(state.config, config2),
        monaco
      };
    });
  }
  function init() {
    var state = getState(function(_ref) {
      var monaco = _ref.monaco, isInitialized = _ref.isInitialized, resolve = _ref.resolve;
      return {
        monaco,
        isInitialized,
        resolve
      };
    });
    if (!state.isInitialized) {
      setState({
        isInitialized: true
      });
      if (state.monaco) {
        state.resolve(state.monaco);
        return makeCancelable(wrapperPromise);
      }
      if (window.monaco && window.monaco.editor) {
        storeMonacoInstance(window.monaco);
        state.resolve(window.monaco);
        return makeCancelable(wrapperPromise);
      }
      compose(injectScripts, getMonacoLoaderScript)(configureLoader);
    }
    return makeCancelable(wrapperPromise);
  }
  function injectScripts(script) {
    return document.body.appendChild(script);
  }
  function createScript(src) {
    var script = document.createElement("script");
    return src && (script.src = src), script;
  }
  function getMonacoLoaderScript(configureLoader2) {
    var state = getState(function(_ref2) {
      var config2 = _ref2.config, reject = _ref2.reject;
      return {
        config: config2,
        reject
      };
    });
    var loaderScript = createScript("".concat(state.config.paths.vs, "/loader.js"));
    loaderScript.onload = function() {
      return configureLoader2();
    };
    loaderScript.onerror = state.reject;
    return loaderScript;
  }
  function configureLoader() {
    var state = getState(function(_ref3) {
      var config2 = _ref3.config, resolve = _ref3.resolve, reject = _ref3.reject;
      return {
        config: config2,
        resolve,
        reject
      };
    });
    var require2 = window.require;
    require2.config(state.config);
    require2(["vs/editor/editor.main"], function(monaco) {
      storeMonacoInstance(monaco);
      state.resolve(monaco);
    }, function(error2) {
      state.reject(error2);
    });
  }
  function storeMonacoInstance(monaco) {
    if (!getState().monaco) {
      setState({
        monaco
      });
    }
  }
  function __getMonacoInstance() {
    return getState(function(_ref4) {
      var monaco = _ref4.monaco;
      return monaco;
    });
  }
  var wrapperPromise = new Promise(function(resolve, reject) {
    return setState({
      resolve,
      reject
    });
  });
  var loader = {
    config,
    init,
    __getMonacoInstance
  };
  var le = { wrapper: { display: "flex", position: "relative", textAlign: "initial" }, fullWidth: { width: "100%" }, hide: { display: "none" } }, v = le;
  var ae = { container: { display: "flex", height: "100%", width: "100%", justifyContent: "center", alignItems: "center" } }, Y = ae;
  function Me({ children: e2 }) {
    return React$1.createElement("div", { style: Y.container }, e2);
  }
  var Z = Me;
  var $ = Z;
  function Ee({ width: e2, height: r2, isEditorReady: n2, loading: t2, _ref: a2, className: m2, wrapperProps: E2 }) {
    return React$1.createElement("section", { style: { ...v.wrapper, width: e2, height: r2 }, ...E2 }, !n2 && React$1.createElement($, null, t2), React$1.createElement("div", { ref: a2, style: { ...v.fullWidth, ...!n2 && v.hide }, className: m2 }));
  }
  var ee = Ee;
  var H = reactExports.memo(ee);
  function Ce(e2) {
    reactExports.useEffect(e2, []);
  }
  var k = Ce;
  function he(e2, r2, n2 = true) {
    let t2 = reactExports.useRef(true);
    reactExports.useEffect(t2.current || !n2 ? () => {
      t2.current = false;
    } : e2, r2);
  }
  var l = he;
  function D() {
  }
  function h(e2, r2, n2, t2) {
    return De(e2, t2) || be(e2, r2, n2, t2);
  }
  function De(e2, r2) {
    return e2.editor.getModel(te(e2, r2));
  }
  function be(e2, r2, n2, t2) {
    return e2.editor.createModel(r2, n2, t2 ? te(e2, t2) : void 0);
  }
  function te(e2, r2) {
    return e2.Uri.parse(r2);
  }
  function Oe({ original: e2, modified: r2, language: n2, originalLanguage: t2, modifiedLanguage: a2, originalModelPath: m2, modifiedModelPath: E2, keepCurrentOriginalModel: g2 = false, keepCurrentModifiedModel: N2 = false, theme: x2 = "light", loading: P2 = "Loading...", options: y2 = {}, height: V2 = "100%", width: z2 = "100%", className: F2, wrapperProps: j2 = {}, beforeMount: A2 = D, onMount: q2 = D }) {
    let [M2, O2] = reactExports.useState(false), [T2, s2] = reactExports.useState(true), u2 = reactExports.useRef(null), c2 = reactExports.useRef(null), w2 = reactExports.useRef(null), d2 = reactExports.useRef(q2), o2 = reactExports.useRef(A2), b2 = reactExports.useRef(false);
    k(() => {
      let i2 = loader.init();
      return i2.then((f2) => (c2.current = f2) && s2(false)).catch((f2) => (f2 == null ? void 0 : f2.type) !== "cancelation" && console.error("Monaco initialization: error:", f2)), () => u2.current ? I2() : i2.cancel();
    }), l(() => {
      if (u2.current && c2.current) {
        let i2 = u2.current.getOriginalEditor(), f2 = h(c2.current, e2 || "", t2 || n2 || "text", m2 || "");
        f2 !== i2.getModel() && i2.setModel(f2);
      }
    }, [m2], M2), l(() => {
      if (u2.current && c2.current) {
        let i2 = u2.current.getModifiedEditor(), f2 = h(c2.current, r2 || "", a2 || n2 || "text", E2 || "");
        f2 !== i2.getModel() && i2.setModel(f2);
      }
    }, [E2], M2), l(() => {
      let i2 = u2.current.getModifiedEditor();
      i2.getOption(c2.current.editor.EditorOption.readOnly) ? i2.setValue(r2 || "") : r2 !== i2.getValue() && (i2.executeEdits("", [{ range: i2.getModel().getFullModelRange(), text: r2 || "", forceMoveMarkers: true }]), i2.pushUndoStop());
    }, [r2], M2), l(() => {
      var _a2, _b;
      (_b = (_a2 = u2.current) == null ? void 0 : _a2.getModel()) == null ? void 0 : _b.original.setValue(e2 || "");
    }, [e2], M2), l(() => {
      let { original: i2, modified: f2 } = u2.current.getModel();
      c2.current.editor.setModelLanguage(i2, t2 || n2 || "text"), c2.current.editor.setModelLanguage(f2, a2 || n2 || "text");
    }, [n2, t2, a2], M2), l(() => {
      var _a2;
      (_a2 = c2.current) == null ? void 0 : _a2.editor.setTheme(x2);
    }, [x2], M2), l(() => {
      var _a2;
      (_a2 = u2.current) == null ? void 0 : _a2.updateOptions(y2);
    }, [y2], M2);
    let L2 = reactExports.useCallback(() => {
      var _a2;
      if (!c2.current)
        return;
      o2.current(c2.current);
      let i2 = h(c2.current, e2 || "", t2 || n2 || "text", m2 || ""), f2 = h(c2.current, r2 || "", a2 || n2 || "text", E2 || "");
      (_a2 = u2.current) == null ? void 0 : _a2.setModel({ original: i2, modified: f2 });
    }, [n2, r2, a2, e2, t2, m2, E2]), U2 = reactExports.useCallback(() => {
      var _a2;
      !b2.current && w2.current && (u2.current = c2.current.editor.createDiffEditor(w2.current, { automaticLayout: true, ...y2 }), L2(), (_a2 = c2.current) == null ? void 0 : _a2.editor.setTheme(x2), O2(true), b2.current = true);
    }, [y2, x2, L2]);
    reactExports.useEffect(() => {
      M2 && d2.current(u2.current, c2.current);
    }, [M2]), reactExports.useEffect(() => {
      !T2 && !M2 && U2();
    }, [T2, M2, U2]);
    function I2() {
      var _a2, _b, _c, _d;
      let i2 = (_a2 = u2.current) == null ? void 0 : _a2.getModel();
      g2 || ((_b = i2 == null ? void 0 : i2.original) == null ? void 0 : _b.dispose()), N2 || ((_c = i2 == null ? void 0 : i2.modified) == null ? void 0 : _c.dispose()), (_d = u2.current) == null ? void 0 : _d.dispose();
    }
    return React$1.createElement(H, { width: z2, height: V2, isEditorReady: M2, loading: P2, _ref: w2, className: F2, wrapperProps: j2 });
  }
  var ie = Oe;
  reactExports.memo(ie);
  function He(e2) {
    let r2 = reactExports.useRef();
    return reactExports.useEffect(() => {
      r2.current = e2;
    }, [e2]), r2.current;
  }
  var se = He;
  var _ = /* @__PURE__ */ new Map();
  function Ve({ defaultValue: e2, defaultLanguage: r2, defaultPath: n2, value: t2, language: a2, path: m2, theme: E2 = "light", line: g2, loading: N2 = "Loading...", options: x2 = {}, overrideServices: P2 = {}, saveViewState: y2 = true, keepCurrentModel: V2 = false, width: z2 = "100%", height: F2 = "100%", className: j2, wrapperProps: A2 = {}, beforeMount: q2 = D, onMount: M2 = D, onChange: O2, onValidate: T2 = D }) {
    let [s2, u2] = reactExports.useState(false), [c2, w2] = reactExports.useState(true), d2 = reactExports.useRef(null), o2 = reactExports.useRef(null), b2 = reactExports.useRef(null), L2 = reactExports.useRef(M2), U2 = reactExports.useRef(q2), I2 = reactExports.useRef(), i2 = reactExports.useRef(t2), f2 = se(m2), Q2 = reactExports.useRef(false), B2 = reactExports.useRef(false);
    k(() => {
      let p2 = loader.init();
      return p2.then((R2) => (d2.current = R2) && w2(false)).catch((R2) => (R2 == null ? void 0 : R2.type) !== "cancelation" && console.error("Monaco initialization: error:", R2)), () => o2.current ? pe2() : p2.cancel();
    }), l(() => {
      var _a2, _b, _c, _d;
      let p2 = h(d2.current, e2 || t2 || "", r2 || a2 || "", m2 || n2 || "");
      p2 !== ((_a2 = o2.current) == null ? void 0 : _a2.getModel()) && (y2 && _.set(f2, (_b = o2.current) == null ? void 0 : _b.saveViewState()), (_c = o2.current) == null ? void 0 : _c.setModel(p2), y2 && ((_d = o2.current) == null ? void 0 : _d.restoreViewState(_.get(m2))));
    }, [m2], s2), l(() => {
      var _a2;
      (_a2 = o2.current) == null ? void 0 : _a2.updateOptions(x2);
    }, [x2], s2), l(() => {
      !o2.current || t2 === void 0 || (o2.current.getOption(d2.current.editor.EditorOption.readOnly) ? o2.current.setValue(t2) : t2 !== o2.current.getValue() && (B2.current = true, o2.current.executeEdits("", [{ range: o2.current.getModel().getFullModelRange(), text: t2, forceMoveMarkers: true }]), o2.current.pushUndoStop(), B2.current = false));
    }, [t2], s2), l(() => {
      var _a2, _b;
      let p2 = (_a2 = o2.current) == null ? void 0 : _a2.getModel();
      p2 && a2 && ((_b = d2.current) == null ? void 0 : _b.editor.setModelLanguage(p2, a2));
    }, [a2], s2), l(() => {
      var _a2;
      g2 !== void 0 && ((_a2 = o2.current) == null ? void 0 : _a2.revealLine(g2));
    }, [g2], s2), l(() => {
      var _a2;
      (_a2 = d2.current) == null ? void 0 : _a2.editor.setTheme(E2);
    }, [E2], s2);
    let X2 = reactExports.useCallback(() => {
      var _a2;
      if (!(!b2.current || !d2.current) && !Q2.current) {
        U2.current(d2.current);
        let p2 = m2 || n2, R2 = h(d2.current, t2 || e2 || "", r2 || a2 || "", p2 || "");
        o2.current = (_a2 = d2.current) == null ? void 0 : _a2.editor.create(b2.current, { model: R2, automaticLayout: true, ...x2 }, P2), y2 && o2.current.restoreViewState(_.get(p2)), d2.current.editor.setTheme(E2), g2 !== void 0 && o2.current.revealLine(g2), u2(true), Q2.current = true;
      }
    }, [e2, r2, n2, t2, a2, m2, x2, P2, y2, E2, g2]);
    reactExports.useEffect(() => {
      s2 && L2.current(o2.current, d2.current);
    }, [s2]), reactExports.useEffect(() => {
      !c2 && !s2 && X2();
    }, [c2, s2, X2]), i2.current = t2, reactExports.useEffect(() => {
      var _a2, _b;
      s2 && O2 && ((_a2 = I2.current) == null ? void 0 : _a2.dispose(), I2.current = (_b = o2.current) == null ? void 0 : _b.onDidChangeModelContent((p2) => {
        B2.current || O2(o2.current.getValue(), p2);
      }));
    }, [s2, O2]), reactExports.useEffect(() => {
      if (s2) {
        let p2 = d2.current.editor.onDidChangeMarkers((R2) => {
          var _a2;
          let G2 = (_a2 = o2.current.getModel()) == null ? void 0 : _a2.uri;
          if (G2 && R2.find((J2) => J2.path === G2.path)) {
            let J2 = d2.current.editor.getModelMarkers({ resource: G2 });
            T2 == null ? void 0 : T2(J2);
          }
        });
        return () => {
          p2 == null ? void 0 : p2.dispose();
        };
      }
      return () => {
      };
    }, [s2, T2]);
    function pe2() {
      var _a2, _b;
      (_a2 = I2.current) == null ? void 0 : _a2.dispose(), V2 ? y2 && _.set(m2, o2.current.saveViewState()) : (_b = o2.current.getModel()) == null ? void 0 : _b.dispose(), o2.current.dispose();
    }
    return React$1.createElement(H, { width: z2, height: F2, isEditorReady: s2, loading: N2, _ref: b2, className: j2, wrapperProps: A2 });
  }
  var fe = Ve;
  var de = reactExports.memo(fe);
  var Ft = de;
  const Editor = "";
  const FeedbackDropdown = ({
    toggleFeedbackVisibility,
    direction
  }) => {
    const {
      compilerSocket,
      token,
      videoTutorial,
      isTesteable,
      setOpenedModals,
      runExerciseTests,
      bc_token,
      openLink,
      checkRigobotInvitation,
      hasSolution,
      getCurrentExercise,
      // currentExercisePosition,
      updateEditorTabs,
      toggleRigo,
      setShowVideoTutorial
    } = useStore((state) => ({
      compilerSocket: state.compilerSocket,
      token: state.token,
      setFeedbackButtonProps: state.setFeedbackButtonProps,
      fetchExercises: state.fetchExercises,
      videoTutorial: state.videoTutorial,
      isTesteable: state.isTesteable,
      setOpenedModals: state.setOpenedModals,
      runExerciseTests: state.runExerciseTests,
      setTestResult: state.setTestResult,
      toastFromStatus: state.toastFromStatus,
      bc_token: state.bc_token,
      openLink: state.openLink,
      checkRigobotInvitation: state.checkRigobotInvitation,
      hasSolution: state.hasSolution,
      currentSolution: state.currentSolution,
      getCurrentExercise: state.getCurrentExercise,
      currentExercisePosition: state.currentExercisePosition,
      updateEditorTabs: state.updateEditorTabs,
      toggleRigo: state.toggleRigo,
      setShowVideoTutorial: state.setShowVideoTutorial
    }));
    const { t: t2 } = useTranslation();
    const runTests = () => {
      toggleFeedbackVisibility();
      runExerciseTests({
        toast: true,
        setFeedbackButton: true,
        feedbackButtonText: t2("Running..."),
        targetButton: "feedback"
      });
    };
    const openLoginModal = () => {
      setOpenedModals({ login: true });
      toggleFeedbackVisibility();
    };
    const redirectToVideo = () => {
      setShowVideoTutorial(true);
      toggleFeedbackVisibility();
    };
    const openLearnpackDocs = () => {
      const docsUrl = "https://4geeks.com/docs/learnpack";
      openLink(docsUrl);
      toggleFeedbackVisibility();
    };
    const showChat = () => {
      toggleRigo();
      toggleFeedbackVisibility();
    };
    const rigoAccepted = async () => {
      checkRigobotInvitation();
    };
    const openSolutionFile = () => {
      const solutionFile = getCurrentExercise().files.find(
        (file) => file.name.includes("solution.hide")
      );
      const data = {
        exerciseSlug: getCurrentExercise().slug,
        files: [solutionFile.path],
        solutionFileName: solutionFile.name,
        updateEditorTabs
      };
      compilerSocket.emit("open", data);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `feedback-dropdown ${direction}`, children: [
      Boolean(token) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          text: t2("Get help from AI"),
          svg: svgs.brainIcon,
          action: showChat
        }
      ) : bc_token ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          svg: svgs.brainIcon,
          text: t2("Get help from AI"),
          action: rigoAccepted
        }
      ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          svg: svgs.fourGeeksIcon,
          text: t2("Login to use AI feedback"),
          action: openLoginModal
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          svg: svgs.testIcon,
          text: isTesteable ? t2("Run tests") : t2("No tests available"),
          action: runTests,
          disabled: !isTesteable
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          text: hasSolution ? t2("Review model solution") : t2("Model solution not available"),
          svg: svgs.solutionIcon,
          disabled: !hasSolution,
          action: hasSolution ? openSolutionFile : () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          text: `Video tutorial ${videoTutorial ? "" : t2("not available")}`,
          disabled: !videoTutorial,
          svg: svgs.videoIcon,
          action: redirectToVideo
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SimpleButton,
        {
          text: t2("About LearnPack"),
          svg: svgs.fourGeeksIcon,
          action: openLearnpackDocs
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        t2("Feedback plays an important role when learning technical skills. "),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          OpenWindowLink,
          {
            text: t2("Learn why"),
            href: "https://4geeks.com/mastering-technical-knowledge#feedback-quality-and-frequency"
          }
        )
      ] })
    ] });
  };
  function FeedbackButton({
    direction = "down"
  }) {
    const { t: t2 } = useTranslation();
    const [showFeedback, setShowFeedback] = reactExports.useState(false);
    let hideFeedbackTimeout;
    const toggleFeedback = () => {
      setShowFeedback((prev2) => !prev2);
    };
    const handleMouseEnter = () => {
      clearTimeout(hideFeedbackTimeout);
      setShowFeedback(true);
    };
    const handleMouseLeave = () => {
      hideFeedbackTimeout = setTimeout(() => {
        setShowFeedback(false);
      }, 200);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        id: "feedback-button",
        className: "pos-relative",
        onMouseEnter: handleMouseEnter,
        onMouseLeave: handleMouseLeave,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleButton,
            {
              text: t2("Get feedback"),
              svg: svgs.feedbackIcon,
              extraClass: `pill color-blue row-reverse`,
              action: toggleFeedback
            }
          ),
          showFeedback && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FeedbackDropdown,
            {
              direction,
              toggleFeedbackVisibility: toggleFeedback
            }
          )
        ]
      }
    );
  }
  const styles$1 = "";
  function ResetButton() {
    const { setOpenedModals } = useStore((state) => ({
      setOpenedModals: state.setOpenedModals
    }));
    const { t: t2 } = useTranslation();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SimpleButton,
      {
        extraClass: "pill color-blue",
        svg: svgs.resetIcon,
        text: t2("Reset"),
        id: "reset-button",
        action: () => setOpenedModals({ reset: true })
      }
    );
  }
  const Dropdown = ({
    children,
    className,
    openingElement,
    spaceBetween = 5
  }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `dropdown ${className}`, children: [
      openingElement,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { gap: spaceBetween }, className: "dropdown-content", children })
    ] });
  };
  function BuildButton({
    extraClass = ""
  }) {
    const { t: t2 } = useTranslation();
    const {
      buildbuttonText,
      setBuildButtonPrompt,
      isBuildable,
      build,
      isTesteable,
      runExerciseTests
    } = useStore((state) => ({
      currentExercisePosition: state.currentExercisePosition,
      exercises: state.exercises,
      compilerSocket: state.compilerSocket,
      buildbuttonText: state.buildbuttonText,
      setBuildButtonPrompt: state.setBuildButtonPrompt,
      isBuildable: state.isBuildable,
      build: state.build,
      isTesteable: state.isTesteable,
      feedbackButtonProps: state.feedbackbuttonProps,
      runExerciseTests: state.runExerciseTests
    }));
    const runTests = () => {
      setBuildButtonPrompt(t2("Running..."), "bg-blue");
      runExerciseTests({
        toast: true,
        setFeedbackButton: false,
        feedbackButtonText: t2("Running..."),
        targetButton: "build"
      });
    };
    const changeToTest = !isBuildable && isTesteable;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SimpleButton,
      {
        id: "build-button",
        text: t2(buildbuttonText.text),
        svg: svgs.buildIcon,
        extraClass: `pill bg-blue ${buildbuttonText.className} ${extraClass}`,
        action: () => {
          changeToTest ? runTests() : build(t2("Running..."));
        },
        disabled: !isBuildable && !isTesteable
      }
    );
  }
  const TestButton = () => {
    const { t: t2 } = useTranslation();
    const { isTesteable, runExerciseTests, feedbackbuttonProps } = useStore((state) => ({
      isTesteable: state.isTesteable,
      runExerciseTests: state.runExerciseTests,
      feedbackbuttonProps: state.feedbackbuttonProps
    }));
    const runTests = () => {
      runExerciseTests({
        toast: true,
        setFeedbackButton: true,
        feedbackButtonText: t2("Running..."),
        targetButton: "feedback"
      });
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SimpleButton,
      {
        extraClass: `rounded big w-100 border-blue color-active ${feedbackbuttonProps.className}`,
        svg: svgs.testIcon,
        text: isTesteable ? t2(feedbackbuttonProps.text) : t2("No tests available"),
        action: runTests,
        disabled: !isTesteable
      }
    );
  };
  const CompileOptions = () => {
    const { t: t2 } = useTranslation();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dropdown, { className: "up", openingElement: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleButton, { svg: svgs.buildIcon, text: t2("Run") }), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BuildButton, { extraClass: "active big w-100" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TestButton, {})
    ] });
  };
  const getTitleFromHTMLString = (html) => {
    const match = html.match(/<title>(.*)<\/title>/);
    return match ? match[1] : "";
  };
  const Preview = ({ html, onTitleRevealed }) => {
    reactExports.useEffect(() => {
      const title = getTitleFromHTMLString(html);
      onTitleRevealed(title ?? window.location.host + "/preview");
    }, []);
    return (
      // <iframe
      //   ref={iframeRef}
      //   className="preview-iframe"
      //   srcDoc={html}
      //   title="HTML Preview"
      //   onLoad={handleLoad}
      // />
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: { width: "100%", height: "100%", border: "none", marginTop: "100px" },
          dangerouslySetInnerHTML: { __html: html }
        }
      )
    );
  };
  const AskForHint = ({ context }) => {
    const { setRigoContext } = useStore((state) => ({
      setRigoContext: state.setRigoContext
    }));
    const { t: t2 } = useTranslation();
    const handleClick = () => {
      setRigoContext(context);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ask-for-hint", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      SimpleButton,
      {
        extraClass: "border-blue padding-medium rounded active-on-hover",
        action: handleClick,
        text: t2("ask-rigo-for-a-hint"),
        svg: svgs.rigoSvg
      }
    ) });
  };
  const languageMap = {
    ".js": "javascript",
    ".py": "python",
    ".css": "css",
    ".html": "html",
    ".jsx": "javascript"
    // Agrega más extensiones y lenguajes según sea necesario
  };
  const getLanguageFromExtension = (fileName) => {
    const extension = fileName.slice(fileName.lastIndexOf("."));
    return languageMap[extension] || "plaintext";
  };
  const CodeEditor = ({
    terminal = "normal",
    hideTerminal
  }) => {
    const {
      tabs,
      setTabs,
      getCurrentExercise,
      updateFileContent,
      cleanTerminal,
      theme,
      updateDBSession
    } = useStore((state) => ({
      tabs: state.editorTabs,
      getCurrentExercise: state.getCurrentExercise,
      updateFileContent: state.updateFileContent,
      cleanTerminal: state.cleanTerminal,
      theme: state.theme,
      updateDBSession: state.updateDBSession,
      setTabs: state.setEditorTabs
    }));
    const { t: t2 } = useTranslation();
    const outputFromMessages = {
      build: t2("terminal"),
      test: t2("tests-feedback")
    };
    const [editorTheme, setEditorTheme] = reactExports.useState("light");
    const [editorStatus, setEditorStatus] = reactExports.useState("UNMODIFIED");
    const [browserTabTitle, setBrowserTabTitle] = reactExports.useState(
      window.location.host + "/preview"
    );
    const debouncedStore = reactExports.useCallback(
      debounce(() => {
        updateDBSession();
      }, 5e3),
      []
    );
    const updateContent = (id2, content) => {
      const newTabs = tabs.map(
        (tab2) => tab2.id === id2 ? { ...tab2, content } : tab2
      );
      setTabs(newTabs);
      const ex = getCurrentExercise();
      const withoutTerminal = newTabs.filter((t22) => t22.name !== "terminal");
      LocalStorage.setEditorTabs(ex.slug, withoutTerminal);
      setEditorStatus("MODIFIED");
      const tab = newTabs.find((t22) => t22.id === id2);
      if (tab) {
        updateFileContent(ex.slug, tab);
        debouncedStore();
      }
    };
    const removeTab = (id2, name2) => {
      if (name2 === "terminal" && hideTerminal) {
        hideTerminal();
        cleanTerminal();
        return;
      }
      const newTabs = tabs.filter((tab) => tab.id !== id2);
      setTabs(newTabs);
      if (newTabs.length > 0) {
        setTabs(
          newTabs.map((tab, index2) => ({
            ...tab,
            isActive: index2 === 0
          }))
        );
      }
    };
    const handleTabClick = (id2) => {
      const newTabs = tabs.map(
        (tab) => tab.id === id2 ? { ...tab, isActive: true } : { ...tab, isActive: false }
      );
      setTabs(newTabs);
    };
    reactExports.useEffect(() => {
      if (theme === "light") {
        setEditorTheme("light");
      } else if (theme === "dark") {
        setEditorTheme("vs-dark");
      }
    }, [theme]);
    reactExports.useEffect(() => {
      const someModified = tabs.some((t22) => Boolean(t22.modified));
      if (someModified) {
        setEditorStatus("MODIFIED");
      }
    }, [tabs]);
    const foundPreviewTitle = (title) => {
      if (!title)
        return;
      setBrowserTabTitle(title);
    };
    const terminalTab = tabs.find((tab) => tab.name === "terminal");
    const filteredTabs = tabs.filter((tab) => tab.name !== "terminal");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: `${tabs.length === 0 ? "none" : "block"}` }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tabs",
          style: { display: terminal === "only" ? "none" : "flex" },
          children: filteredTabs.map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `tab ${tab.isActive ? "active" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handleTabClick(tab.id), children: tab.name.includes("solution.hide") ? t2("model-solution") : tab.name }) }, tab.id))
        }
      ),
      !(terminal === "only") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "editor", children: [
        tabs.map(
          (tab) => tab.isActive && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Ft,
            {
              className: "editor-monaco",
              height: "400px",
              language: getLanguageFromExtension(tab.name),
              theme: editorTheme,
              value: tab.content,
              onChange: (value2) => updateContent(tab.id, value2 || ""),
              options: {
                minimap: {
                  enabled: false
                },
                fontSize: 16,
                bracketPairColorization: {
                  enabled: true
                },
                cursorBlinking: "smooth",
                wordWrap: "off",
                padding: {
                  top: 10,
                  bottom: 0
                },
                scrollbar: {
                  vertical: "hidden",
                  horizontal: "hidden"
                },
                lineNumbersMinChars: 3,
                readOnly: tab.name === "terminal" || tab.name.includes("solution.hide")
              }
            },
            tab.id
          )
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(EditorFooter, { editorStatus })
      ] }),
      terminalTab && !terminalTab.isHTML && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `terminal ${terminal}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h5", { className: "d-flex justify-between align-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: terminalTab && terminalTab.from && outputFromMessages[terminalTab.from] }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => removeTab(terminalTab.id, terminalTab.name), children: "×" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            dangerouslySetInnerHTML: {
              __html: convertMarkdownToHTML(terminalTab.content, false)
            }
          }
        ),
        !getCurrentExercise().done && /* @__PURE__ */ jsxRuntimeExports.jsx(AskForHint, { context: terminalTab.content }),
        terminal === "only" && getCurrentExercise().done && /* @__PURE__ */ jsxRuntimeExports.jsx(EditorFooter, { editorStatus })
      ] }),
      terminalTab && terminalTab.isHTML && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `terminal ${terminal} html browser`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex justify-between align-center browser-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "padding-big browser-tab", children: browserTabTitle }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SimpleButton,
              {
                title: t2("display-another-tab padding-medium"),
                size: "mini",
                svg: svgs.newTab,
                extraClass: "hover rounded",
                action: () => {
                  window.open(
                    `/preview?slug=${getCurrentExercise().slug}`,
                    "__blank"
                  );
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SimpleButton,
              {
                title: t2("close-tab"),
                size: "mini",
                svg: svgs.closeX,
                extraClass: "danger-on-hover rounded",
                action: () => removeTab(terminalTab.id, terminalTab.name)
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "browser-body", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Preview,
          {
            onTitleRevealed: foundPreviewTitle,
            html: terminalTab.content
          }
        ) })
      ] })
    ] });
  };
  const NextButton = () => {
    const { currentExercisePosition, handlePositionChange, exercises } = useStore(
      (state) => ({
        currentExercisePosition: state.currentExercisePosition,
        handlePositionChange: state.handlePositionChange,
        exercises: state.exercises
      })
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SimpleButton,
      {
        disabled: currentExercisePosition === exercises.length - 1,
        action: () => handlePositionChange(Number(currentExercisePosition) + 1),
        svg: svgs.nextArrow,
        text: "Next",
        extraClass: "w-100 bg-success text-white big"
      }
    );
  };
  const EditorFooter = ({ editorStatus }) => {
    const { t: t2 } = useTranslation();
    const { lastState, getCurrentExercise } = useStore((state) => ({
      lastState: state.lastState,
      getCurrentExercise: state.getCurrentExercise
    }));
    const ex = getCurrentExercise();
    let letPass = lastState === "success" && ex.done && editorStatus === "MODIFIED";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `editor-footer ${editorStatus} ${lastState}`, children: [
      letPass && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ResetButton, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NextButton, {})
      ] }),
      editorStatus === "UNMODIFIED" && !letPass && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "not-started", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: svgs.learnpackLogo }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("read-instructions") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackButton, { direction: "up" })
      ] }),
      editorStatus === "MODIFIED" && !letPass && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CompileOptions, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ResetButton, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackButton, { direction: "up" })
      ] })
    ] });
  };
  const Notifier = {
    id: "",
    success: (message) => {
      if (Notifier.id) {
        _t.success(message, { id: Notifier.id });
      } else {
        Notifier.id = _t.success(message);
      }
    },
    loading: (message) => {
      if (Notifier.id) {
        _t.loading(message, { id: Notifier.id });
      } else {
        Notifier.id = _t.loading(message);
      }
    },
    error: (message) => {
      if (Notifier.id) {
        _t.error(message, { id: Notifier.id });
      } else {
        Notifier.id = _t.error(message);
      }
    },
    dismiss: () => {
      if (Notifier.id) {
        _t.dismiss(Notifier.id);
        Notifier.id = "";
      }
    },
    confetti: () => {
      if (typeof window.confetti === "function") {
        window.confetti({
          angle: randomInRange(55, 125),
          spread: randomInRange(50, 70),
          particleCount: randomInRange(50, 100),
          origin: { y: 0.6 }
        });
      }
    }
  };
  const rigoSvgString = `
<svg
      width="30"
      height="30"
      viewBox="0 0 24 14"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M18.4549 2.36911L17.93 1.40069L17.2413 0.129606C17.1479 -0.0432019 16.8817 -0.0432019 16.7883 0.129606L16.0996 1.40069L15.5936 2.33415H5.89392C5.12428 2.33415 4.46601 2.81711 4.19531 3.50085H19.7989C19.5707 2.92499 19.0677 2.49097 18.4549 2.36861V2.36911Z"
        fill="white"
      />
      <path
        d="M22.8283 4.43156H22.2655V4.25426C22.2655 2.67701 20.9839 1.39844 19.4031 1.39844H17.9308L18.4557 2.36686C19.0685 2.48922 19.5715 2.92274 19.7997 3.4991H4.19609C4.46679 2.81536 5.12505 2.3324 5.8947 2.3324H15.5939L16.0998 1.39894H4.59265C3.01191 1.39894 1.73034 2.67751 1.73034 4.25476V4.43206H1.16696C0.96269 4.43206 0.796875 4.59538 0.796875 4.79715V9.66722C0.796875 9.869 0.96269 10.0323 1.16696 10.0323H3.13127V10.2136C3.13127 10.3954 3.1947 10.5622 3.30009 10.6926C3.31507 10.7111 3.33105 10.729 3.34753 10.746C3.381 10.78 3.41746 10.811 3.45691 10.8379C3.51585 10.8784 3.58077 10.9108 3.6502 10.9328C3.71962 10.9548 3.79354 10.9668 3.86995 10.9668H10.5175L11.413 8.1664L11.8166 6.9038C11.8755 6.72001 12.1213 6.72001 12.1802 6.9038L12.5837 8.1664L13.4792 10.9668H20.1273C20.2422 10.9668 20.3506 10.9403 20.4475 10.8924C20.5014 10.8659 20.5514 10.8329 20.5973 10.7945C20.6338 10.764 20.6672 10.7295 20.6977 10.6926C20.7202 10.6646 20.7412 10.6351 20.7596 10.6042C20.8276 10.4903 20.8665 10.3565 20.8665 10.2136V10.0323H22.8283C23.0326 10.0323 23.1984 9.869 23.1984 9.66722V4.79665C23.1984 4.59488 23.0326 4.43156 22.8283 4.43156ZM7.56384 8.1659V9.34109C7.56384 9.59381 7.35507 9.79858 7.09736 9.79858C6.83964 9.79858 6.63088 9.59381 6.63088 9.34109V4.88855C6.63088 4.63583 6.83964 4.43106 7.09736 4.43106C7.35507 4.43106 7.56384 4.63583 7.56384 4.88855V8.1654V8.1659ZM17.3664 8.1659V9.34109C17.3664 9.59381 17.1576 9.79858 16.8999 9.79858C16.6422 9.79858 16.4335 9.59381 16.4335 9.34109V4.88855C16.4335 4.63583 16.6422 4.43106 16.8999 4.43106C17.1576 4.43106 17.3664 4.63583 17.3664 4.88855V8.1654V8.1659Z"
        fill="#080B16"
      />
      <path
        d="M13.4785 10.9664L12.583 8.16606L12.1795 6.90347C12.1205 6.71968 11.8748 6.71968 11.8159 6.90347L11.4123 8.16606L10.5168 10.9664H4.0625V12.1381C4.0625 13.1665 4.88209 14.0001 5.89346 14.0001H18.0999C19.1112 14.0001 19.9308 13.1665 19.9308 12.1381V10.9664H13.4785Z"
        fill="white"
      />
      <path
        d="M7.09929 4.438C6.84158 4.438 6.63281 4.64277 6.63281 4.89549V9.34803C6.63281 9.60075 6.84158 9.80552 7.09929 9.80552C7.35701 9.80552 7.56577 9.60075 7.56577 9.34803V4.89499C7.56577 4.64227 7.35701 4.4375 7.09929 4.4375V4.438Z"
        fill="#E95B17"
      />
      <path
        d="M16.8962 4.438C16.6385 4.438 16.4297 4.64277 16.4297 4.89549V9.34803C16.4297 9.60075 16.6385 9.80552 16.8962 9.80552C17.1539 9.80552 17.3626 9.60075 17.3626 9.34803V4.89499C17.3626 4.64227 17.1539 4.4375 16.8962 4.4375V4.438Z"
        fill="#0096CF"
      />
    </svg>
`;
  const currentQuiz = {
    lastExecution: null
  };
  function LessonContent() {
    const { currentContent, openLink, toastFromStatus, setRigoContext } = useStore((state) => ({
      currentContent: state.currentContent,
      openLink: state.openLink,
      toastFromStatus: state.toastFromStatus,
      setRigoContext: state.setRigoContext
    }));
    const { t: t2 } = useTranslation();
    const lessonContentRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      var _a2;
      const lessonContentDiv = lessonContentRef.current;
      if (!lessonContentDiv)
        return;
      const parents = lessonContentDiv.getElementsByClassName("contains-task-list");
      const anchors = lessonContentDiv.getElementsByTagName("a");
      const codes = lessonContentDiv.getElementsByTagName("code");
      const handleClick = (event) => {
        event.preventDefault();
        openLink(event.target.href);
      };
      const handleCodeClick = (event) => {
        const codeText = event.target.textContent;
        navigator.clipboard.writeText(codeText);
        _t.success(t2("code-copied"));
      };
      const handleRigoClick = () => {
        const quizJson = JSON.stringify(currentQuiz, null, 2);
        setRigoContext(quizJson);
      };
      const handleSubmit = () => {
        var _a3;
        const quiz = Object.values(currentQuiz);
        let anyIncorrect = false;
        let correctAnswers = 0;
        const selections = quiz.filter((q2) => Boolean(q2 && q2.title)).map((q2) => {
          const isCorrect = q2.currentSelection === q2.correctAnswer;
          if (!isCorrect) {
            anyIncorrect = true;
          } else {
            correctAnswers++;
          }
          return {
            question: q2.title,
            answer: q2.currentSelection,
            isCorrect
          };
        });
        const totalQuestions = selections.length;
        const percentage = correctAnswers / totalQuestions * 100;
        const evaluation = {
          status: anyIncorrect ? "ERROR" : "SUCCESS",
          // correctAnswers,
          percentage,
          selections
        };
        for (let group of parents) {
          const previousElement = group.previousElementSibling;
          const groupTitle = (_a3 = previousElement == null ? void 0 : previousElement.textContent) == null ? void 0 : _a3.trim();
          if (!groupTitle)
            return;
          const checkboxes = group.getElementsByClassName("task-list-item");
          const checkboxesArray = Array.from(checkboxes);
          checkboxesArray.forEach((checkbox) => {
            const inputElement = checkbox.querySelector("input[type='checkbox']");
            const isChecked = inputElement ? inputElement.checked : false;
            if (!isChecked) {
              checkbox.classList.remove("bg-success");
              checkbox.classList.remove("bg-fail");
              return;
            }
            const isCorrect = (
              // @ts-ignore
              currentQuiz[groupTitle].correctAnswer === checkbox.textContent.trim()
            );
            if (isCorrect) {
              checkbox.classList.add("bg-success");
              console.log("correctAnswer", checkbox.textContent.trim());
            } else {
              checkbox.classList.add("bg-fail");
              console.log("wrong", checkbox.textContent.trim());
            }
          });
        }
        currentQuiz.lastExecution = { ...evaluation };
        if (anyIncorrect) {
          toastFromStatus("quiz-error");
          return;
        }
        toastFromStatus("quiz-success");
        Notifier.confetti();
      };
      const handleCheckboxClick = (event) => {
        var _a3;
        const checkbox = event.target.closest(".task-list-item");
        const parent = event.target.closest(".contains-task-list");
        const previousElement = parent.previousElementSibling;
        const groupTitle = (_a3 = previousElement == null ? void 0 : previousElement.textContent) == null ? void 0 : _a3.trim();
        currentQuiz[groupTitle].currentSelection = checkbox.textContent.trim();
        const checkboxes = parent.getElementsByClassName("task-list-item");
        for (let checkbox2 of checkboxes) {
          checkbox2.classList.remove("bg-success");
          checkbox2.classList.remove("bg-fail");
          const inputElement2 = checkbox2.querySelector("input[type='checkbox']");
          if (inputElement2) {
            inputElement2.checked = false;
          }
        }
        const inputElement = checkbox.querySelector("input[type='checkbox']");
        if (inputElement) {
          inputElement.checked = true;
        }
      };
      for (let anchor of anchors) {
        anchor.addEventListener("click", handleClick);
      }
      for (let code2 of codes) {
        code2.addEventListener("dblclick", handleCodeClick);
        code2.title = t2("double-click-to-copy");
      }
      let counter = 0;
      for (let group of parents) {
        const checkboxes = group.getElementsByClassName("task-list-item");
        const previousElement = group.previousElementSibling;
        const groupTitle = (_a2 = previousElement == null ? void 0 : previousElement.textContent) == null ? void 0 : _a2.trim();
        const checkboxesArray = Array.from(checkboxes);
        let correctAnswer = "";
        currentQuiz[groupTitle] = {
          title: groupTitle,
          totalQuestions: checkboxes.length,
          checkboxes: checkboxesArray.map((checkbox) => {
            const inputElement = checkbox.querySelector("input[type='checkbox']");
            const isChecked = inputElement ? inputElement.checked : false;
            if (isChecked) {
              correctAnswer = checkbox.textContent.trim();
            }
            inputElement.cheched = false;
            return {
              text: checkbox.textContent.trim(),
              isCorrect: inputElement ? inputElement.checked : false
            };
          }),
          correctAnswer
        };
        checkboxesArray.forEach((checkbox) => {
          const inputElement = checkbox.querySelector("input[type='checkbox']");
          checkbox.addEventListener("click", handleCheckboxClick);
          if (inputElement) {
            inputElement.checked = false;
          }
        });
        if (counter === parents.length - 1) {
          const lastGroupParent = group.parentElement;
          const quizButtonsContainer = document.createElement("div");
          quizButtonsContainer.className = "quiz-buttons-container";
          const quizButton = document.createElement("button");
          const rigoButton = document.createElement("button");
          const textSpan = document.createElement("span");
          textSpan.textContent = t2("ask-rigo-for-a-hint");
          const svgSpan = document.createElement("span");
          svgSpan.innerHTML = rigoSvgString;
          rigoButton.appendChild(textSpan);
          rigoButton.appendChild(svgSpan);
          quizButton.textContent = t2("submit-quiz");
          quizButton.className = "quiz-button my-2 active-on-hover";
          rigoButton.className = "quiz-button my-2 active-on-hover";
          quizButton.addEventListener("click", handleSubmit);
          rigoButton.addEventListener("click", handleRigoClick);
          if (lastGroupParent) {
            lastGroupParent.appendChild(quizButtonsContainer);
            quizButtonsContainer.appendChild(quizButton);
            quizButtonsContainer.appendChild(rigoButton);
          }
        }
        counter++;
      }
      return () => {
        for (let anchor of anchors) {
          anchor.removeEventListener("click", handleClick);
        }
        for (let code2 of codes) {
          code2.removeEventListener("dblclick", handleCodeClick);
        }
        for (let group of parents) {
          const checkboxes = group.getElementsByClassName("task-list-item");
          for (let checkbox of checkboxes) {
            checkbox.removeEventListener("click", handleCheckboxClick);
          }
        }
        Object.keys(currentQuiz).forEach((key) => {
          delete currentQuiz[key];
        });
        const quizButtonsContainer = document.querySelector(
          ".quiz-buttons-container"
        );
        if (quizButtonsContainer) {
          quizButtonsContainer.remove();
        }
      };
    }, [currentContent]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "lesson-content",
        ref: lessonContentRef,
        dangerouslySetInnerHTML: {
          __html: convertMarkdownToHTML(currentContent)
        }
      }
    );
  }
  const styles = "";
  const Alert = ({ children }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "alert", children });
  };
  function LessonContainer({
    children,
    continueAction
  }) {
    var _a2, _b;
    const { t: t2 } = useTranslation();
    const [alerts, setAlerts] = reactExports.useState({
      incrementalTest: false,
      agent: true
    });
    const {
      exercises,
      getCurrentExercise,
      configObject,
      isTesteable,
      editorTabs
    } = useStore((state) => ({
      getCurrentExercise: state.getCurrentExercise,
      exercises: state.exercises,
      configObject: state.configObject,
      isTesteable: state.isTesteable,
      editorTabs: state.editorTabs
    }));
    reactExports.useEffect(() => {
      const current = getCurrentExercise();
      if (current === void 0 || !configObject || !configObject.config)
        return;
      setAlerts((prevAlerts) => ({
        ...prevAlerts,
        incrementalTest: configObject.config.grading === "incremental" && !current.done && isTesteable
      }));
    }, [exercises, configObject]);
    const handleHideAlert = (alertName) => {
      setAlerts((prevAlerts) => ({
        ...prevAlerts,
        [alertName]: false
      }));
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lesson-container-component", children: [
      alerts.incrementalTest && /* @__PURE__ */ jsxRuntimeExports.jsx("blockquote", { children: t2("incremental-test-alert") }),
      ((_b = (_a2 = configObject == null ? void 0 : configObject.config) == null ? void 0 : _a2.warnings) == null ? void 0 : _b.agent) && alerts.agent && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "d-flex space-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          t2("agent-mismatch-error"),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            OpenWindowLink,
            {
              href: "https://4geeks.com/lesson/agent-vs-mode",
              text: "Read more"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handleHideAlert("agent"), children: "Hide" })
      ] }) }),
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(LessonContent, {}),
      ENVIRONMENT === "localStorage" && continueAction && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          onClick: continueAction,
          className: `badge bg-blue ${editorTabs.length > 0 ? "hide-continue-button" : ""}`,
          children: t2("continue")
        }
      )
    ] });
  }
  const Container = () => {
    const [isMobile, setIsMobile] = reactExports.useState(
      window.innerWidth <= 768 ? true : false
    );
    const [visibleTab, setVisibleTab] = reactExports.useState(
      window.innerWidth <= 768 ? "instructions" : "all"
    );
    const instructionsSectionRef = reactExports.useRef(null);
    const {
      editorTabs,
      handleNext,
      environment,
      terminalShouldShow,
      setTerminalShouldShow
    } = useStore((s2) => ({
      editorTabs: s2.editorTabs,
      handleNext: s2.handleNext,
      environment: s2.environment,
      setEditorTabs: s2.setEditorTabs,
      terminalShouldShow: s2.terminalShouldShow,
      setTerminalShouldShow: s2.setTerminalShouldShow
    }));
    const { t: t2 } = useTranslation();
    const onChangeTab = (tabName) => {
      if (tabName === "terminal" && !editorTabs.some((t22) => t22.name === "terminal")) {
        _t.error(t2("compile-first"));
        return;
      }
      if (tabName === "code") {
        setTerminalShouldShow(false);
      }
      setVisibleTab(tabName);
    };
    const hideTerminal = () => {
      setVisibleTab("code");
    };
    reactExports.useEffect(() => {
      const handleResize = () => {
        if (window.innerWidth > 768) {
          setVisibleTab("all");
          setIsMobile(false);
        }
        if (window.innerWidth <= 768) {
          if (visibleTab === "all") {
            setVisibleTab("instructions");
          }
          setIsMobile(true);
        }
      };
      window.addEventListener("resize", handleResize);
      return () => {
        window.removeEventListener("resize", handleResize);
      };
    }, [visibleTab]);
    reactExports.useEffect(() => {
      const isTerminalActive = editorTabs.some((t22) => t22.name === "terminal");
      if (isTerminalActive && isMobile && terminalShouldShow) {
        setVisibleTab("terminal");
      }
      if (editorTabs.length === 0) {
        if (window.innerWidth > 768) {
          setVisibleTab("all");
        } else {
          setVisibleTab("instructions");
        }
      }
      if (instructionsSectionRef.current) {
        instructionsSectionRef.current.scrollTo({
          top: 0,
          behavior: "smooth"
        });
      }
    }, [editorTabs, terminalShouldShow]);
    const handleLessonContinue = () => {
      if (isMobile && editorTabs.length > 0) {
        setVisibleTab("code");
        return;
      } else if (!isMobile && editorTabs.length > 0) {
        console.log("Start coding at the right!");
      } else {
        handleNext();
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { className: styles$2.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.appTabs, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            onClick: () => onChangeTab("instructions"),
            "data-visible": visibleTab === "instructions" ? true : false,
            children: t2("instructions")
          }
        ),
        editorTabs.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: () => onChangeTab("code"),
              "data-visible": visibleTab === "code" ? true : false,
              children: t2("code")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: () => onChangeTab("terminal"),
              "data-visible": visibleTab === "terminal" ? true : false,
              children: t2("output")
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "section",
        {
          ref: instructionsSectionRef,
          style: {
            display: visibleTab === "instructions" || visibleTab === "all" ? "block" : "none"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(LessonContainer, { continueAction: handleLessonContinue, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { className: "hiddenOnMobile active-hr", children: [
            " ",
            t2("instructions"),
            " "
          ] }) })
        }
      ),
      editorTabs.length > 0 && !(environment === "localhost") && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "section",
        {
          style: {
            display: visibleTab === "code" || visibleTab === "all" ? "block" : "none"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CodeEditor, { terminal: isMobile ? "hidden" : "normal" })
        }
      ),
      !(environment === "localhost") && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "section",
        {
          style: {
            display: visibleTab === "terminal" ? "block" : "none"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CodeEditor, { hideTerminal, terminal: "only" })
        }
      )
    ] });
  };
  function Home() {
    const { start, handleEnvironmentChange, theme, isIframe } = useStore((s2) => ({
      environment: s2.environment,
      start: s2.start,
      handleEnvironmentChange: s2.handleEnvironmentChange,
      theme: s2.theme,
      isIframe: s2.isIframe
      // startTelemetry: s.startTelemetry,
    }));
    reactExports.useEffect(() => {
      start();
      document.addEventListener("environment-change", handleEnvironmentChange);
      return () => {
        document.removeEventListener(
          "environment-change",
          handleEnvironmentChange
        );
      };
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "main",
      {
        id: "main-container",
        className: `${theme} ${isIframe ? "iframe-mode" : ""}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ShortcutsListener, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ModalsContainer, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SocketHandler, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NewHeader, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Container, {})
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Ie, {})
        ]
      }
    );
  }
  const Layout = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {});
  };
  const previewLoader = async () => {
    const htmlString = LocalStorage.get(`htmlString`, false);
    return { htmlString };
  };
  const PreviewHTMLPage = () => {
    const { htmlString } = useLoaderData();
    const [previewTitle, setPreviewTitle] = reactExports.useState("");
    const foundPreviewTitle = (title) => {
      setPreviewTitle(title);
    };
    reactExports.useEffect(() => {
      console.log(previewTitle);
    }, [previewTitle]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "vh100 overflow-y-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Preview, { onTitleRevealed: foundPreviewTitle, html: htmlString }) });
  };
  const tagManagerArgs = {
    gtmId: "GTM-WCVQ4KJ",
    auth: "UziHoBlMGYrHZqefka0uXg",
    env: "env-1"
  };
  TagManager.initialize(tagManagerArgs);
  const router = createBrowserRouter([
    {
      path: "/",
      element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, {}),
      children: [
        {
          path: "/",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(Home, {})
        },
        {
          path: "/preview",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(PreviewHTMLPage, {}),
          loader: previewLoader
        }
      ]
    }
  ]);
  client.createRoot(document.getElementById("root")).render(
    /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }) })
  );
})();
//# sourceMappingURL=index.js.map
